wish =

we had the ability to drive thought routes 

e.g.,

@[driver] role 

with the skills of 

<route.stone.prune> --which $glob 
  --which is required; can be *
  --prunes only the unused source stones (unused .src | .stone | .guard files)

<route.stone.get> --which @next-one | @next-all | $glob [--say] 
  --say -> echos into stdout 
  --which @next-one grabs one next one available
  --which @next-all grabs all next ones available

<route.stone.set> --which $stone --as passed 
  --as done triggers verification 
    -- first, the $stone actually must have been filled 
    -- next, if there are .guard#reviews enumerated, each review must be or have been run already on this versionHash of the target content (i.e., findsert .guard.grade.$hash.r$1.md) 
    -- next, if there are .guard#reviews enumerated then we require a .guard#judge which assesses the grades and emits a pass | fail and must have been or be run (i.e., findsert.guard.judge.$hash.md) 
    -- last, if there was a judge, then its judgement file will have yml frontmatter which we can deterministically parse to grab the judgement of pass | fail
    -- if pass, then approve the set
    -- if fail, then notify them that the guard.judge has blocked their stone pass; they must loop back and address the review and judgement feedback before they can pass this milestone  


---


the objective of this skill is to enable

1. easy assessment of "whats next?" -> what's next on the thought route; which is the next milestone to achieve

	e.g., any robot can now say 

	<route.stone.get> --which @next-one --on path/to/routedir

	for eample

	<route.stone.get> @next-one --on .behavior/2026-02-01.driver-route-stones


	which will get the command to lookup all of the .src | .stone files (.src as the historic alias for .stone) 

	and figure out, via alphanumeric sort of the .stones in that route dir, which stone is next

	---

	it can track whether a stone has been completed or not via 
	1. if there's a .guard for that .stone 
		e.g., 
			- .behavior/2026-02-01.driver-route-stones/1.vision.stone.guard 
			for
			- .behavior/2026-02-01.driver-route-stones/1.vision.stone	

		then, there must be a .pass for that stone
			i.e., they've passed the guard
			i.e., they've passed the milestone

	---

	each .stone file must have a alphanumeric prefix 

	1.
	2.1
	2.2

	multiple files can have the samae prefix 

	3.1.research.x
	3.1.research.y
	etc

	when multiple files have the same prefix, this means that they do not depend on eachother and can be executed in parallel

	when asked for --stone @next-one, we always grab the next alphanumeric stone

	when asked for --stone @next-all, we always grab the next alphanumeric stones that have the same numeric prefix (this is what unlocks the capacity to determine whether we can do stones in parallel, to shorten walltime)


2. easy assessment of "can i pass?" -> what are the conditions required to pass 	

	for many .stones, there wont be a .guard - and the only condition to pass is that there's a .md produced for that stone 
	
		e.g., .behavior/2026-02-01.driver-route-stones/1.vision.stone would have a .behavior/2026-02-01.driver-route-stones/1.vision.md artifact produced for it 

		before we'd allow .behavior/2026-02-01.driver-route-stones/2.1.criteria.blackbox.stone to be next

		this enables us to chain order of operations along a thought route 

		i.e., you cant pass milestone 3 unless you pass milestone 1 on the route


	for other .stones, there will be a .guard - and that guard will prescribe the reviews and judge that decides whether you can pass that milestone based on the output of your current artifact 
		
		e.g., for some cases, there will be no reviews, and the judge simply waits for a human to have said '.stone.approved', so that we can gate milestones on human approval 
			e.g., the vision; only the human that declared the wish really knows what the vision was. they may not have articulated it sufficiently in the wish and so the only way to tell whether the vision aligns with their wish is to get their explicit confirmation and feedback; hence, human approval gate
			- this is a deterministic judge, which can be signified in the guard file via 
				.guard = `- judge: npx rhachet run --skill route.stone.judge --mechanism approved? --stone $stone --on $route`
				which simply prescribes the shell cmd to run to get execute the judgement; that skill will know where to write the .judge file and how; (also, this skill will need to be included in this release, given how common it is)  

		e.g., for other cases, there will be reviews and an allpass judge, where each review must be fully passed before the judge approves it 
			- e.g., each review file will have a frontmatter of `- blockers` and `- nitpicks` 
			and the judge iwll be specified to have a threshold of `- judge: npx rhachet run --skill route.stone.judge --mechanism reviewed? --stone $stone --on $route --allow-blockers 0 --allow-nitpicks 1` (e.g., allow up to 1 nitpick, but zero blockers )	
			i.e., a deterministic judge again, aliasable via the syntax above; bundled with the driver, given how generic it is again 	


			- where the reviews are specified as a list of shell commands to execute which will produce the review files. e.g., `npx rhachet run --skill review ... > .behavior/2026-02-01.driver-route-stones/2.1.criteria.blackbox.stone.guard.review.$hash.r1.md`

		e.g., for other cases, there will be a probabalistic judge. for now, the user can define a probabilistic judge via their own cmd if they want. the only contract is that it writes the the .stone.guard.judge file for the hash, so that this <route.stone.set> --as passed command can evaluate whether it was passed


	and in all cases with a .guard, the <route.stone.set> command will first check if the artifact it needs is already supplied 
		e.g., if for the $hash of the artifact assets (.artifacts = a property of the .guard yml) (e.g., .artifacts = 1.vision.md -vs- .artifacts = src/*)  there's already the .judge.$hash.md then reuse it ; same with the .reviews;  that way we dont trigger redundant compute on partial failures when priors have succeeded for the same hash


3. easy cleanup of the route dirs  
	
	e.g., its common that routes are prescribed with more milestones than required

	often, a human goes in and curates which ones they want the brain to stop at along their journey; 

	e.g., "for this one, we dont need to distill terms or look at templates"
	- `<route.stone.prune> --stone *.research.template* --on $route`
	- `<route.stone.prune> --stone *.research.domain* --on $route`

	it should naturally failfast if that route was already stopped at; i.e., if there's an artifact for it, to prevent loss of history (i.e., what produced this artifact?)

	but if the stone was unused, then no need to keep it. can easily prune it


---

a surgoal of this work is also to formalize the concept of a Route ; a thought Route that can be navigated 

i.e., most often, rigid skills are declared in terms of Routes 

thought routes composed of .src prompts that specify what directions a brain should take next to curate the progress of their thought

you can think of it as instructions (printoff mapquest style) which guide a brain along some journey to reach a conceptual destination

along the way, their context and knowledge is curated, so that they can successfully reach the objective that is desired

the key unlock of thought routes is that most objectives in life are achievable via reusalbe thought routes

thought routes are related to strategy, in that strategy allows for dynamic rearangement of thought routes in response to observations

so, a route is a primitive that will eventually be used to compose the concept of a strategy

but before we get to strategy, we need to formalize what a route is

and before we even need strategies, we already have multiple usecases where thought routes are critical and we want to get the human out of the navigator seat, so that robots can navigate themselves along the thought route, and produce more powerful rigid skills

eamples of current thought routes in the critical path of active production use  
- init.behavior (by bhuild)
- init.repair (by ghlitch)

---

at the end of this, instead of a human sitting around and copy pasting the .src files one after another into the mechanic role which then executes them (e.g., as part of init.behavior)

the human should simply be able to 
1. prune the route, based on their expectations (in the future, a robot will do this too; likely, the one that wrote the route; this is where strategy begins to intersect. for now, a human will do it)
2. then, tell the robot to run the `npx rhachet run --skill route.stone.get --stone @next-one --route $path/to/behavior --say`
which will then echo the next stone into their brain

then, once they think they're done, the human can tell the robot to run the 

`npx rhachet run --skill route.stone.set --stone $stone --route $path/to/behavior --as passed`

which will kickoff the .guard to review and judge and respond whether or not they've passed

at which point, the robot will know to either fix the judged defects or that they've achived the milestone 

---

the next step, which we will roll as part of a separate behavior pr, is the hook that enables the robot to know what to do next on their own

i.e., 
1. <route.bind> --route $path/to/behavior (which would drop a @gitroot/.route/.bind.brain flag that binds this branch to a given route; in the future, we'll prescribe which brain is bound to the route, but for now, assume one brain per route)

and a hook, which 
- onStop, runs the route.stone.set --as passed, on the active stone (stone active also tracked in @gitroot/.route/.bind.brain) 
- onBoot, runs the route.stone.get --say on the active stone 

that way, 
- onStop, it guarantees that the robot brain has finished their work - and prompts them to continue until they're done (naturally, the .guard should track the number of attempts a brain had at passing, and if > 11, halt, since there may be an infiloop)
- onBoot, it guarantees that the robot brain remembers the stone source instructions, so they're aligned with what theyre working on and dont forget the instructions as they progress along the route between stones (some stones are far appart) 



---


                                                  
  ‚ùØ lets also update the criteria to persist the reviewer and judge output under .route within the route dir; not right       
    next to the files, to minmize noise. same filename, but under $route/.route/ ; the .guard and .approved can still be      
    toplevel though (as will be the .stone and .md artifacts); also, expect support for *.md between the stone file name      
    and the artifact name (e.g., they may have their own versioning schemes and etc)   
