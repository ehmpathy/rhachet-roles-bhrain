# blueprint: route.bind

## summary

add a `route.bind` skill that associates a route path with the current git branch, stored as a flag file inside the route's own `.route/` directory. modify all `route.stone.*` cli commands to auto-resolve `--route` from the bind when absent.

---

## domain objects

### RouteBind (value object)

```ts
{
  branch: string;        // original branch name (e.g., "vlad/driver-route-bind")
  branchFlat: string;    // flattened name (e.g., "vlad.driver-route-bind")
  route: string;         // absolute path to the route directory
  flagPath: string;      // absolute path to the .bind flag file
}
```

not a formal `DomainLiteral` class — just a typed shape used internally by bind operations. the flag file location IS the route path (parent of `.route/`), so no `route:` field is stored in the file itself.

### flag file format

```
branch: vlad/driver-route-bind
bound_by: route.bind skill
```

filename: `.bind.<flattened-branch>.flag` (inside `<route-dir>/.route/`)

---

## domain operations

### getRouteBindByBranch

```
input:  { branch: string | null }
output: { route: string } | null
```

the core resolution algorithm. when `--route` is absent on any `route.stone.*` command:

1. get current branch via `git rev-parse --abbrev-ref HEAD` (or use `input.branch` if provided)
2. flatten via `sanitizeBranchName()`
3. scan for `**/.route/.bind.<flattened>.flag` from cwd (repo root)
4. if exactly one match → derive route path from flag parent's parent
5. if zero matches → return null
6. if multiple matches → throw error with disambiguation guidance

### setRouteBind

```
input:  { route: string }
output: { route: string; flagPath: string }
```

1. validate route directory found
2. reject if on protected branch (main, master)
3. get current branch name
4. scan for any pre-bound flag files for this branch
5. if found and same route → idempotent return
6. if found and different route → error: "already bound to X. use route.bind --del first"
7. ensure `<route>/.route/` directory found
8. write flag file at `<route>/.route/.bind.<flattened>.flag`
9. return result

### getRouteBind

```
input:  {}
output: { route: string } | null
```

1. call `getRouteBindByBranch()`
2. return route path or null

### delRouteBind

```
input:  {}
output: { deleted: boolean }
```

1. get current branch, flatten
2. scan for `**/.route/.bind.<flattened>.flag`
3. if found → remove the flag file(s)
4. if not found → idempotent success (no error)

---

## codepath treestruct

### prodcode

```
src/
├── contract/
│   └── cli/
│       ├── index.ts
│       │   └── [~] cli                                    # add cli.route.bind entry
│       └── route.ts
│           ├── [+] routeBind()                            # cli entrypoint: dispatch --get / --del / --route
│           ├── [~] routeStoneGet()                        # add auto-resolve fallback when --route absent
│           ├── [~] routeStoneSet()                        # add auto-resolve fallback when --route absent
│           ├── [~] routeStoneDel()                        # add auto-resolve fallback when --route absent
│           ├── [~] routeStoneJudge()                      # add auto-resolve fallback when --route absent
│           ├── [○] parseArgs()                            # retain: shared arg parser
│           └── [○] isNodeEvalMode()                       # retain: node -e detection
├── domain.operations/
│   ├── review/
│   │   └── [←] sanitizeBranchName()                      # reuse: branch name flatten
│   └── route/
│       └── bind/
│           ├── getRouteBindByBranch.ts
│           │   └── [+] getRouteBindByBranch()             # scan for .bind.<branch>.flag, derive route
│           ├── setRouteBind.ts
│           │   └── [+] setRouteBind()                     # validate, reject protected, write flag file
│           ├── getRouteBind.ts
│           │   └── [+] getRouteBind()                     # thin wrapper: getRouteBindByBranch({ branch: null })
│           └── delRouteBind.ts
│               └── [+] delRouteBind()                     # scan for flags, remove if found, idempotent
├── domain.roles/
│   └── driver/
│       └── skills/
│           └── [+] route.bind.sh                          # shell wrapper → cli.route.bind()
├── utils/
│   └── [←] enumFilesFromGlob()                           # reuse: glob scan
└── index.ts
    └── [~] cli                                            # add cli.route.bind entry
```

### testcode

```
src/
└── domain.operations/
    └── route/
        └── bind/
            ├── [+] getRouteBindByBranch.test.ts           # zero/one/multiple flags, branch flatten
            ├── [+] setRouteBind.test.ts                   # create/idempotent/reject/protected branch
            └── [+] delRouteBind.test.ts                   # remove/idempotent

blackbox/
├── .test/
│   ├── invokeRouteSkill.ts
│   │   ├── [○] genTempDirForRhachet()                    # retain: temp dir with git + symlinks
│   │   └── [~] invokeRouteSkill()                        # extend skill union with 'route.bind'
│   └── assets/
│       └── [○] route-driver/                              # retain: 3-stone fixture
├── [+] driver.route.bind.acceptance.test.ts               # usecases 1-3: bind, get, del
└── [+] driver.route.bind.autoresolve.acceptance.test.ts   # usecases 4-8: auto-resolve, ambiguity, episode
```

---

## filediff treestruct

```
src/
├── contract/
│   └── cli/
│       ├── [~] index.ts
│       └── [~] route.ts
├── domain.operations/
│   └── route/
│       └── bind/
│           ├── [+] getRouteBindByBranch.ts
│           ├── [+] getRouteBindByBranch.test.ts
│           ├── [+] setRouteBind.ts
│           ├── [+] setRouteBind.test.ts
│           ├── [+] getRouteBind.ts
│           ├── [+] delRouteBind.ts
│           └── [+] delRouteBind.test.ts
├── domain.roles/
│   └── driver/
│       └── skills/
│           └── [+] route.bind.sh
└── [~] index.ts

blackbox/
├── .test/
│   └── [~] invokeRouteSkill.ts
├── [+] driver.route.bind.acceptance.test.ts
└── [+] driver.route.bind.autoresolve.acceptance.test.ts
```

---

## contracts

### shell entrypoint: `route.bind.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail
exec node -e "import('rhachet-roles-bhrain/cli').then(m => m.cli.route.bind())" -- "$@"
```

### cli entrypoint: `routeBind()`

```ts
export const routeBind = async (): Promise<void> => {
  const options = parseArgs(process.argv);

  // dispatch based on which flag is provided
  if (options.get === 'true')  → getRouteBind() → stdout
  if (options.del === 'true')  → delRouteBind() → stdout
  if (options.route)           → setRouteBind({ route }) → stdout
  else                         → error: usage help
};
```

### cli auto-resolve in `routeStoneGet/Set/Del/Judge`

```ts
// replace the current `--route` required check:
//   if (!options.route) { error; exit(1); }
//
// with:
//   if (!options.route) { options.route = await resolveRouteFromBind(); }
//   if (!options.route) { error: "no route bound. use --route or route.bind"; exit(1); }
```

the resolution is a fallback — explicit `--route` always wins.

### cli exports update

```ts
// src/contract/cli/index.ts
export const cli = {
  review,
  reflect,
  route: {
    bind: routeBind,         // [+] new
    stone: {
      get: routeStoneGet,
      set: routeStoneSet,
      del: routeStoneDel,
      judge: routeStoneJudge,
    },
  },
};
```

---

## operation details

### getRouteBindByBranch.ts

```ts
/**
 * .what = resolves the bound route for the current branch
 * .why = enables auto-resolve of --route from bind flag files
 */
export const getRouteBindByBranch = async (input: {
  branch: string | null;
}): Promise<{ route: string } | null> => {
  // get branch name (from input or git)
  const branch = input.branch ?? await getCurrentBranch();

  // flatten branch name for flag file lookup
  const branchFlat = sanitizeBranchName({ branch });

  // scan for bind flag files
  const flagGlob = `**/.route/.bind.${branchFlat}.flag`;
  const flagFiles = await enumFilesFromGlob({ glob: flagGlob, cwd: process.cwd() });

  // handle result count
  if (flagFiles.length === 0) return null;
  if (flagFiles.length > 1) throw new BadRequestError(
    'multiple routes bound to this branch. use --route to disambiguate',
    { branch, flagFiles },
  );

  // derive route path: flag is at <route>/.route/.bind.*.flag
  const flagPath = flagFiles[0]!;
  const routeDir = path.dirname(path.dirname(flagPath));
  return { route: routeDir };
};
```

### setRouteBind.ts

```ts
/**
 * .what = binds a route to the current branch via flag file
 * .why = enables subsequent route commands to auto-resolve --route
 */
export const setRouteBind = async (input: {
  route: string;
}): Promise<{ route: string; flagPath: string }> => {
  // validate route directory
  // reject protected branches (main, master)
  // get current branch, flatten
  // scan for pre-bound flags for this branch
  // if same route → idempotent return
  // if different route → error
  // ensure .route/ dir
  // write flag file
  // return { route, flagPath }
};
```

### delRouteBind.ts

```ts
/**
 * .what = removes the bind flag for the current branch
 * .why = enables clean unbind with idempotent semantics
 */
export const delRouteBind = async (): Promise<{ deleted: boolean }> => {
  // get current branch, flatten
  // scan for bind flags
  // if found → remove each flag file
  // if not found → return { deleted: false } (idempotent, no error)
};
```

### getRouteBind.ts

```ts
/**
 * .what = queries the bound route for the current branch
 * .why = enables visibility into current bind state
 */
export const getRouteBind = async (): Promise<{ route: string } | null> => {
  return getRouteBindByBranch({ branch: null });
};
```

---

## auto-resolve integration

the key change is in `src/contract/cli/route.ts`. each of the four cli entrypoints (`routeStoneGet`, `routeStoneSet`, `routeStoneDel`, `routeStoneJudge`) currently has:

```ts
if (!options.route) {
  console.error('error: --route is required');
  console.error('run with --help for usage');
  process.exit(1);
}
```

this block is replaced with:

```ts
if (!options.route) {
  const bind = await getRouteBindByBranch({ branch: null });
  if (bind) {
    options.route = bind.route;
  } else {
    console.error('error: no route bound to this branch. use --route or route.bind');
    process.exit(1);
  }
}
```

explicit `--route` still wins — the resolution only fires when `--route` is absent. the `getRouteBindByBranch` import is dynamic or lazy to preserve fast startup on the cli subpath.

---

## test coverage

### unit tests

**getRouteBindByBranch.test.ts**
- zero flag files → returns null
- one flag file → returns correct route path
- multiple flag files → throws disambiguation error
- branch name flattened correctly

**setRouteBind.test.ts**
- creates flag file with correct format and location
- idempotent on same route
- rejects different route when bound
- rejects protected branches (main, master)
- rejects absent route directory

**delRouteBind.test.ts**
- removes flag file when bound
- idempotent when not bound (no error)

### acceptance tests

**driver.route.bind.acceptance.test.ts** — covers usecases 1-3

```
given('[case1] route with stones'
  when('[t0] route.bind --route <path>'
    then('exit code is 0')
    then('stdout confirms bound route')
    then('flag file created in <path>/.route/')

  when('[t1] route.bind --route <path> (second time, same path)'
    then('idempotent — exit code 0, no error')

  when('[t2] route.bind --get'
    then('stdout shows bound route path')
    then('exit code is 0')

  when('[t3] route.bind --del'
    then('exit code is 0')
    then('stdout confirms unbind')
    then('flag file removed')

  when('[t4] route.bind --del (second time)'
    then('idempotent — exit code 0')

  when('[t5] route.bind --get (after del)'
    then('stdout shows "not bound"')

given('[case2] route path not found'
  when('[t0] route.bind --route <bad-path>'
    then('error mentions path')
    then('exit code is nonzero')

given('[case3] protected branch (main)'
  when('[t0] route.bind --route <path>'
    then('error: "cannot bind route on protected branch"')
    then('exit code is nonzero')

given('[case4] bind to different route when already bound'
  when('[t0] route.bind --route <path-A> (first bind)'
    then('exit code is 0')
  when('[t1] route.bind --route <path-B> (different route)'
    then('error: "already bound to <path-A>"')
    then('exit code is nonzero')
```

**driver.route.bind.autoresolve.acceptance.test.ts** — covers usecases 4-8

```
given('[case1] bound route with stones'
  when('[t0] route.bind --route <path>'
    then('bind succeeds')

  when('[t1] route.stone.get --stone @next-one (no --route)'
    then('auto-resolves from bind')
    then('returns first stone')
    then('exit code is 0')

  when('[t2] route.stone.set --stone <stone1> --as passed (no --route)'
    then('auto-resolves from bind')
    then('exit code is 0')

  when('[t3] route.stone.get --stone @next-one (no --route, after pass)'
    then('returns second stone (first already passed)')

  when('[t4] route.stone.get --stone @next-one --route <explicit> (explicit override)'
    then('explicit --route wins over bind')

  when('[t5] route.bind --del'
    then('unbind succeeds')

  when('[t6] route.stone.get --stone @next-one (no --route, after unbind)'
    then('error: "no route bound"')
    then('exit code is nonzero')

given('[case2] branch with no bind'
  when('[t0] route.stone.get --stone @next-one (no --route)'
    then('error: "no route bound to this branch. use --route or route.bind"')
    then('exit code is nonzero')

given('[case3] multiple routes bound to same branch (ambiguity)'
  when('[t0] manually create bind flags in two route directories'
  when('[t1] route.stone.get --stone @next-one (no --route)'
    then('error: "multiple routes bound"')
    then('exit code is nonzero')
```

---

## reuse map

| codepath | source | action |
|----------|--------|--------|
| `sanitizeBranchName()` | `src/domain.operations/review/sanitizeBranchName.ts` | [→] eject to shared location or [←] import from review |
| `enumFilesFromGlob()` | `src/utils/enumFilesFromGlob.ts` | [←] reuse |
| `parseArgs()` | `src/contract/cli/route.ts` | [←] reuse (already shared across cli commands) |
| `genTempDirForRhachet()` | `blackbox/.test/invokeRouteSkill.ts` | [←] reuse |
| `invokeRouteSkill()` | `blackbox/.test/invokeRouteSkill.ts` | [~] extend skill union with `'route.bind'` |
| `route-driver` fixture | `blackbox/.test/assets/route-driver/` | [←] reuse (3 stones, no guards) |
| `isNodeEvalMode()` | `src/contract/cli/route.ts` | [←] reuse |

### note on sanitizeBranchName location

`sanitizeBranchName` currently lives in `src/domain.operations/review/` which is a review-specific context. since bind will depend on it too, consider one of:

1. **import from review** — simplest, acceptable since it's a pure utility with no review-specific logic
2. **eject to `src/utils/`** — cleaner boundary, but adds a file move

recommend option 1 for now (import from review). if it becomes used in 3+ contexts, eject to `src/utils/` later.

---

## execution order

### phase 0: infrastructure

1. extend `invokeRouteSkill` skill union to include `'route.bind'`
2. create `route.bind.sh` shell entrypoint

### phase 1: domain operations (bind core)

3. create `getRouteBindByBranch.ts` + unit tests
4. create `setRouteBind.ts` + unit tests
5. create `getRouteBind.ts`
6. create `delRouteBind.ts` + unit tests

### phase 2: cli layer

7. add `routeBind()` cli entrypoint to `route.ts`
8. add `route.bind` to cli exports in `index.ts` and `src/index.ts`

### phase 3: auto-resolve integration

9. modify `routeStoneGet` to auto-resolve `--route` from bind
10. modify `routeStoneSet` to auto-resolve `--route` from bind
11. modify `routeStoneDel` to auto-resolve `--route` from bind
12. modify `routeStoneJudge` to auto-resolve `--route` from bind

### phase 4: acceptance tests

13. write `driver.route.bind.acceptance.test.ts` (usecases 1-3)
14. write `driver.route.bind.autoresolve.acceptance.test.ts` (usecases 4-8)

### phase 5: verify

15. build and run all tests (unit + acceptance)
16. verify no regressions on pre-bind tests (explicit `--route` still works)

---

## edge cases and pit of success

| edge case | behavior | guard |
|-----------|----------|-------|
| no bind and no `--route` | error with guidance: "use --route or route.bind" | clear next step |
| multiple binds for same branch | error: "use --route to disambiguate" | prevents silent wrong-route |
| explicit `--route` with active bind | explicit wins, bind ignored | power users retain control |
| protected branch (main, master) | error: "cannot bind route on protected branch" | prevents shared-branch pollution |
| same route bound twice | idempotent success | safe to retry |
| different route when bound | error: "already bound to X. use route.bind --del first" | prevents accidental overwrite |
| route directory absent | error: "route directory not found: X" | catches typos |
| flag file malformed | fail-fast on parse | no silent misbehavior |
