# roadmap: driver-route-stones v1

## overview

this roadmap breaks down the blueprint into phases with ordered dependencies, acceptance criteria, and verification steps.

**total phases**: 7
**dependency flow**: phase N depends on phase N-1 (linear)

---

## phase 1: test fixtures

**goal**: create test assets that all subsequent phases depend on

**read before**:
- `.behavior/v2026_02_01.driver-route-stones/3.3.blueprint.v1.i1.md` (test fixtures section)

### checklist

- [ ] create `src/domain.operations/route/.test/assets/` directory
- [ ] create `route.simple/` fixture
  - [ ] `1.vision.stone`
  - [ ] `2.criteria.stone`
  - [ ] `3.plan.stone`
- [ ] create `route.parallel/` fixture
  - [ ] `2.criteria.stone`
  - [ ] `3.1.research.domain.stone`
  - [ ] `3.1.research.template.stone`
  - [ ] `3.1.research.prior.stone`
  - [ ] `3.2.plan.stone`
- [ ] create `route.guarded/` fixture
  - [ ] `1.vision.stone`
  - [ ] `1.vision.guard` (approved? judge)
  - [ ] `5.implement.stone`
  - [ ] `5.implement.guard` (reviewed? + approved? judges)
- [ ] create `route.approved/` fixture
  - [ ] `1.vision.stone`
  - [ ] `1.vision.guard`
  - [ ] `1.vision.md` (artifact)
  - [ ] `.route/1.vision.approved` (approval marker)
- [ ] create `route.reviewed/` fixture
  - [ ] `.agent/rules/no-todos.md`
  - [ ] `1.implement.stone`
  - [ ] `1.implement.guard`
  - [ ] `src/clean.ts`
  - [ ] `src/dirty.ts`
- [ ] create `route.alternate/` fixture
  - [ ] `1.vision.src.stone`
  - [ ] `1.vision.src.guard`
  - [ ] `2.criteria.src`
  - [ ] `2.criteria.stone.guard`
  - [ ] `1.vision.md`

### acceptance criteria

```
given('test fixtures directory')
  when('fixtures are created')
    then('route.simple/ has 3 unguarded stones')
    then('route.parallel/ has stones with shared 3.1 prefix')
    then('route.guarded/ has stones with guard files')
    then('route.approved/ has pre-approved stone with .route/ marker')
    then('route.reviewed/ has rules and clean/dirty source files')
    then('route.alternate/ demonstrates .src.stone, .src, .src.guard, .stone.guard')
```

### verification

```sh
ls -la src/domain.operations/route/.test/assets/
ls -la src/domain.operations/route/.test/assets/route.simple/
ls -la src/domain.operations/route/.test/assets/route.parallel/
ls -la src/domain.operations/route/.test/assets/route.guarded/
ls -la src/domain.operations/route/.test/assets/route.approved/
ls -la src/domain.operations/route/.test/assets/route.reviewed/
ls -la src/domain.operations/route/.test/assets/route.alternate/
```

---

## phase 2: domain objects

**goal**: define all domain objects for the driver role

**depends on**: phase 1 (fixtures inform object shapes)

**read before**:
- `.behavior/v2026_02_01.driver-route-stones/3.2.distill.domain._.v1.i1.md`
- `.behavior/v2026_02_01.driver-route-stones/3.1.research.patterns._.code.prod.v1.i1.md`

### checklist

- [ ] create `src/domain.objects/Driver/` directory
- [ ] create `RouteStone.ts`
  - [ ] interface with name, path, guard
  - [ ] class extends DomainEntity
  - [ ] unique = ['path']
- [ ] create `RouteStoneDriveArtifacts.ts`
  - [ ] interface with stone ref, outputs[], passage
  - [ ] class extends DomainLiteral
- [ ] create `RouteStoneGuard.ts`
  - [ ] interface with path, artifacts[], reviews[], judges[]
  - [ ] class extends DomainLiteral
- [ ] create `RouteStoneGuardReviewArtifact.ts`
  - [ ] interface with stone ref, hash, iteration, index, path, blockers, nitpicks
  - [ ] class extends DomainEntity
  - [ ] primary = ['path'], unique = ['stone', 'hash', 'index']
- [ ] create `RouteStoneGuardJudgeArtifact.ts`
  - [ ] interface with stone ref, hash, iteration, index, path, passed, reason
  - [ ] class extends DomainEntity
  - [ ] primary = ['path'], unique = ['stone', 'hash', 'index']
- [ ] create `RouteStoneGuardApproveArtifact.ts`
  - [ ] interface with stone ref, path
  - [ ] class extends DomainEntity
  - [ ] primary = ['path'], unique = ['stone']
- [ ] create `index.ts` barrel export

### acceptance criteria

```
given('domain objects')
  when('RouteStone is instantiated')
    then('it has name, path, guard properties')
    then('unique key is path')
  when('RouteStoneGuard is instantiated')
    then('it has artifacts[], reviews[], judges[] arrays')
  when('RouteStoneDriveArtifacts is instantiated')
    then('it references stone by unique key')
    then('outputs is FilePath[]')
    then('passage is FilePath | null')
```

### verification

```sh
npm run build:compile
npm run test:types
```

---

## phase 3: leaf operations

**goal**: implement all leaf operations (pure functions and file operations)

**depends on**: phase 2 (domain objects)

**read before**:
- `.behavior/v2026_02_01.driver-route-stones/3.2.distill.domain._.v1.i1.md` (operations table)
- `.behavior/v2026_02_01.driver-route-stones/3.1.research.patterns._.code.test.v1.i1.md`

### checklist

#### core operations

- [ ] `computeStoneOrderPrefix.ts` + `.test.ts`
  - [ ] extract numeric prefix from stone name
  - [ ] "3.1.research.domain" â†’ "3.1"
- [ ] `getAllStones.ts` + `.test.ts`
  - [ ] glob for *.stone, *.src.stone, *.src
  - [ ] extract stone name (strip extension)
  - [ ] detect guard files (.guard, .src.guard, .stone.guard)
  - [ ] parse guards, return RouteStone[]
- [ ] `getAllStoneDriveArtifacts.ts` + `.test.ts`
  - [ ] for each stone: find outputs, check passage
  - [ ] return RouteStoneDriveArtifacts[]
- [ ] `getAllStoneArtifacts.ts` + `.test.ts`
  - [ ] glob for artifacts (guard.artifacts or default $name*.md)
  - [ ] return FilePath[]
- [ ] `computeNextStones.ts` + `.test.ts`
  - [ ] filter incomplete stones
  - [ ] @next-one: first incomplete
  - [ ] @next-all: all with same order prefix
- [ ] `setStonePassage.ts` + `.test.ts`
  - [ ] write .route/$stone.passed marker
- [ ] `delStone.ts` + `.test.ts`
  - [ ] remove stone file and guard file if present

#### guard operations (in guard/ subdirectory)

- [ ] `guard/parseStoneGuard.ts` + `.test.ts`
  - [ ] read yaml, validate schema
  - [ ] return RouteStoneGuard
- [ ] `guard/computeStoneReviewInputHash.ts` + `.test.ts`
  - [ ] enumerate artifacts, read content
  - [ ] compute sha256 hash
- [ ] `guard/getAllStoneGuardArtifactsByHash.ts` + `.test.ts`
  - [ ] glob for review/judge files by hash
  - [ ] parse and return grouped
- [ ] `guard/getOneStoneGuardApproval.ts` + `.test.ts`
  - [ ] check for .approved marker
  - [ ] return artifact or null
- [ ] `guard/setStoneGuardApproval.ts` + `.test.ts`
  - [ ] write .route/$stone.approved marker
- [ ] `guard/runStoneGuardReviews.ts` + `.integration.test.ts`
  - [ ] exec review shell commands
  - [ ] write output files
  - [ ] parse blockers/nitpicks
- [ ] `guard/runStoneGuardJudges.ts` + `.integration.test.ts`
  - [ ] exec judge shell commands
  - [ ] write output files
  - [ ] parse passed/reason

### acceptance criteria

```
given('route.simple fixture')
  when('getAllStones is called')
    then('returns 3 stones sorted alphanumerically')
    then('each stone has name without extension')
    then('each stone has guard = null')

given('route.parallel fixture')
  when('computeStoneOrderPrefix is called on 3.1.research.domain')
    then('returns "3.1"')
  when('computeNextStones is called with @next-all after 2.x complete')
    then('returns all 3.1.x stones')

given('route.guarded fixture')
  when('getAllStones is called')
    then('stones with .guard files have guard property populated')
    then('guard has artifacts, reviews, judges arrays')

given('route.alternate fixture')
  when('getAllStones is called')
    then('.src.stone, .src extensions are recognized')
    then('.src.guard, .stone.guard extensions are recognized')
    then('stone names strip all extension variants')
```

### verification

```sh
npm run test:unit -- computeStoneOrderPrefix
npm run test:unit -- getAllStones
npm run test:unit -- getAllStoneDriveArtifacts
npm run test:unit -- getAllStoneArtifacts
npm run test:unit -- computeNextStones
npm run test:unit -- parseStoneGuard
npm run test:unit -- computeStoneReviewInputHash
npm run test:unit -- getAllStoneGuardArtifactsByHash
npm run test:integration -- runStoneGuardReviews
npm run test:integration -- runStoneGuardJudges
```

---

## phase 4: step orchestrators

**goal**: implement high-level step operations that compose leaf operations

**depends on**: phase 3 (leaf operations)

**read before**:
- `.behavior/v2026_02_01.driver-route-stones/2.1.criteria.blackbox.md`
- `.behavior/v2026_02_01.driver-route-stones/3.3.blueprint.v1.i1.md` (step operations section)

### checklist

- [ ] `stepRouteStoneGet.ts` + `.test.ts` + `.integration.test.ts`
  - [ ] validate route found
  - [ ] getAllStones, getAllStoneDriveArtifacts
  - [ ] computeNextStones or filter by glob
  - [ ] if --say: read stone content, emit to stdout
  - [ ] if no stones: emit "all stones passed"
- [ ] `setStoneAsPassed.ts` + `.test.ts` + `.integration.test.ts`
  - [ ] getAllStones, find matched stone
  - [ ] getAllStoneArtifacts (BadRequestError if empty)
  - [ ] if no guard or guard without reviews/judges: auto-pass
  - [ ] if guard.reviews but no guard.judges: BadRequestError
  - [ ] compute hash, check for prior artifacts
  - [ ] run reviews/judges or reuse prior
  - [ ] if all pass: setStonePassage
- [ ] `setStoneAsApproved.ts` + `.test.ts`
  - [ ] getAllStones, find matched stone
  - [ ] setStoneGuardApproval
- [ ] `stepRouteStoneSet.ts` + `.test.ts` + `.integration.test.ts`
  - [ ] if as === 'approved': dispatch to setStoneAsApproved
  - [ ] if as === 'passed': dispatch to setStoneAsPassed
  - [ ] else: UnexpectedCodePathError
- [ ] `stepRouteStoneDel.ts` + `.test.ts` + `.integration.test.ts`
  - [ ] getAllStones, filter by glob
  - [ ] for each: check artifacts
  - [ ] if artifact found: skip
  - [ ] if no artifact: delStone
  - [ ] emit summary

### acceptance criteria

```
given('route.simple fixture')
  when('stepRouteStoneGet --stone @next-one')
    then('returns first stone (1.vision)')
  when('stepRouteStoneGet --stone @next-all')
    then('returns first stone (only one at prefix 1)')

given('route.parallel fixture with 2.criteria passed')
  when('stepRouteStoneGet --stone @next-all')
    then('returns all 3.1.x stones')

given('route.approved fixture')
  when('stepRouteStoneSet --stone 1.vision --as passed')
    then('judges run and find .approved marker')
    then('stone passes')

given('stone with artifact')
  when('stepRouteStoneDel is called')
    then('stone is skipped')
    then('notice is emitted')
```

### verification

```sh
npm run test:unit -- stepRouteStoneGet
npm run test:unit -- stepRouteStoneSet
npm run test:unit -- stepRouteStoneDel
npm run test:unit -- setStoneAsPassed
npm run test:unit -- setStoneAsApproved
npm run test:integration -- stepRouteStoneGet
npm run test:integration -- stepRouteStoneSet
npm run test:integration -- stepRouteStoneDel
npm run test:integration -- setStoneAsPassed
```

---

## phase 5: cli entrypoints

**goal**: implement cli wrappers for shell invocation

**depends on**: phase 4 (step orchestrators)

**read before**:
- `.behavior/v2026_02_01.driver-route-stones/3.1.research.patterns._.code.prod.v1.i1.md`
- `src/contract/cli/review.ts` for pattern

### checklist

- [ ] create `src/contract/cli/route.ts`
- [ ] implement `routeStoneGet()`
  - [ ] parseArgs: --stone, --route, --say
  - [ ] validate required args
  - [ ] invoke stepRouteStoneGet
  - [ ] format and print output
- [ ] implement `routeStoneSet()`
  - [ ] parseArgs: --stone, --route, --as
  - [ ] validate required args
  - [ ] invoke stepRouteStoneSet
  - [ ] format and print output
- [ ] implement `routeStoneDel()`
  - [ ] parseArgs: --stone, --route
  - [ ] validate required args
  - [ ] invoke stepRouteStoneDel
  - [ ] format and print output
- [ ] implement `routeStoneJudge()`
  - [ ] parseArgs: --mechanism, --stone, --route, --allow-blockers, --allow-nitpicks
  - [ ] if mechanism === 'approved?': check .approved marker
  - [ ] if mechanism === 'reviewed?': parse reviews, check thresholds
  - [ ] emit pass/fail with reason
- [ ] update `src/contract/cli/index.ts`
  - [ ] export cli.route.stone.get
  - [ ] export cli.route.stone.set
  - [ ] export cli.route.stone.del
  - [ ] export cli.route.stone.judge
- [ ] update `src/index.ts` if needed

### acceptance criteria

```
given('cli entrypoints')
  when('routeStoneGet is called with --help')
    then('prints usage information')
  when('routeStoneGet is called without --route')
    then('prints error: --route is required')
  when('routeStoneJudge --mechanism approved? finds .approved')
    then('emits pass')
  when('routeStoneJudge --mechanism reviewed? finds blockers > threshold')
    then('emits fail with reason')
```

### verification

```sh
npm run build
node -e "import('rhachet-roles-bhrain/cli').then(m => console.log(Object.keys(m.cli)))"
```

---

## phase 6: skill shells and role definition

**goal**: create shell skill wrappers and register driver role

**depends on**: phase 5 (cli entrypoints)

**read before**:
- `.behavior/v2026_02_01.driver-route-stones/3.3.blueprint.v1.i1.md` (role definition section)
- `src/domain.roles/reviewer/` for pattern

### checklist

- [ ] create `src/domain.roles/driver/` directory
- [ ] create `readme.md`
- [ ] create `briefs/` directory (empty for now)
- [ ] create `skills/` directory
- [ ] create `skills/route.stone.get.sh`
  - [ ] shebang, set -euo pipefail
  - [ ] exec node -e "import('rhachet-roles-bhrain/cli').then(m => m.cli.route.stone.get())"
- [ ] create `skills/route.stone.set.sh`
- [ ] create `skills/route.stone.del.sh`
- [ ] create `skills/route.stone.judge.sh`
- [ ] create `getDriverRole.ts`
  - [ ] ROLE_DRIVER with slug, name, purpose
  - [ ] skills: { dirs: [__dirname + '/skills'] }
  - [ ] briefs: { dirs: [__dirname + '/briefs'] }
- [ ] update `getRoleRegistry.ts`
  - [ ] import ROLE_DRIVER
  - [ ] add to registry

### acceptance criteria

```
given('driver role')
  when('getRoleRegistry is called')
    then('driver role is in registry')
    then('driver role has 4 skills')
  when('route.stone.get.sh is executed')
    then('invokes cli.route.stone.get()')
```

### verification

```sh
npm run build
ls -la dist/domain.roles/driver/skills/
cat dist/domain.roles/driver/skills/route.stone.get.sh
```

---

## phase 7: acceptance tests

**goal**: blackbox tests via skill invocation

**depends on**: phase 6 (role definition)

**read before**:
- `.behavior/v2026_02_01.driver-route-stones/2.1.criteria.blackbox.md`
- `.behavior/v2026_02_01.driver-route-stones/2.2.criteria.blackbox.matrix.md`
- `.behavior/v2026_02_01.driver-route-stones/3.1.research.patterns._.code.test.v1.i1.md`

### checklist

- [ ] create `blackbox/.test/invokeRouteSkill.ts` helper
- [ ] create `blackbox/driver.route.get.acceptance.test.ts`
  - [ ] test @next-one returns first incomplete
  - [ ] test @next-all returns parallel tier
  - [ ] test --say echoes content
  - [ ] test "all stones passed" when complete
  - [ ] test error on route not found
- [ ] create `blackbox/driver.route.set.acceptance.test.ts`
  - [ ] test --as passed with no guard
  - [ ] test --as passed with guard (approved?)
  - [ ] test --as passed with guard (reviewed?)
  - [ ] test --as approved creates marker
  - [ ] test artifact not found error
- [ ] create `blackbox/driver.route.del.acceptance.test.ts`
  - [ ] test delete stone without artifact
  - [ ] test skip stone with artifact
  - [ ] test glob matches multiple

### acceptance criteria

```
given('blackbox tests')
  when('all acceptance tests pass')
    then('feature is complete per criteria')
```

### verification

```sh
npm run test:acceptance:locally -- driver.route
```

---

## summary

| phase | name | depends on | verification |
|-------|------|------------|--------------|
| 1 | test fixtures | - | ls fixtures |
| 2 | domain objects | 1 | build + types |
| 3 | leaf operations | 2 | unit tests |
| 4 | step orchestrators | 3 | unit + integration tests |
| 5 | cli entrypoints | 4 | build + manual |
| 6 | skill shells + role | 5 | build + ls |
| 7 | acceptance tests | 6 | acceptance tests |

**done when**: `npm run test:acceptance:locally -- driver.route` passes
