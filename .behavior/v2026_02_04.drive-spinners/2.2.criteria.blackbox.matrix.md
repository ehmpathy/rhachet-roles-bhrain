# blackbox coverage matrix: drive-spinners

## matrix.1 = stdout guard tree (usecase.1)

dimensions:
- **guard type**: unguarded, artifacts-only, reviews+judges
- **passage result**: allowed, blocked
- **cache state**: all fresh, some cached, all cached

| ind: guard type | ind: passage | ind: cache state | dep: guard section | dep: review lines | dep: judge lines | dep: passage line |
|---|---|---|---|---|---|---|
| unguarded | allowed | n/a | omitted | omitted | omitted | `allowed (unguarded)` |
| artifacts-only | allowed | n/a | artifacts only | omitted | omitted | `allowed (artifacts only)` |
| reviews+judges | allowed | all fresh | full tree | `âœ“ finished {dur}s` + counts | `âœ“ finished {dur}s` + passed | `allowed` |
| reviews+judges | allowed | some cached | full tree | cached: `Â· cached`; fresh: `âœ“ finished {dur}s` + counts | cached: `Â· cached`; fresh: `âœ“ finished {dur}s` | `allowed` |
| reviews+judges | allowed | all cached | full tree | all `Â· cached` | all `Â· cached` | `allowed` |
| reviews+judges | blocked | all fresh | full tree | `âœ“ finished {dur}s` + counts | failed: `âœ— finished {dur}s` + reason | `blocked` + reason |
| reviews+judges | blocked | some cached | full tree | cached: `Â· cached`; fresh: `âœ“ finished {dur}s` + counts | cached: `Â· cached`; fresh: `âœ— finished {dur}s` + reason | `blocked` + reason |
| reviews+judges | blocked | all cached | full tree | all `Â· cached` | `âœ—` + reason (from cache) | `blocked` + reason |

### gap check

- âœ… all guard type Ã— passage Ã— cache combinations are covered
- note: `unguarded` and `artifacts-only` have no cache dimension (no reviews/judges to cache)
- note: `blocked` requires at least one failed judge; reviews always complete regardless of passage

---

## matrix.2 = review result lines (usecase.1 detail)

dimensions:
- **cache state**: fresh, cached
- **blockers**: 0, >0
- **nitpicks**: 0, >0

| ind: cache state | ind: blockers | ind: nitpicks | dep: status line | dep: blocker line | dep: nitpick line | dep: artifact path |
|---|---|---|---|---|---|---|
| fresh | 0 | 0 | `âœ“ finished {dur}s` | omitted | omitted | shown |
| fresh | >0 | 0 | `âœ“ finished {dur}s` | `{n} blockers ðŸ”´` | omitted | shown |
| fresh | 0 | >0 | `âœ“ finished {dur}s` | omitted | `{n} nitpicks ðŸŸ ` | shown |
| fresh | >0 | >0 | `âœ“ finished {dur}s` | `{n} blockers ðŸ”´` | `{n} nitpicks ðŸŸ ` | shown |
| cached | n/a | n/a | `Â· cached` | omitted | omitted | omitted |

### gap check

- âœ… all fresh blocker Ã— nitpick combinations covered
- âœ… cached collapses to single indicator (no counts surfaced from cache)

---

## matrix.3 = judge result lines (usecase.1 detail)

dimensions:
- **cache state**: fresh, cached
- **passed**: true, false

| ind: cache state | ind: passed | dep: status line | dep: reason line |
|---|---|---|---|
| fresh | true | `âœ“ finished {dur}s` | omitted |
| fresh | false | `âœ— finished {dur}s` | `reason: {text}` |
| cached | true | `Â· cached` | omitted |
| cached | false | `Â· cached` | omitted |

### gap check

- âœ… all cache Ã— passed combinations covered
- note: cached judges don't re-surface the reason (the human can check the artifact file if needed)

---

## matrix.4 = stderr live progress (usecase.2)

dimensions:
- **phase**: reviews, judges
- **item state**: queued, inflight, finished, cached

| ind: phase | ind: item state | dep: stderr display |
|---|---|---|
| reviews | queued | `Â· queued` |
| reviews | inflight | `inflight {elapsed}s â ¹` |
| reviews | finished | `âœ“ finished {dur}s` + counts |
| reviews | cached | `Â· cached` |
| judges | queued | `Â· queued` |
| judges | inflight | `inflight {elapsed}s â ¹` |
| judges | finished (passed) | `âœ“ finished {dur}s` |
| judges | finished (failed) | `âœ— finished {dur}s` |
| judges | cached | `Â· cached` |

### gap check

- âœ… all phase Ã— state combinations covered
- note: judges are always queued while reviews run (sequential phases)

---

## matrix.5 = artifact enumeration (usecase.3)

dimensions:
- **artifact count**: 1, >1

| ind: artifact count | dep: artifacts section |
|---|---|
| 1 | single artifact filename listed |
| >1 | each artifact filename listed as sub-branch |

### gap check

- âœ… both cases covered
- note: 0 artifacts is a BadRequestError before the guard tree is rendered (pre-condition, not a display concern)

---

## decomposition notes

all matrices stay at 2-3 independent dimensions â€” no decomposition needed. the behavioral boundaries are well-scoped:
- stdout final tree = what the human sees after execution
- stderr live tree = what the human sees while execution proceeds
- review/judge lines = atomic display contracts per result type
