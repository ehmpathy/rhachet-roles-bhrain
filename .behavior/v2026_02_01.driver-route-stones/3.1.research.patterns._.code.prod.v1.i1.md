# research: production code patterns v1

## overview

this research documents the production codepath patterns in `rhachet-roles-bhrain` that are relevant for implementation of `driver-route-stones`. each pattern is marked with:

- **[REUSE]** — adopt as-is
- **[EXTEND]** — build upon with additions
- **[REPLACE]** — supersede with new approach

---

## 1. cli patterns

**files**: `src/contract/cli/`

### structure

```typescript
// index.ts - fast export (avoids heavy imports)
export const cli = { review, reflect };

// review.ts / reflect.ts - operation entrypoints
export const review = async (): Promise<void> => {
  // 1. arg parse
  const options = parseArgs(process.argv);

  // 2. early exits
  if (hasHelpFlag(options)) return showHelp();

  // 3. validate
  if (!options.rules || !options.paths)
    throw new BadRequestError('--rules and --paths required');

  // 4. discover brain context
  const brain = await genContextBrain();

  // 5. invoke domain operation
  await stepReview({ refs: {...} }, { brain, log: console });
};
```

### key helpers

| helper | purpose |
|--------|---------|
| `parseArgs(argv)` | simple arg parser without heavy deps |
| `hasHelpFlag(opts)` | detect `--help` for early exit |
| `isNodeEvalMode()` | detect `node -e` vs normal invocation |
| `genContextBrain()` | lazy brain discovery from environment |

### relation to driver-route-stones

- need cli entrypoints for `route.stone.get`, `route.stone.set`, `route.stone.del`
- reuse arg parse, help flag, brain discovery patterns
- support `--stone`, `--route`, `--say`, `--as` flags

**recommendation**: **[REUSE]** — identical cli structure for route operations

---

## 2. role patterns

**files**: `src/domain.roles/*/get*Role.ts`, `src/domain.roles/getRoleRegistry.ts`

### structure

```typescript
export const ROLE_REVIEWER: Role = Role.build({
  slug: 'reviewer',
  name: 'Reviewer',
  purpose: 'code review via rules',
  readme: { uri: __dirname + '/readme.md' },
  traits: [],
  skills: {
    dirs: [],
    refs: [SKILL_REVIEW, SKILL_REFLECT],
  },
  briefs: {
    dirs: [{ uri: __dirname + '/briefs' }],
  },
});

// registry aggregates roles
export const getRoleRegistry = (): RoleRegistry =>
  new RoleRegistry({
    slug: 'bhrain',
    roles: [ROLE_THINKER, ROLE_REVIEWER, ROLE_BRAIN],
  });
```

### relation to driver-route-stones

- add `ROLE_DRIVER` with route-stone skills
- skills: `route.stone.get`, `route.stone.set`, `route.stone.del`, `route.stone.guard`, `route.stone.review`, `route.stone.judge`
- extend registry with driver role

**recommendation**: **[EXTEND]** — add driver role with same pattern

---

## 3. skill patterns

**files**: `src/domain.roles/*/skills/*/skill*.ts`

### genRoleSkill structure

```typescript
export const SKILL_NAME = genRoleSkill({
  slug: 'skill-name',
  route: stepSkillName,  // stitcher function
  threads: {
    lookup: {
      // cli args
      output: { source: 'process.argv', char: 'o', desc: 'output path', type: 'string' },
      mode: { source: 'process.argv', char: 'm', desc: 'mode', type: 'string' },
    },
    assess: (input): input is ValidInputType => !!input.output,
    instantiate: async (input) => ({
      caller: await enrollThread({ role: 'caller', stash: {...} }),
      worker: await enrollThread({ role: 'worker', stash: {...} }),
    }),
  },
  context: {
    lookup: {
      apiKey: { source: 'process.env', envar: 'API_KEY', type: 'string' },
    },
    assess: (input): input is ContextType => true,
    instantiate: (input) => ({ brain: input.brain }),
  },
  readme: '# skill\n\nusage: ...',
});
```

### relation to driver-route-stones

- each operation becomes a skill via genRoleSkill
- threads: `caller` (requester) → `driver` (executor)
- context: brain for review/judge operations, log for all

**recommendation**: **[REUSE]** — use genRoleSkill for all route.stone operations

---

## 4. stitcher patterns

**files**: `src/domain.roles/*/skills/*/step*.ts`

### type definition

```typescript
type StitcherReview = GStitcher<
  Threads<{
    caller: RoleContext<'caller', { art: { feedback: ArtifactGitFile } }>;
    reviewer: RoleContext<'reviewer', { art: { review: ArtifactGitFile } }>;
  }>,
  BrainContext & GStitcher['context'],
  { review: ReviewOutput }
>;
```

### step implementation

```typescript
export const stepReview = asStitcherFlat<StitcherReview>(
  genStitchRoute({
    slug: '@[reviewer]<review>',
    sequence: [
      // step 1: enumerate files
      new StitchStepCompute<StitcherReview>({
        form: 'COMPUTE',
        slug: '@[reviewer]<enumerate>',
        stitchee: 'reviewer',
        invoke: async ({ threads }, context) => {
          const files = await enumFilesFromGlob({ glob: input.paths });
          return { input: { paths: input.paths }, output: { files } };
        },
      }),
      // step 2: imagine review
      new StitchStepImagine<StitcherReview>({
        form: 'IMAGINE',
        slug: '@[reviewer]<review>',
        stitchee: 'reviewer',
        invoke: async ({ threads }, context) => {
          return context.brain.repl.imagine({...});
        },
      }),
    ],
  }),
);
```

### relation to driver-route-stones

- route operations use same stitcher architecture
- `route.stone.get` → StitchStepCompute (file enumeration, state check)
- `route.stone.set` → StitchStepCompute (validate artifact) + optional StitchStepImagine (review/judge)
- `route.stone.del` → StitchStepCompute (file removal)

**recommendation**: **[REUSE]** — use GStitcher, StitchStepCompute, genStitchRoute

---

## 5. file enumeration patterns

**files**: `src/domain.operations/review/enumFilesFromGlob.ts`, `enumFilesFromDiffs.ts`

### glob enumeration

```typescript
import fg from 'fast-glob';

export const enumFilesFromGlob = async (input: {
  glob: string | string[];
  cwd?: string;
}): Promise<string[]> => {
  const patterns = Array.isArray(input.glob) ? input.glob : [input.glob];
  const positivePatterns = patterns.filter((p) => !p.startsWith('!'));
  const negativePatterns = patterns.filter((p) => p.startsWith('!')).map((p) => p.slice(1));

  const files = await fg(positivePatterns, {
    cwd: input.cwd,
    ignore: negativePatterns,
    onlyFiles: true,
    dot: true,
  });

  return [...new Set(files)].sort();
};
```

### git diff enumeration

```typescript
export const enumFilesFromDiffs = async (input: {
  range: 'since-main' | 'since-commit' | 'since-staged';
  cwd?: string;
}): Promise<string[]> => {
  const gitCommand = {
    'since-main': 'git diff main --name-only',
    'since-commit': 'git diff HEAD --name-only',
    'since-staged': 'git diff --staged --name-only',
  }[input.range];

  const output = execSync(gitCommand, { cwd, encode: 'utf-8' });
  return output.split('\n').map(l => l.trim()).filter(Boolean).sort();
};
```

### relation to driver-route-stones

- route discovery: enumerate `.stone` files via glob
- artifact check: enumerate produced `.md` files
- guard file discovery: find `.stone.guard` files

**recommendation**: **[REUSE]** — use fast-glob, enumFilesFromGlob for stone discovery

---

## 6. artifact patterns

**files**: `src/domain.operations/artifact/`

### artifact generation

```typescript
export const genArtifactGitFile = (
  input: { uri: string },
  options?: { versions?: boolean }
): ArtifactGitFile => {
  // creates git-backed artifact with optional version support
};
```

### artifact set step

```typescript
export const genStepArtSet = ({ stitchee, artee, mode = 'upsert' }) =>
  new StitchStepCompute({
    slug: `[${stitchee}]<artifact:set>[${artee}]`,
    invoke: async ({ threads }) => {
      const artifact = threads[stitchee].context.stash.art[artee];
      const content = getStitch(...).output.content;
      await artifact.set({ content });
      return { input: { mode }, output: { content } };
    },
  });
```

### path helpers

```typescript
export const asDotRhachetDir = (from: string): string => {
  const baseDir = dirname(from);
  const baseKey = basename(from);
  return join(baseDir, '.rhachet', baseKey);
};
```

### relation to driver-route-stones

- stone state via git artifacts (versions: true)
- review/judge files via artifact set pattern
- metadata in `.rhachet/` or `.route/` directories

**recommendation**: **[REUSE]** — use genArtifactGitFile, genStepArtSet, path helpers

---

## 7. validation patterns

**files**: `src/domain.operations/reflect/step2/parseManifestOperations.ts`

### zod schema validation

```typescript
import { z } from 'zod';

const schemaOfReviewIssue = z.object({
  rule: z.string(),
  title: z.string(),
  description: z.string(),
  locations: z.array(z.string()),
});

const schemaOfReviewOutput = z.object({
  done: z.boolean(),
  blockers: z.array(schemaOfReviewIssue),
  nitpicks: z.array(schemaOfReviewIssue),
});
```

### discriminated union for operations

```typescript
const schemaManifestEntry = z.discriminatedUnion('operation', [
  z.object({ operation: z.literal('OMIT'), reason: z.string() }),
  z.object({ operation: z.literal('SET_CREATE'), syncPath: z.string() }),
  z.object({ operation: z.literal('SET_UPDATE'), syncPath: z.string() }),
]);
```

### relation to driver-route-stones

- guard file schema (artifacts, reviews, judges arrays)
- judge output schema (pass/fail, feedback)
- review output schema (blockers, nitpicks counts)

**recommendation**: **[REUSE]** — use zod for all schema validation

---

## 8. hash/version patterns

**observation**: no explicit content hash computation found in production code.

### current approach

- git artifact version support via `rhachet-artifact-git`
- diff detection via git commands
- metadata storage in `.rhachet/` directories

### relation to driver-route-stones

- artifact hash for guard idempotency can use git object hash
- or compute sha256 of artifact content
- iteration prefix (`i$iter`) for chronological order

**recommendation**: **[EXTEND]** — add content hash utility for guard idempotency

---

## 9. error patterns

**files**: throughout codebase

### helpful-errors usage

```typescript
import { BadRequestError, UnexpectedCodePathError } from 'helpful-errors';

// validation errors
if (!input.stone)
  throw new BadRequestError('--stone required');

// unexpected state
if (!artifactFound)
  throw new UnexpectedCodePathError('artifact should exist', { stone, artifact });
```

### relation to driver-route-stones

- BadRequestError for invalid inputs (bad route, bad stone)
- UnexpectedCodePathError for guard failures, parse errors

**recommendation**: **[REUSE]** — use helpful-errors for all error cases

---

## summary matrix

| pattern | source | relation | marker |
|---------|--------|----------|--------|
| cli arg parse | `contract/cli/*.ts` | route cli entrypoints | [REUSE] |
| role definition | `domain.roles/*/get*Role.ts` | driver role | [EXTEND] |
| skill definition | `domain.roles/*/skills/*/skill*.ts` | route.stone.* skills | [REUSE] |
| stitcher architecture | `domain.roles/*/skills/*/step*.ts` | operation stitchers | [REUSE] |
| file enumeration | `domain.operations/review/enumFiles*.ts` | stone discovery | [REUSE] |
| artifact operations | `domain.operations/artifact/*.ts` | state persistence | [REUSE] |
| validation schemas | `domain.operations/reflect/step2/*.ts` | guard/judge schemas | [REUSE] |
| path helpers | `domain.operations/artifact/asDotRhachetFile.ts` | metadata storage | [REUSE] |
| error helpers | throughout | error types | [REUSE] |
| content hash | (none found) | guard idempotency | [EXTEND] |

---

## implementation implications

### new files needed

```
src/
├── contract/
│   └── cli/
│       └── route.ts          # cli entrypoint for route operations
├── domain.roles/
│   └── driver/
│       ├── getDriverRole.ts  # role definition
│       ├── readme.md
│       ├── briefs/
│       └── skills/
│           ├── route.stone.get/
│           │   ├── skillRouteStoneGet.ts
│           │   └── stepRouteStoneGet.ts
│           ├── route.stone.set/
│           │   ├── skillRouteStoneSet.ts
│           │   └── stepRouteStoneSet.ts
│           └── route.stone.del/
│               ├── skillRouteStoneDel.ts
│               └── stepRouteStoneDel.ts
└── domain.operations/
    └── route/
        ├── enumStonesFromRoute.ts
        ├── computeArtifactHash.ts
        ├── parseGuardFile.ts
        └── computeStoneState.ts
```

### reuse chain

1. `enumFilesFromGlob` → enumerate `.stone` files in route
2. `genArtifactGitFile` → manage stone artifacts
3. `genStepArtSet` → persist review/judge output
4. `parseManifestOperations` pattern → parse guard yaml
5. `genRoleSkill` → wrap operations as skills
6. `asStitcherFlat` + `genStitchRoute` → compose operation steps

### extend items

1. content hash utility for artifact idempotency
2. driver role with route-specific briefs
3. guard schema types (artifacts, reviews, judges)

---

## citations

all patterns sourced from `rhachet-roles-bhrain` repository:
- `src/contract/cli/review.ts:1-89`
- `src/contract/cli/reflect.ts:1-67`
- `src/domain.roles/reviewer/getReviewerRole.ts:1-42`
- `src/domain.roles/brain/skills/act/skillAct.ts:1-156`
- `src/domain.operations/review/enumFilesFromGlob.ts:1-31`
- `src/domain.operations/review/enumFilesFromDiffs.ts:1-47`
- `src/domain.operations/artifact/genStepArtSet.ts:1-28`
- `src/domain.operations/reflect/step2/parseManifestOperations.ts:1-89`
