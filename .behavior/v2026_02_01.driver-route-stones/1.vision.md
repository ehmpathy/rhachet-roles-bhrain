# vision: driver-route-stones

## the outcome world

### before

a human sits in the navigator seat, manually orchestrates a robot brain through a thought route:

```
human: *reads 1.vision.src, copies content*
human: "ok mechanic, here's what you need to do next..."
mechanic: *produces 1.vision.md*
human: *eyeballs it* "looks good, move on"
human: *reads 2.criteria.src, copies content*
human: "ok now do this..."
mechanic: *produces 2.criteria.md*
... repeat for every stone ...
```

the human is the bottleneck. they do mechanical work — read files, copy-paste, decide "what's next", check "is this done". work that a robot could do if it knew the protocol.

### after

the robot navigates itself:

```
robot: rhx route.stone.get --stone @next-one --route .behavior/my-feature
       → echoes: "illustrate the vision implied in the wish..."

robot: *produces 1.vision.md*

robot: rhx route.stone.set --stone 1.vision --as passed --route .behavior/my-feature
       → guard checks: artifact exists? reviews passed? judge approved?
       → passed

robot: rhx route.stone.get --stone @next-one --route .behavior/my-feature
       → echoes: "define the blackbox criteria..."

... robot continues autonomously along the route ...
```

the human curates the route beforehand (delete what's not needed), then steps back. the robot does the mechanical navigation work.

### the "aha" moment

> "wait — the robot knows what milestone is next, knows whether it passed, and knows what feedback to address if it didn't. i just set the destination and it drives itself there."

it's like handing a self-drive car a destination vs reading turn-by-turn directions aloud the whole trip.

---

## user experience

### usecase 1: human-guided robot execution

**goal**: run a rigid skill (like `init.behavior`) without manual copy-paste orchestration

**timeline**:
1. human initiates behavior: `rhx init.behavior --wish "add dark mode"`
2. route is created with stones: `1.vision.src`, `2.criteria.src`, `3.plan.src`, etc
3. human deletes unnecessary stones: `route.stone.del --stone *.research.template* --route .behavior/...`
4. robot runs `route.stone.get --stone @next-one` → gets first stone instructions
5. robot produces artifact
6. robot runs `route.stone.set --stone 1.vision --as passed` → guard validates, passes or rejects
7. if rejected: robot addresses feedback, retries
8. if passed: robot runs `route.stone.get --stone @next-one` again
9. repeat until route complete

**contract**:
```sh
# get next stone(s)
route.stone.get --stone @next-one | @next-all | $glob --route $route [--say]

# mark stone as passed (triggers guard if present)
route.stone.set --stone $stone --as passed --route $route

# mark stone as approved (human-only via permission control)
route.stone.set --stone $stone --as approved --route $route

# cleanup unused stones
route.stone.del --stone $glob --route $route
```

### usecase 2: parallel stone execution

**goal**: execute independent stones concurrently to reduce walltime

**timeline**:
1. robot runs `route.stone.get --stone @next-all --route .behavior/...`
2. returns: `3.1.research.domain.src`, `3.1.research.template.src`, `3.1.research.prior.src`
3. robot (or orchestrator) spawns parallel execution for each
4. each completes and runs `route.stone.set --as passed`
5. once all 3.1.x stones pass, `route.stone.get --stone @next-one` returns `3.2.plan.src`

the full numeric prefix determines parallelism: `3.1.research.domain`, `3.1.research.template`, `3.1.research.prior` share prefix `3.1` → can run in parallel. `3.2.x` waits for all `3.1.x` to complete first.

### usecase 3: human-gated milestones

**goal**: require explicit human approval before pass of certain stones

**example**: vision stone — only the human knows if the vision matches their mental image

**guard file** (`1.vision.stone.guard`):
```yaml
artifacts:
  - 1.vision*.md   # supports versioned artifacts like 1.vision.v1.i1.md
judges:
  - rhx route.stone.judge --mechanism approved? --stone 1.vision --route $route
```

**timeline**:
1. robot produces `1.vision.md`
2. robot runs `route.stone.set --stone 1.vision --as passed`
3. guard runs judges: checks for `.approved` marker under `.route/`
4. if not approved: rejects with "wait for human approval"
5. human runs `route.stone.set --stone 1.vision --as approved`
6. robot retries `route.stone.set --as passed` → now passes

### usecase 4: review-gated milestones

**goal**: require code review before pass of implementation stones

**guard file** (`5.implement.stone.guard`):
```yaml
artifacts:
  - src/**/*.ts
reviews:
  - rhx review --rules .agent/**/rules/*.md --paths src/**/*.ts
judges:
  - rhx route.stone.judge --mechanism reviewed? --stone 5.implement --route $route --allow-blockers 0 --allow-nitpicks 2
  - rhx route.stone.judge --mechanism approved? --stone 5.implement --route $route
```

this example composes two judges: the code must pass review thresholds **and** receive human approval.

**timeline**:
1. robot implements feature in `src/`
2. robot runs `route.stone.set --stone 5.implement --as passed`
3. guard runs reviews → produces files under `$route/.route/`:
   - `5.implement.guard.review.i$iter.$hash.r1.md`
   - `5.implement.guard.review.i$iter.$hash.r2.md`, etc
4. guard runs judges → produces files under `$route/.route/`:
   - `5.implement.guard.judge.i$iter.$hash.j1.md`
   - `5.implement.guard.judge.i$iter.$hash.j2.md`, etc
5. if blockers found: rejects with feedback
6. robot addresses blockers, retries
7. guard re-runs review on new `$hash`, re-judges
8. passes when clean

**note**: review, judge, and approval files are stored under `.route/` since they're driver artifacts, not route artifacts. the `.stone`, `.guard`, and `.md` files remain at the route top level as route artifacts.

---

## mental model

### how users describe it

> "it's like checkpoints in a video game — you can't reach the boss until you've cleared each checkpoint. but the game (robot) knows how to play; you just set which checkpoints matter."

> "it's mapquest directions for robot brains — turn-by-turn instructions they can follow without a human that reads each step aloud."

> "it's a rubric with autograde — the route defines what's due, the guards define what pass looks like, the robot does the work and checks its own answers."

### analogies

| concept | analogy |
|---------|---------|
| route | a trail with marked waypoints |
| stone | a waypoint / milestone / checkpoint |
| guard | a gatekeeper at the checkpoint |
| review | an exam at the gate |
| judges | the graders who each decide pass/fail |
| `@next-one` | "what's my next turn?" |
| `@next-all` | "what can i do in parallel before converge?" |

### terminology

| user term | system term |
|-----------|-------------|
| "what's next?" | `route.stone.get --stone @next-one` |
| "am i done?" | `route.stone.set --as passed` |
| "skip this step" | `route.stone.del --stone $stone` |
| "checkpoint" | stone |
| "gate" | guard |

---

## evaluation

### how well does it solve the goals?

| goal | solved? |
|------|---------|
| easy "what's next?" assessment | yes — `route.stone.get --stone @next-one` |
| easy "can i pass?" assessment | yes — `route.stone.set --as passed` with guard feedback |
| route cleanup | yes — `route.stone.del --stone $glob` |
| parallel execution unlock | yes — `--stone @next-all` returns same-prefix stones |
| human approval gates | yes — `--mechanism approved?` judge |
| review-based gates | yes — `--mechanism reviewed?` judge with thresholds |
| reusable across routes | yes — generic skills, route-agnostic |

### pros

- **removes human from navigation loop** — robot drives itself
- **progressive disclosure** — drive prewritten routes with zero knowledge; add guards only when needed
- **composable guards** — mix deterministic (approved?) and probabilistic judges
- **idempotent** — guards check `$hash`, reuse prior reviews/judgments if artifact unchanged
- **parallel-friendly** — full numeric prefix convention enables safe concurrency
- **fail-fast** — del rejects if artifact exists (no history loss)
- **incremental** — each stone is atomic; progress is checkpointed

### cons

- **guard author effort** — good guards require thought to write (but guards are optional; users can drive prewritten routes or write guardless routes)
- **hash stability** — artifact hash must be deterministic (glob order, content normalization)

### edgecases and pit of success

| edgecase | pit of success |
|----------|----------------|
| del stone that has artifact | fail-fast: "cannot del; artifact exists" |
| set stone that has no artifact | fail-fast: "artifact not found" |
| guard with reviews but no judges | fail-fast: "guard specifies reviews but no judges" |
| judges run before all reviews | fail-fast: "reviews incomplete" |
| infinite retry loop | guard tracks attempt count; halt after threshold (e.g., 11) |
| parallel stones with deps | full numeric prefix convention; `3.1.a` and `3.1.b` are parallel, `3.2.x` waits for all `3.1.x` |
| hash changes mid-review | reviews and judges under `.route/` include iteration prefix (`.i$iter.$hash.r1`, `.i$iter.$hash.j1`) for chronological order; new hash = fresh run with incremented iteration |

---

## summary

the `driver` role with `route.stone.*` skills transforms thought routes from human-narrated journeys into self-navigate paths. robots know where they are, what's next, and whether they've arrived — frees humans to curate destinations rather than read directions.

> routes are the roads. stones are the waypoints. guards are the gates. robots drive themselves.

---

## appendix

### `rhx` alias

`rhx` is an alias for `npx rhachet run --skill`, already supported by rhachet.

```sh
# these are equivalent
rhx route.stone.get --stone @next-one --route .behavior/my-feature
npx rhachet run --skill route.stone.get --stone @next-one --route .behavior/my-feature
```
