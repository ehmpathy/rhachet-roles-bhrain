# blueprints comparison catalog

## .what

a systematic comparison of replic brain architectures across key dimensions: loop architecture, context management, tool interface, subagent patterns, git integration, and performance.

## .why

comparing architectures reveals the design tradeoffs in the replic brain space. understanding why different systems make different choices informs future architecture decisions and helps practitioners select the right tool for their needs.

---

## architectural comparison matrix

| dimension | claude code | codex |
|-----------|-------------|-------|
| **execution** | local/sdk | cloud sandbox |
| **loop type** | single-threaded, synchronous | async, background |
| **network** | controlled (permissions) | blocked by default |
| **parallelism** | subagents | multiple tasks |
| **context** | compaction | task-bounded |
| **model** | claude-sonnet/opus | gpt-5-codex |
| **interface** | cli, ide extensions | github, slack, api, ios |

---

## dimension analysis

### 1. loop architecture

#### claude code: single-threaded with subagent delegation
```
main loop ────────────────────────►
     │
     └──► subagent (isolated context)
              │
              └──► returns summary
```

- synchronous within session
- user interacts directly with main loop
- subagents for context isolation and parallel work

#### codex: async task-based with parallel execution
```
task queue ────────────────────────►
     │
     ├──► task 1 (container A) ──► PR
     │
     ├──► task 2 (container B) ──► PR
     │
     └──► task 3 (container C) ──► PR
```

- asynchronous, runs in background
- multiple tasks execute in parallel
- each task gets isolated container

#### tradeoff
| aspect | claude code | codex |
|--------|-------------|-------|
| interactivity | high (real-time) | low (async) |
| parallelism | via subagents | native multi-task |
| user feedback | immediate | at task completion |

---

### 2. context management

#### claude code: compaction via summarization
```
[context fills] ──► [summarize] ──► [continue]
```

- auto-summarization when approaching 200k limit
- enables unbounded session length
- trades verbatim history for longevity

#### codex: task-bounded full context
```
[task starts] ──► [full context] ──► [task ends]
```

- no explicit compaction needed
- tasks are bounded in scope
- fresh context per task

#### tradeoff
| aspect | claude code | codex |
|--------|-------------|-------|
| session length | unbounded | task-scoped |
| history loss | yes (via summarization) | no (per task) |
| complexity | higher (compaction logic) | lower |

---

### 3. tool interface

#### claude code: builtin + MCP extensibility
```
┌─────────────────────────────────────┐
│  [25+ builtin tools]               │
│  + [MCP servers for custom tools]  │
│  + [permission-based access]       │
└─────────────────────────────────────┘
```

#### codex: sandbox-restricted tools
```
┌─────────────────────────────────────┐
│  [file, shell, git tools]          │
│  [network blocked by default]      │
│  [test execution built-in]         │
└─────────────────────────────────────┘
```

#### tradeoff
| aspect | claude code | codex |
|--------|-------------|-------|
| extensibility | high (MCP) | limited |
| security | permission-based | sandbox isolation |
| web access | yes (controlled) | blocked (default) |

---

### 4. subagent patterns

#### claude code: typed subagents
```
Task(subagent_type="Explore", prompt="...")
Task(subagent_type="Plan", prompt="...")
Task(subagent_type="general-purpose", prompt="...")
```

- explicit types with different capabilities
- isolated context per subagent
- can use different/cheaper models

#### codex: parallel task containers
```
[Task A: Container 1] ──► PR #1
[Task B: Container 2] ──► PR #2
```

- each task is essentially a "subagent"
- full container isolation
- natural parallelism

#### tradeoff
| aspect | claude code | codex |
|--------|-------------|-------|
| granularity | fine (subagents within session) | coarse (separate tasks) |
| model flexibility | per-subagent | per-task |
| coordination | parent context | independent |

---

### 5. git integration

#### claude code: user-driven commits
```
[changes made]
     │
     └──► user: "commit this"
              │
              └──► git add + git commit
```

- only commits when explicitly asked
- guardrails against dangerous operations
- manual push

#### codex: auto-proposed PRs
```
[task completes]
     │
     └──► auto-generate PR proposal
              │
              └──► user reviews + merges
```

- automatic PR creation
- built-in github integration
- streamlined review workflow

#### tradeoff
| aspect | claude code | codex |
|--------|-------------|-------|
| automation | low (user-driven) | high (auto-PR) |
| control | high | lower |
| workflow fit | cli/local dev | github-centric |

---

### 6. performance dimensions

#### benchmark comparison

| benchmark | claude code | codex |
|-----------|-------------|-------|
| SWE-bench (verified) | ~49% | competitive |
| HumanEval | strong | strong |
| practical tasks | strong (interactive) | strong (batch) |

#### reasoning strategy effectiveness

| strategy | claude code | codex |
|----------|-------------|-------|
| react-style | implicit | implicit |
| extended thinking | yes (configurable) | via model |
| test-driven | user-initiated | automatic |

#### token efficiency

| aspect | claude code | codex |
|--------|-------------|-------|
| context usage | compacted | full per task |
| model calls | single-threaded | parallel |
| cost model | per-session | per-task |

---

## shared patterns

despite architectural differences, both systems share:

1. **agentic loop** — generate → tool → observe → repeat
2. **tool-based interaction** — structured tool calls, not free-form execution
3. **git awareness** — understand and manipulate repositories
4. **test integration** — verify changes via tests
5. **llm-driven reasoning** — model decides actions
6. **safety constraints** — guardrails on dangerous operations

---

## divergent approaches

| decision point | claude code choice | codex choice |
|----------------|-------------------|--------------|
| where to run | user's machine | openai's cloud |
| how to isolate | permissions + subagents | containers + network block |
| how to scale | session compaction | bounded tasks |
| how to integrate | cli + MCP | github + slack + api |
| when to commit | on user request | auto-propose PR |

---

## insights

### pattern: cloud vs local tradeoff
- **cloud** (codex): easier deployment, better isolation, async-first
- **local** (claude code): immediate feedback, user control, privacy

### pattern: compaction vs bounding
- **compaction**: enables unbounded sessions but loses detail
- **bounding**: preserves detail but scopes to single tasks

### pattern: permission vs sandbox
- **permission**: flexible but requires trust decisions
- **sandbox**: restrictive but eliminates classes of risk

### correlation: architecture → use case
| architecture | best for |
|--------------|----------|
| claude code | interactive development, exploration, refactoring |
| codex | batch tasks, CI integration, github workflows |

---

## sources

- [Building Effective Agents](https://www.anthropic.com/research/building-effective-agents)
- [Codex Cloud Architecture](https://developers.openai.com/codex/cloud/)
- [AI Coding Agents Benchmark](https://render.com/blog/ai-coding-agents-benchmark)
- [Claude Code vs Cursor Deep Comparison](https://www.qodo.ai/blog/claude-code-vs-cursor/)

---

## related briefs

- [arc201.blueprint.claude-code.[article].md](./arc201.blueprint.claude-code.[article].md)
- [arc202.blueprint.codex.[article].md](./arc202.blueprint.codex.[article].md)
- [arc109.concept.agentic-loop.[article].md](./arc109.concept.agentic-loop.[article].md)
- [arc117.concept.subagent.[article].md](./arc117.concept.subagent.[article].md)
