# research: test code patterns for route.drive

## pattern 1: BDD structure with given/when/then

**[REUSE]**

tests use `given`, `when`, `then` from `test-fns` for BDD-style structure with `[caseN]` and `[tN]` labels.

**citation 1** - `src/domain.operations/route/stepRouteStoneSet.integration.test.ts:1-13`
```ts
import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';
import { given, then, when } from 'test-fns';

import { stepRouteStoneSet } from './stepRouteStoneSet';

const ASSETS_DIR = path.join(__dirname, '.test/assets');

const noopContext = { cliEmit: { onGuardProgress: () => {} } };

describe('stepRouteStoneSet.integration', () => {
  given('[case1] set stone as passed with guard execution', () => {
```

**citation 2** - `src/domain.operations/route/stepRouteStoneSet.integration.test.ts:37-50`
```ts
    when('[t0] --as passed triggers guard', () => {
      then('executes reviews and judges', async () => {
        const result = await stepRouteStoneSet(
          {
            stone: '1.test',
            route: tempDir,
            as: 'passed',
          },
          noopContext,
        );
        expect(result.passed).toBe(true);
        expect(result.refs?.reviews.length).toBeGreaterThan(0);
        expect(result.refs?.judges.length).toBeGreaterThan(0);
      });
```

**relation to wish**: route.drive tests will follow this same BDD structure with `[caseN]` and `[tN]` labels for integration tests.

---

## pattern 2: useBeforeAll and useThen for shared state

**[REUSE]**

acceptance tests use `useBeforeAll` for setup and `useThen` to share expensive operation results across then blocks.

**citation 3** - `blackbox/driver.route.journey.acceptance.test.ts:3-4`
```ts
import { given, then, useBeforeAll, useThen, when } from 'test-fns';
```

**citation 4** - `blackbox/driver.route.journey.acceptance.test.ts:31-45`
```ts
  given('[journey] weather api route', () => {
    const scene = useBeforeAll(async () => {
      const tempDir = genTempDirForRhachet({
        slug: 'journey',
        clone: ASSETS_DIR,
      });

      // link the driver role
      await execAsync('npx rhachet roles link --role driver', { cwd: tempDir });

      // make mock-review.sh executable
      await execAsync('chmod +x .test/mock-review.sh', { cwd: tempDir });

      return { tempDir };
    });
```

**citation 5** - `blackbox/driver.route.journey.acceptance.test.ts:51-58`
```ts
    when('[t0] route is initialized', () => {
      const result = useThen('route.stone.get succeeds', async () =>
        invokeRouteSkill({
          skill: 'route.stone.get',
          args: { stone: '@next-one', route: '.' },
          cwd: scene.tempDir,
        }),
      );
```

**relation to wish**: route.drive acceptance tests will use `useBeforeAll` for fixture setup and `useThen` for skill invocation results.

---

## pattern 3: genTempDirForRhachet utility

**[EXTEND]**

acceptance tests use a specialized temp directory generator that sets up git repo and symlinks.

**citation 6** - `blackbox/.test/invokeRouteSkill.ts:9-34`
```ts
/**
 * .what = creates a temp directory ready for rhachet roles link
 * .why = enables acceptance tests with git repo and node_modules symlink
 */
export const genTempDirForRhachet = (input: {
  slug: string;
  clone: string;
}): string => {
  return genTempDir({
    slug: input.slug,
    clone: input.clone,
    git: true,
    symlink: [
      // symlink rhachet-roles-bhrain package for the driver role
      {
        at: 'node_modules/rhachet-roles-bhrain/package.json',
        to: 'package.json',
      },
      { at: 'node_modules/rhachet-roles-bhrain/dist', to: 'dist' },
      // symlink .bin for npx to find rhx/rhachet commands
      { at: 'node_modules/.bin', to: 'node_modules/.bin' },
      // symlink rhachet so rhx entrypoint can find ../rhachet/bin/rhx
      { at: 'node_modules/rhachet', to: 'node_modules/rhachet' },
    ],
  });
};
```

**relation to wish**: reuse for route.drive acceptance tests. may need extension if drive tests require additional symlinks.

---

## pattern 4: invokeRouteSkill utility

**[EXTEND]**

blackbox tests invoke skills via shell entrypoints with structured args.

**citation 7** - `blackbox/.test/invokeRouteSkill.ts:48-91`
```ts
export const invokeRouteSkill = async (input: {
  skill:
    | 'route.bind'
    | 'route.stone.get'
    | 'route.stone.set'
    | 'route.stone.del'
    | 'route.stone.judge';
  args: Record<string, string | boolean | undefined>;
  cwd: string;
}): Promise<{ stdout: string; stderr: string; code: number }> => {
  // map skill name to shell command filename
  const skillFile = `${input.skill}.sh`;
  const skillPath = path.join(
    input.cwd,
    '.agent/repo=bhrain/role=driver/skills',
    skillFile,
  );

  // build args string
  const argsStr = Object.entries(input.args)
    .filter(([_, v]) => v !== undefined)
    .map(([k, v]) => {
      if (v === true) return `--${k}`;
      return `--${k} "${v}"`;
    })
    .join(' ');

  const cmd = `bash "${skillPath}" ${argsStr}`;

  try {
    const result = await execAsync(cmd, {
      cwd: input.cwd,
      env: { ...process.env },
    });
    return { ...result, code: 0 };
  } catch (error) {
    const execError = error as { stdout?: string; stderr?: string; code?: number };
    return {
      stdout: execError.stdout ?? '',
      stderr: execError.stderr ?? '',
      code: execError.code ?? 1,
    };
  }
};
```

**relation to wish**: extend to add `'route.drive'` to the union type for route.drive acceptance tests.

---

## pattern 5: sanitizeTimeForSnapshot

**[REUSE]**

acceptance tests sanitize dynamic values for stable snapshots.

**citation 8** - `blackbox/.test/invokeRouteSkill.ts:44-46`
```ts
export const sanitizeTimeForSnapshot = (output: string): string => {
  return output.replace(/finished \d+\.\d+s/g, 'finished [TIME]');
};
```

**citation 9** - `blackbox/driver.route.journey.acceptance.test.ts:68-70`
```ts
      then('stdout has good vibes', () => {
        expect(sanitizeTimeForSnapshot(result.stdout)).toMatchSnapshot();
      });
```

**relation to wish**: reuse for route.drive output snapshots. format output contains stone names and commands that should be stable.

---

## pattern 6: fixture directory structure

**[REUSE]**

test fixtures are organized in `blackbox/.test/assets/` with route-specific directories.

**citation 10** - directory list
```
blackbox/.test/assets/
├── codebase-mechanic/
├── route-driver/
├── route-driver-guarded/
├── route-escape-hatch/
├── route-journey/
└── route-review-blocks/
```

**citation 11** - `blackbox/.test/assets/route-journey/` directory structure
```
blackbox/.test/assets/route-journey/
├── 0.wish.md
├── 1.vision.guard
├── 1.vision.stone
├── 2.research.stone
├── 3.blueprint.guard
├── 3.blueprint.stone
├── 5.execute.guard
├── 5.execute.stone
├── package.json
└── .test/
    └── mock-review.sh
```

**relation to wish**: create new fixture directory `route-drive/` or extend `route-journey/` with self-review guard configuration.

---

## pattern 7: mock review shell scripts

**[EXTEND]**

fixtures use shell scripts to mock review behavior with controllable pass/fail.

**citation 12** - `blackbox/.test/assets/route-journey/.test/mock-review.sh:1-35`
```sh
#!/usr/bin/env bash
######################################################################
# .what = mock review for journey acceptance test
# .why = enables controlled pass/fail behavior for test scenarios
#
# behavior:
#   - if .test/review-should-pass exists: emit 0 blockers, 0 nitpicks
#   - otherwise: emit 1 blocker
#
# usage:
#   bash $route/.test/mock-review.sh
######################################################################
set -euo pipefail

# get the route directory (parent of .test)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROUTE_DIR="$(dirname "$SCRIPT_DIR")"

# check if we should pass
if [[ -f "$ROUTE_DIR/.test/review-should-pass" ]]; then
  echo "---"
  echo "blockers: 0"
  echo "nitpicks: 0"
  echo "---"
  echo "review passed (mock)"
else
  echo "---"
  echo "blockers: 1"
  echo "nitpicks: 0"
  echo "---"
  echo "review failed (mock)"
  echo ""
  echo "## blockers"
  echo "- mock blocker: this is a test blocker that will be removed when .test/review-should-pass exists"
fi
```

**relation to wish**: no mock needed for self-review flow. self-reviews are promise-based (user runs command), not shell-executed. peer reviews can reuse mock pattern.

---

## pattern 8: guard file fixture format

**[EXTEND]**

test fixtures use guard files with flat reviews array (backwards compatible format).

**citation 13** - `blackbox/.test/assets/route-driver-guarded/1.test.guard:1-6`
```yaml
artifacts:
  - 1.test*.md
reviews:
  - echo "blockers: 0\nnitpicks: 1\ntest review content"
judges:
  - echo "passed: true\nreason: all checks passed"
```

**citation 14** - `blackbox/.test/assets/route-journey/3.blueprint.guard:1-9`
```yaml
artifacts:
  - 3.blueprint*.md

reviews:
  - bash $route/.test/mock-review.sh

judges:
  - npx rhx route.stone.judge --mechanism reviewed? --stone $stone --route $route --allow-blockers 0 --allow-nitpicks 2
  - npx rhx route.stone.judge --mechanism approved? --stone $stone --route $route
```

**relation to wish**: extend to create fixtures with structured reviews `{ self: [...], peer: [...] }` format for self-review tests.

---

## pattern 9: journey acceptance test structure

**[REUSE]**

journey tests execute sequential phases that accumulate state across steps.

**citation 15** - `blackbox/driver.route.journey.acceptance.test.ts:14-29`
```ts
/**
 * .what = full journey acceptance test for the driver role
 * .why = exercises complete user workflow through route navigation
 *
 * journey:
 *   0.wish.md (fixture)
 *   1.vision.stone (guarded by human approval)
 *   2.research.stone (no guard - auto-pass on artifact)
 *   3.blueprint.stone (guarded by reviews + human approval)
 *   5.execute.stone (guarded by reviews only)
 *
 * structure:
 *   - sequential when blocks for each user action
 *   - state accumulates in tempDir filesystem across the journey
 *   - runs with --runInBand to ensure sequential execution
 */
```

**citation 16** - `blackbox/driver.route.journey.acceptance.test.ts:47-49`
```ts
    // =========================================================================
    // PHASE 1: vision stone with human approval gate
    // =========================================================================
```

**relation to wish**: route.drive journey tests should follow same phase structure for self-review flow:
- PHASE 1: clone runs `--as passed`, blocked by self-review
- PHASE 2: clone runs `--as promised --that $slug` for each review.self
- PHASE 3: all promised, peer reviews execute
- PHASE 4: guards pass, stone marked as passed

---

## pattern 10: temp directory with beforeEach/afterEach

**[REUSE]**

integration tests use beforeEach/afterEach for temp directory setup and cleanup.

**citation 17** - `src/domain.operations/route/stepRouteStoneSet.integration.test.ts:14-35`
```ts
  given('[case1] set stone as passed with guard execution', () => {
    const tempDir = path.join(os.tmpdir(), `test-step-set-guard-${Date.now()}`);

    beforeEach(async () => {
      await fs.mkdir(tempDir, { recursive: true });
      await fs.writeFile(path.join(tempDir, '1.test.stone'), '# Test');
      await fs.writeFile(
        path.join(tempDir, '1.test.guard'),
        [
          'artifacts:',
          '  - 1.test*.md',
          'reviews:',
          '  - echo "blockers: 0\\nnitpicks: 0"',
          'judges:',
          '  - echo "passed: true\\nreason: clean"',
        ].join('\n'),
      );
      await fs.writeFile(path.join(tempDir, '1.test.md'), '# Artifact');
    });

    afterEach(async () => {
      await fs.rm(tempDir, { recursive: true, force: true });
    });
```

**relation to wish**: reuse pattern for stepRouteDrive and setStoneAsPromised integration tests.

---

## pattern 11: fs.cp for fixture clone

**[REUSE]**

tests use `fs.cp` to clone fixture directories to temp locations.

**citation 18** - `src/domain.operations/route/stepRouteStoneSet.integration.test.ts:77-79`
```ts
    beforeEach(async () => {
      await fs.cp(path.join(ASSETS_DIR, 'route.guarded'), tempDir, {
        recursive: true,
      });
```

**relation to wish**: reuse for clone of route fixtures with self-review guard configs.

---

## pattern 12: noop context for unit-style integration tests

**[REUSE]**

tests provide minimal context objects for domain operation tests.

**citation 19** - `src/domain.operations/route/stepRouteStoneSet.integration.test.ts:10`
```ts
const noopContext = { cliEmit: { onGuardProgress: () => {} } };
```

**relation to wish**: reuse pattern for stepRouteDrive tests. may need to extend context with additional callbacks if drive emits progress.

---

## summary

| pattern | disposition | reason |
|---------|-------------|--------|
| given/when/then BDD | [REUSE] | standard test structure |
| useBeforeAll/useThen | [REUSE] | shared setup and results |
| genTempDirForRhachet | [EXTEND] | may need additional symlinks |
| invokeRouteSkill | [EXTEND] | add `'route.drive'` skill |
| sanitizeTimeForSnapshot | [REUSE] | stable snapshots |
| fixture directory structure | [REUSE] | organized assets |
| mock review scripts | [EXTEND] | peer review mock |
| guard file fixtures | [EXTEND] | add structured reviews format |
| journey test structure | [REUSE] | phase-based test |
| beforeEach/afterEach temp dirs | [REUSE] | integration test isolation |
| fs.cp fixture clone | [REUSE] | temp environment setup |
| noop context | [REUSE] | minimal context injection |

---

## new test components needed

1. **route-drive fixture directory** - `blackbox/.test/assets/route-drive/` with:
   - stones that have `reviews.self` configured
   - stones with flat reviews array (backwards compat)
   - stones with no guard (auto-pass)

2. **structured guard fixture** - guard file with `reviews: { self: [...], peer: [...] }`

3. **promise artifact fixture** - pre-created promise files in `.route/` for hash validation tests

4. **invokeRouteSkill extension** - add `'route.drive'` to skill union type

5. **stepRouteDrive.integration.test.ts** - integration tests for drive output

6. **setStoneAsPromised.integration.test.ts** - integration tests for promise record

7. **getStonePromises.test.ts** - unit tests for promise enumeration and validation

8. **formatCheckYoself.test.ts** - unit tests for check yo'self output format

9. **driver.route.drive.acceptance.test.ts** - blackbox tests for route.drive skill

10. **driver.route.self-review.acceptance.test.ts** - journey test for full self-review flow

---

## test scenarios from criteria

based on blackbox criteria, tests should cover:

### episode.1 scenarios
- route bound → route.drive shows stone content and command
- clone runs `--as passed` with reviews.self → blocked, shows check yo'self
- clone runs `--as promised --that $slug` → promise recorded
- more unpromised → shows next review.self
- all promised → proceeds to peer reviews

### episode.2 scenarios
- promise extant for hash A → valid
- artifact edited (hash B) → promise invalidated
- `--as passed` after edit → check yo'self for invalidated review

### episode.3 scenarios
- guard with flat reviews array → no self-review flow, peer reviews execute directly

### episode.4 scenarios
- all stones passed → route.drive shows "route complete"

### episode.5 scenarios
- no route bound → route.drive is silent no-op
