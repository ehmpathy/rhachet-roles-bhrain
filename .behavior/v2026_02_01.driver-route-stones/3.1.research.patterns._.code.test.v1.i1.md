# research: test code patterns v1

## overview

this research documents the test codepath patterns in `rhachet-roles-bhrain` that are relevant for implementation of `driver-route-stones` tests. each pattern is marked with:

- **[REUSE]** â€” adopt as-is
- **[EXTEND]** â€” build upon with additions
- **[REPLACE]** â€” supersede with new approach

---

## 1. test file structure

**pattern**: three-tier test architecture

| tier | extension | config | timeout | purpose |
|------|-----------|--------|---------|---------|
| unit | `.test.ts` | `jest.unit.config.ts` | default | fast, isolated, no external deps |
| integration | `.integration.test.ts` | `jest.integration.config.ts` | 90s | external deps (apis, filesystems) |
| acceptance | `.acceptance.test.ts` | `jest.acceptance.config.ts` | 90s | end-to-end blackbox via shell |

**example locations**:
- unit: `src/domain.operations/reflect/createDraftDirectory.test.ts`
- integration: `src/domain.operations/reflect/stepReflect.integration.test.ts`
- acceptance: `blackbox/review.representative-clean.acceptance.test.ts`

**run commands**:
```sh
npm run test:unit
npm run test:integration
npm run test:acceptance
```

**recommendation**: **[REUSE]** â€” follow this exact three-tier structure

---

## 2. bdd patterns (given/when/then)

**source**: `test-fns` library

### import

```typescript
import { given, when, then, useBeforeAll, useBeforeEach, useThen } from 'test-fns';
```

### structure

```typescript
describe('featureName', () => {
  given('[case1] scenario description', () => {
    when('[t0] action or event', () => {
      then('expected outcome', async () => {
        // assertions
      });
    });
  });
});
```

### label conventions

- `[caseN]` â€” unique case label per `given` block
- `[tN]` â€” time index label per `when` block (resets per `given`)

### unit test example

```typescript
describe('reflect', () => {
  given('[case1] typescript-quality example repo', () => {
    const sourceDir = path.join(ASSETS_DIR, 'typescript-quality');

    when('[t0] before any changes', () => {
      then('enumFeedbackFiles finds 3 feedback files', async () => {
        const files = await enumFeedbackFiles({ directory: sourceDir });
        expect(files).toHaveLength(3);
      });
    });
  });
});
```

### integration test example

```typescript
describe('stepReflect', () => {
  const brainScene = useBeforeAll(async () => ({
    brain: genTestBrainContext({ brain: DEFAULT_TEST_BRAIN }),
  }));

  given('[case1] source directory does not exist', () => {
    when('[t0] stepReflect is called', () => {
      then('throws BadRequestError about source absent', async () => {
        const error = await getError(
          stepReflect({ source: '/nonexistent' }, { brain: brainScene.brain }),
        );
        expect(error).toBeInstanceOf(BadRequestError);
      });
    });
  });
});
```

### acceptance test example with useThen

```typescript
describe('review.acceptance', () => {
  given('[case1] mechanic codebase with clean code', () => {
    when('[t0] review skill on clean.ts', () => {
      // useThen for expensive operation shared across then blocks
      const res = useThen('invoke review skill on clean code', async () => {
        const cli = await invokeReviewSkill({ ... });
        const review = await fs.readFile(outputPath, 'utf-8');
        return { cli, review };
      });

      then('cli completes successfully', async () => {
        expect(res.cli.stderr).not.toContain('Error');
      });

      then('review contains no blockers', async () => {
        expect(res.review).not.toContain('blocker');
      });
    });
  });
});
```

**recommendation**: **[REUSE]** â€” apply this exact bdd pattern with test-fns

---

## 3. test fixtures & assets

**pattern**: static asset directories under `.test/assets/`

### directory structure

```
src/domain.operations/reflect/
â”œâ”€â”€ .test/
â”‚   â”œâ”€â”€ assets/
â”‚   â”‚   â”œâ”€â”€ example.repo/
â”‚   â”‚   â”‚   â”œâ”€â”€ typescript-quality/
â”‚   â”‚   â”‚   â””â”€â”€ prose-author/
â”‚   â”‚   â””â”€â”€ example.target/
â”‚   â””â”€â”€ setup.ts
â”œâ”€â”€ stepReflect.ts
â”œâ”€â”€ stepReflect.test.ts
â””â”€â”€ stepReflect.integration.test.ts
```

### setup helper pattern

```typescript
// .test/setup.ts
export const GIT_ENV = {
  ...process.env,
  GIT_AUTHOR_NAME: 'Test User',
  GIT_AUTHOR_EMAIL: 'test@test.com',
  GIT_COMMITTER_NAME: 'Test User',
  GIT_COMMITTER_EMAIL: 'test@test.com',
};

export const setupSourceRepo = async (
  repoType: 'typescript-quality' | 'prose-author',
): Promise<{ repoDir: string }> => {
  const repoDir = path.join(
    os.tmpdir(),
    `bhrain-reflect-source-${Date.now()}-${Math.random().toString(36).slice(2)}`,
  );

  await fs.cp(path.join(ASSETS_REPO, repoType), repoDir, { recursive: true });
  execSync('git init', { cwd: repoDir, stdio: 'pipe' });
  execSync('git remote add origin https://github.com/test/repo.git', {
    cwd: repoDir,
    stdio: 'pipe',
  });

  return { repoDir };
};
```

**key conventions**:
1. static assets stored in repo under `.test/assets/`
2. setup functions copy assets to temp directories
3. git config via environment variables (avoids global git config requirement)

**recommendation**: **[REUSE]** â€” follow this fixture pattern

---

## 4. setup patterns (useBeforeAll/useBeforeEach)

### useBeforeAll â€” one-time expensive setup

```typescript
const brainScene = useBeforeAll(async () => ({
  brain: genTestBrainContext({ brain: DEFAULT_TEST_BRAIN }),
}));

// access in then() blocks via: brainScene.brain
```

### useBeforeEach â€” per-test fresh state

```typescript
const scene = useBeforeEach(async () => {
  const repoDir = path.join(os.tmpdir(), `test-${Date.now()}`);
  await fs.mkdir(repoDir, { recursive: true });
  return { repoDir };
});
```

### afterEach/afterAll â€” cleanup

```typescript
afterEach(async () => {
  await fs.rm(testDir, { recursive: true, force: true });
});

afterAll(async () => {
  await fs.rm(scene.sourceDir, { recursive: true, force: true });
});
```

**recommendation**: **[REUSE]** â€” use useBeforeAll for context, afterEach for cleanup

---

## 5. temp directory patterns

### basic pattern

```typescript
const testDir = path.join(os.tmpdir(), `reflect-test-draft-${Date.now()}`);

afterEach(async () => {
  await fs.rm(testDir, { recursive: true, force: true });
});
```

### advanced pattern with entropy

```typescript
const sourceDir = path.join(
  os.tmpdir(),
  `bhrain-reflect-source-${Date.now()}-${Math.random().toString(36).slice(2)}`,
);
```

### test-fns helper

```typescript
import { genTempDir } from 'test-fns';

const tempDir = genTempDir({
  slug: 'review-test',
  clone: ASSETS_DIR,
  git: true,
  symlink: [
    { at: 'node_modules/rhachet-roles-bhrain/package.json', to: 'package.json' },
    { at: 'node_modules/rhachet-roles-bhrain/dist', to: 'dist' },
  ],
});
```

**key conventions**:
1. use `os.tmpdir()` for isolation
2. include `Date.now()` for uniqueness
3. add random string for additional entropy
4. use `fs.rm(dir, { recursive: true, force: true })` in cleanup

**recommendation**: **[REUSE]** â€” follow this exact temp directory pattern

---

## 6. shell skill invocation

**file**: `blackbox/.test/invokeReviewSkill.ts`

### pattern

```typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export const invokeReviewSkill = async (input: {
  rules: string;
  paths: string;
  output: string;
  mode: 'push' | 'pull';
  cwd: string;
}): Promise<{ stdout: string; stderr: string; code: number }> => {
  const skillPath = path.join(
    input.cwd,
    '.agent/repo=bhrain/role=reviewer/skills/review.sh',
  );

  const cmd = [
    `bash "${skillPath}"`,
    `--rules "${input.rules}"`,
    `--paths "${input.paths}"`,
    `--output "${input.output}"`,
    `--mode ${input.mode}`,
  ]
    .filter(Boolean)
    .join(' ');

  try {
    const result = await execAsync(cmd, {
      cwd: input.cwd,
      env: { ...process.env },
    });
    return { ...result, code: 0 };
  } catch (error) {
    const execError = error as { stdout?: string; stderr?: string; code?: number };
    return {
      stdout: execError.stdout ?? '',
      stderr: execError.stderr ?? '',
      code: execError.code ?? 1,
    };
  }
};
```

### usage in acceptance test

```typescript
const cli = await invokeReviewSkill({
  rules: 'rules/*.md',
  paths: 'src/clean.ts',
  output: outputPath,
  mode: 'push',
  cwd: tempDir,
});

console.log('\n--- cli.stdout ---');
console.log(cli.stdout);
console.log('\n--- cli.stderr ---');
console.log(cli.stderr);
```

**key conventions**:
1. use `promisify(exec)` for promise-based execution
2. catch non-zero exits by error handler
3. inherit process.env for api keys
4. log stdout/stderr for debug
5. return normalized `{ stdout, stderr, code }` object

**recommendation**: **[REUSE]** â€” create `invokeRouteSkill.ts` with same pattern

---

## 7. snapshot patterns

**location**: `__snapshots__/*.snap`

### test code

```typescript
then('matches snapshot', () => {
  const result = compileReviewPrompt({ /* ... */ });
  expect(result.prompt).toMatchSnapshot();
});
```

### snapshot file content

```typescript
exports[`genReviewInputStdout given: [case1] no refs when: [t0] generated then: matches snapshot 1`] = `
"ðŸ”­ metrics.expected
   â”œâ”€ files
   â”‚  â”œâ”€ rules: 3
   â”‚  â””â”€ targets: 12
   â””â”€ cost
      â””â”€ estimate: $0.0125"
`;
```

### update command

```sh
RESNAP=true npm run test:unit
```

**key conventions**:
1. snapshots stored in `__snapshots__/` subdirectory
2. test name (with given/when/then) becomes snapshot identifier
3. used for formatted text output verification
4. update via `RESNAP=true` environment variable

**recommendation**: **[REUSE]** â€” use snapshots for route output and error messages

---

## 8. mock & fake patterns

### mock context helper

```typescript
// src/.test/genMockBrainArch1Context.ts
export const genMockBrainArch1Context = (): BrainArch1Context => ({
  creds: {
    anthropic: { apiKey: 'test', url: null },
    openai: { apiKey: 'test', url: null },
  },
  ...genContextLogTrail(),
});
```

### jest mock pattern

```typescript
jest.mock('@src/access/sdks/anthropic/sdkAnthropic', () => ({
  sdkAnthropic: {
    generate: jest.fn(),
  },
}));

import { sdkAnthropic } from '@src/access/sdks/anthropic/sdkAnthropic';

// in test:
(sdkAnthropic.generate as jest.Mock).mockResolvedValue({
  message: new BrainArch1SessionMessage({ ... }),
});
```

### inline factory pattern

```typescript
const createMockToolbox = (
  name: string,
  toolNames: string[],
  executeResult: BrainArch1ToolResult,
): BrainArch1Toolbox => ({
  name,
  definitions: toolNames.map((tn) => ({
    name: tn,
    description: `${tn} description`,
    schema: { input: { type: 'object', properties: {}, required: [] } },
    strict: false,
  })),
  execute: jest.fn().mockResolvedValue(executeResult),
});
```

### real brain context helper

```typescript
// src/.test/genTestBrainContext.ts
export const DEFAULT_TEST_BRAIN = 'xai/grok/code-fast-1';

export const genTestBrainContext = (input: {
  brain: string;
}): ContextBrain<BrainChoice> => {
  const atoms = loadAllAtoms();
  const repls = loadAllRepls();
  return genContextBrain({ brains: { atoms, repls }, choice: input.brain });
};
```

**key conventions**:
1. mock contexts: centralized mock object generators
2. jest mocks: `jest.mock()` + `as jest.Mock` for type safety
3. inline factories: small, composable test double creators
4. real helpers: when actual deps needed (brain contexts)

**recommendation**: **[REUSE]** â€” create genMockRouteContext, genMockRouteStone helpers

---

## 9. environment & timeout patterns

### environment setup

```typescript
// jest.integration.env.ts
jest.setTimeout(90000);

if (!process.env.OPENAI_API_KEY) throw new Error('OPENAI_API_KEY not set');
if (!process.env.ANTHROPIC_API_KEY) throw new Error('ANTHROPIC_API_KEY not set');
```

### repeatably pattern (for flaky llm tests)

```typescript
// src/.test/infra/repeatably.ts
export const REPEATABLY_CONFIG = {
  attempts: 3,
  criteria: process.env.CI ? 'SOME' : 'EVERY',
} as const;
```

### error test utility

```typescript
import { getError } from 'test-fns';

const error = await getError(
  validateSourceDirectory({ source: '/nonexistent/directory' }),
);
expect(error).toBeDefined();
expect(error.message).toContain('does not exist');
```

**recommendation**: **[REUSE]** â€” follow these environment and error patterns

---

## summary matrix

| pattern | source | relation | marker |
|---------|--------|----------|--------|
| three-tier structure | `jest.*.config.ts` | test organization | [REUSE] |
| bdd given/when/then | `test-fns` | test readability | [REUSE] |
| test fixtures | `.test/assets/` | route examples | [REUSE] |
| setup hooks | `useBeforeAll`, `afterEach` | context & cleanup | [REUSE] |
| temp directories | `os.tmpdir()` + entropy | isolation | [REUSE] |
| shell invocation | `invokeReviewSkill.ts` | acceptance tests | [REUSE] |
| snapshots | `__snapshots__/` | output verification | [REUSE] |
| mocks/fakes | `genMock*.ts` + factories | dependency isolation | [REUSE] |
| env/timeout | `jest.*.env.ts` | ci configuration | [REUSE] |

---

## implementation implications for driver-route-stones

### test file structure

```
src/domain.roles/driver/
â”œâ”€â”€ skills/
â”‚   â”œâ”€â”€ route.stone.get/
â”‚   â”‚   â”œâ”€â”€ stepRouteStoneGet.ts
â”‚   â”‚   â”œâ”€â”€ stepRouteStoneGet.test.ts
â”‚   â”‚   â””â”€â”€ stepRouteStoneGet.integration.test.ts
â”‚   â”œâ”€â”€ route.stone.set/
â”‚   â”‚   â”œâ”€â”€ stepRouteStoneSet.ts
â”‚   â”‚   â”œâ”€â”€ stepRouteStoneSet.test.ts
â”‚   â”‚   â””â”€â”€ stepRouteStoneSet.integration.test.ts
â”‚   â””â”€â”€ route.stone.del/
â”‚       â””â”€â”€ ...
â””â”€â”€ .test/
    â”œâ”€â”€ assets/
    â”‚   â””â”€â”€ example.routes/
    â”‚       â”œâ”€â”€ simple/           # route with no guards
    â”‚       â”œâ”€â”€ guarded/          # route with guards
    â”‚       â””â”€â”€ parallel/         # route with 3.1.a, 3.1.b stones
    â””â”€â”€ setup.ts                  # setupRoute(), setupRouteStone()

blackbox/
â”œâ”€â”€ .test/
â”‚   â””â”€â”€ invokeRouteSkill.ts       # shell invocation helper
â”œâ”€â”€ driver.route.get.acceptance.test.ts
â”œâ”€â”€ driver.route.set.acceptance.test.ts
â””â”€â”€ driver.route.del.acceptance.test.ts
```

### mock helpers needed

```typescript
// src/.test/genMockRouteContext.ts
export const genMockRouteContext = (): RouteContext => ({
  route: '/path/to/route',
  stones: [],
});

// src/.test/genMockRouteStone.ts
export const genMockRouteStone = (input: {
  name: string;
  hasGuard?: boolean;
  hasArtifact?: boolean;
}): RouteStone => ({ ... });
```

### shell invocation helper

```typescript
// blackbox/.test/invokeRouteSkill.ts
export const invokeRouteSkill = async (input: {
  operation: 'get' | 'set' | 'del';
  stone: string;
  route: string;
  say?: boolean;
  as?: 'passed';
  cwd: string;
}): Promise<{ stdout: string; stderr: string; code: number }> => { ... };
```

---

## citations

all patterns sourced from `rhachet-roles-bhrain` repository:
- `jest.unit.config.ts:1-15`
- `jest.integration.config.ts:1-18`
- `jest.acceptance.config.ts:1-18`
- `src/domain.operations/reflect/stepReflect.test.ts:1-89`
- `src/domain.operations/reflect/stepReflect.integration.test.ts:1-156`
- `src/domain.operations/reflect/.test/setup.ts:1-67`
- `blackbox/.test/invokeReviewSkill.ts:1-78`
- `blackbox/review.representative-clean.acceptance.test.ts:1-112`
- `src/.test/genMockBrainArch1Context.ts:1-24`
- `src/.test/genTestBrainContext.ts:1-18`
