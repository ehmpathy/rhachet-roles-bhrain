# blackbox criteria: driver-route-stones

## usecase.1 = get next stone

```
given('a route with stones')
  when('robot requests next stone with --stone @next-one')
    then('returns the first incomplete stone by alphanumeric order')
      sothat('robot knows what to work on next')
    then('echoes stone content to stdout if --say flag provided')
      sothat('robot receives instructions directly')

  when('robot requests next stones with --stone @next-all')
    then('returns all incomplete stones that share the same full numeric prefix')
      sothat('robot can execute parallel work')

  when('all stones are complete')
    then('returns message: "all stones passed"')
      sothat('robot knows route is finished')

  when('route path does not exist')
    then('returns error: "route not found"')
      sothat('robot fails fast on bad input')
```

## usecase.2 = set stone as passed

```
given('a stone without a guard')
  when('robot sets stone --as passed')
    then('checks that artifact file exists via *.md glob pattern')
      sothat('artifacts with version suffixes like 1.vision.v1.i1.md are matched')
    then('marks stone as complete if artifact exists')
      sothat('robot can proceed to next stone')
    then('returns error if artifact does not exist: "artifact not found; run route.stone.get --stone $stone --say to see instructions"')
      sothat('robot knows how to produce the artifact')

given('a stone with a guard')
  when('robot sets stone --as passed')
    then('checks that artifact file exists via *.md glob pattern')
    then('runs all reviews specified in guard')
    then('produces review files under $route/.route/: $stone.guard.review.i$iter.$hash.r1.md, etc')
      sothat('driver artifacts are separate from route artifacts')
    then('runs all judges specified in guard')
    then('produces judge files under $route/.route/: $stone.guard.judge.i$rp$j.$reviewHash.$judgeHash.j1.md, etc')
      sothat('driver artifacts are separate from route artifacts and iterations + hashes are fully traceable')
    then('marks stone as complete if all judges pass')
      sothat('robot can proceed to next stone')
    then('returns rejection with feedback if any judge fails')
    then('includes paths to review files and judge files in rejection')
      sothat('robot can read full review and judgement content')

given('a stone with prior review/judge files for same $hash')
  when('robot sets stone --as passed')
    then('reuses prior review files from $route/.route/ instead of re-run')
    then('reuses prior judge files from $route/.route/ instead of re-run')
      sothat('no redundant compute on unchanged artifacts')

given('a stone with prior review/judge files for different $hash')
  when('robot sets stone --as passed')
    then('runs fresh reviews for new $hash')
    then('runs fresh judges for new $hash')
      sothat('changed artifacts get fresh evaluation')
```

## usecase.3 = delete unused stones

```
given('a stone with no artifact produced')
  when('robot deletes stone with --stone $glob')
    then('removes the .stone file')
    then('removes the .guard file if present')
      sothat('route is pruned to only needed stones')

given('a stone with an artifact already produced')
  when('robot deletes stone with --stone $glob')
    then('returns error: "cannot del; artifact exists"')
      sothat('history is preserved and not accidentally lost')

given('a glob that matches multiple stones')
  when('robot deletes with --stone *.research.*')
    then('deletes all matched stones that have no artifacts')
    then('skips matched stones that have artifacts and emits notice')
      sothat('batch cleanup is safe')
```

## usecase.4 = human-gated stone

```
given('a stone with approved? judge')
  when('robot sets stone --as passed before human approval')
    then('judge checks for .approved marker under $route/.route/')
    then('returns rejection: "wait for human approval"')
      sothat('human stays in control of gated milestones')

  when('human runs route.stone.set --stone $stone --as approved')
    then('creates $route/.route/$stone.approved marker')
      sothat('human approval is recorded as driver artifact')

  when('robot retries set stone --as passed after human approval')
    then('judge finds approval marker under $route/.route/')
    then('marks stone as complete')
      sothat('human approval unblocks progress')
```

## usecase.5 = review-gated stone

```
given('a stone with reviewed? judge and threshold --allow-blockers 0 --allow-nitpicks 2')
  when('review finds 1 blocker')
    then('judge fails with feedback from review')
      sothat('robot knows what blocker to fix')

  when('review finds 0 blockers and 3 nitpicks')
    then('judge fails: "nitpicks exceed threshold (3 > 2)"')
      sothat('robot knows to address nitpicks')

  when('review finds 0 blockers and 1 nitpick')
    then('judge passes')
      sothat('minor issues dont block progress')
```

## usecase.6 = parallel stone execution

```
given('a route with stones: 3.1.a.stone, 3.1.b.stone, 3.1.c.stone, 3.2.next.stone')
  when('robot requests --stone @next-all after 2.x complete')
    then('returns: 3.1.a, 3.1.b, 3.1.c')
      sothat('robot can execute all 3.1.x in parallel')

  when('robot completes 3.1.a and 3.1.b but not 3.1.c')
    then('--stone @next-one still returns 3.1.c')
      sothat('incomplete parallel stones block progression')

  when('robot completes all 3.1.x stones')
    then('--stone @next-one returns 3.2.next')
      sothat('next prefix tier unlocks after prior tier complete')
```

## usecase.7 = composed judges

```
given('a stone with multiple judges: reviewed? and approved?')
  when('review passes but human has not approved')
    then('stone is not marked complete')
    then('returns: "wait for human approval"')
      sothat('all judges must pass')

  when('human approves but review has blockers')
    then('stone is not marked complete')
    then('returns feedback from review')
      sothat('all judges must pass')

  when('review passes and human approves')
    then('stone is marked complete')
      sothat('composed gates work as AND logic')
```

## usecase.8 = separation of concerns: driver orchestrates, commands output

```
given('a review command in guard.reviews')
  when('driver executes the review command')
    then('review command outputs to stdout')
      sothat('review command does not need to know file locations')
    then('driver captures stdout and writes to $route/.route/$stone.guard.review.i$iter.$hash.r$n.md')
      sothat('driver handles all file management')

given('a judge command in guard.judges')
  when('driver executes the judge command')
    then('judge command outputs to stdout (passed: true/false, reason: ...)')
      sothat('judge command does not need to know file locations')
    then('driver captures stdout and writes to $route/.route/$stone.guard.judge.i$iter.$hash.j$n.md')
      sothat('driver handles all file management')
```

## usecase.9 = hash computation: each component hashes its inputs

```
given('the principle: each component hashes its inputs')
  when('driver needs review input hash')
    then('driver calls computeStoneReviewInputHash')
    then('hash is computed from artifacts (guard.artifacts glob content)')
      sothat('reviews are cached by their input content')

  when('driver needs judge input hash')
    then('driver calls computeStoneJudgeInputHash')
    then('hash is computed from reviews + approvals under .route/')
      sothat('judges are cached by their input content')

given('reviews evaluate artifacts')
  when('driver checks for cached reviews')
    then('driver computes review input hash from artifacts')
    then('if reviews exist for this hash, reuse them')
    then('if no reviews for this hash, run fresh reviews')

given('judges evaluate reviews and approvals')
  when('driver checks for cached judges')
    then('driver computes judge input hash from reviews + approvals')
    then('if judge exists for this hash and passed, reuse it')
    then('if no judge for this hash, run fresh judge')

given('the cascade: artifact change flows through')
  when('artifact content changes')
    then('review input hash changes')
    then('fresh reviews run (no cached reviews for new hash)')
    then('judge input hash changes (reviews changed)')
    then('fresh judge runs')

given('the cascade: approval granted flows through')
  when('artifact content unchanged but approval granted')
    then('review input hash unchanged')
    then('cached reviews reused')
    then('judge input hash changes (approval state changed)')
    then('fresh judge runs')
      sothat('judge sees new approval even with same reviews')

given('the cascade: review re-run after transient failure')
  when('review failed due to network error on first attempt')
    then('review input hash unchanged')
    then('review re-runs (transient failure, not cached)')
    then('review succeeds on second attempt')
    then('judge input hash changes (review content changed)')
    then('fresh judge runs')
      sothat('judge sees the successful review')
```
