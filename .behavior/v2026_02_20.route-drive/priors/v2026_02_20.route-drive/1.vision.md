# vision: route.drive

## the outcome world

### before: clones drift without gps

a human delegates work to a clone on a feature branch. the clone works for a while, gets distracted by a tangent, forgets the milestone, and when the session ends... no reminder fires. the clone just stops. next session, a new clone spawns with no memory of where the prior clone was headed or what they promised to deliver. the human must re-explain the goal, re-orient the clone, and hope this one stays on track.

worse: a clone thinks they're done but missed something obvious. they mark the stone as passed without self-checking. the human reviews hours later, finds glaring omissions, and has to re-delegate. wasted cycles. frustration. broken trust.

### after: clones have a gps that keeps them honest

```
onStop hook fires...

ğŸ¦‰ where were we?

ğŸ—¿ route.drive
   â”œâ”€ where to go
   â”‚  â”œâ”€ route = .behavior/v2026_02_20.my-feature
   â”‚  â””â”€ stone = 3.3.blueprint.v1
   â””â”€ are we there yet? if so, run
      â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed


   <stone name="3.3.blueprint.v1">

       propose a blueprint for how we can implement the wish described
       - in .behavior/v2026_02_20.my-feature/0.wish.md

       with the domain distillation declared
       ...

   </stone>
```

the `<stone>` tag contains the literal contents of the stone file. the clone sees exactly what the human prescribed - the full goal, done-when criteria, and guard configuration. no ambiguity, no rewording.

the clone is never lost. every session end reminds them: here's your mission in full, here's how to signal completion.

### the "aha" moment

the clone runs `rhx route.stone.set --stone 2.criteria.blackbox --as passed`:

```
ğŸ¦‰ so you're saying there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 2.criteria.blackbox
   â””â”€ passage = blocked (self-review required)

ğŸ” check yo'self
   â”œâ”€ review.self 1/3
   â”‚  â”œâ”€ slug = all-done
   â”‚  â””â”€ see the guide below
   â””â”€ promise its done? if so, run
      â””â”€ rhx route.stone.set --stone 2.criteria.blackbox --as promised --that all-done


   <review.self.guide slug="all-done">

       did you complete everything requested in this stone?
       have you re-read the stone goal and verified each
       requirement is fulfilled with no omissions?

   </review.self.guide>
```

the clone pauses. "wait, did i actually do everything?" they re-read the stone. they find they forgot to document edge cases. they fix it. then they promise.

this is the ralph wiggum loop in action: forcing the self-check before allowing the claim of completion.

## user experience

### usecase 1: human prescribes a route, clone follows

**timeline:**

1. human creates behavior route at `.behavior/v2026_02_20.my-feature/`
2. human runs `rhx route.bind --route .behavior/v2026_02_20.my-feature`
3. human spawns clone, says "work on this feature"
4. clone session starts, boot hook shows bound route context
5. clone works on first stone
6. clone session ends -> `route.drive` hook fires, echoes current stone contents in `<stone>` tag
7. clone returns next session, picks up where they left off
8. clone thinks they're done, runs `rhx route.stone.set --as passed`
9. self-reviews prompt: "did you complete everything?" -> clone promises
10. self-reviews prompt: "do all tests pass?" -> clone promises
11. self-reviews prompt: "is there dead code?" -> clone promises
12. stone marked as passed, `route.drive` shows next stone

### usecase 2: human defines self-reviews per stone

```yaml
# .behavior/v2026_02_20.my-feature/2.criteria.blackbox.md
---
guard:
  review:
    self:
      - slug: all-done
        say: |
          did you complete everything requested in this stone?
          have you re-read the stone goal and verified each requirement?

      - slug: tests-pass
        say: "@briefs/self-review.tests-pass.md"

      - slug: no-dead-code
        say: |
          did you remove all dead code?
          no commented-out blocks? no unused imports?
---
```

the `say` can be inline text or a link to a brief. either way, it's echoed to the clone during the self-review flow.

### usecase 3: clone resumes after interruption

clone gets interrupted mid-stone. session ends. next session:

```
ğŸ¦‰ where were we?

ğŸ—¿ route.drive
   â”œâ”€ where to go
   â”‚  â”œâ”€ route = .behavior/v2026_02_20.my-feature
   â”‚  â””â”€ stone = 3.3.blueprint.v1
   â””â”€ are we there yet? if so, run
      â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed


   <stone name="3.3.blueprint.v1">

       propose a blueprint for how we can implement the wish described
       - in .behavior/v2026_02_20.my-feature/0.wish.md

       with the domain distillation declared
       ...

   </stone>
```

clone immediately knows: this is where i was, this is what i need to do next.

## mental model

### how humans describe it

"it's like a gps for the robot. you set the destination (the route), and every time the ai stops, it reminds them where they are and what exit to take next. and before they can claim they've arrived, they have to promise they actually checked the address."

### analogies

| concept | analogy |
|---------|---------|
| route | a hiking trail with waypoints |
| stone | a waypoint / checkpoint |
| route.bind | setting gps destination |
| route.drive | gps voice saying "in 100 meters, turn right" |
| review.self | pilot checklist before declaring "ready for takeoff" |
| --as promised | signing the checklist item |

### terms comparison

| what we call it | what users might say |
|-----------------|---------------------|
| stone | milestone, checkpoint, stage |
| route.drive | autopilot, navigator, reminder |
| review.self | self-check, sanity check, promise list |
| --as promised | checked off, verified, confirmed |

## evaluation

### how well does it solve the goals?

| goal | solved? | how |
|------|---------|-----|
| clones know what they're working on | yes | onStop hook echoes current stone |
| clones remember across sessions | yes | route is bound to branch, persists |
| clones self-check before claiming done | yes | review.self with promise flow |
| humans trust clone completion claims | yes | promises create explicit contract |
| guards still run as peer review | yes | review.peer (extant) unchanged |

### pros

- **always-on orientation**: clone never forgets the mission
- **explicit promises**: forces self-reflection, reduces false-positives
- **composable reviews**: inline text or brief refs for reusable checklists
- **hash-based invalidation**: promises expire when source changes
- **progressive disclosure**: one review at a time, not overwhelming

### cons

- **ceremony overhead**: extra steps to mark as passed (mitigated: only when review.self defined)
- **promise fatigue**: too many self-reviews could feel tedious (mitigated: keep lists short, 3-5 items)
- **false promises**: clone could lie (mitigated: peer reviews still run after; this catches honest mistakes)

### edgecases and pit of success

| edgecase | pit of success design |
|----------|----------------------|
| clone runs `--as passed` without review.self | proceeds directly to peer reviews |
| clone forgets `--that` slug | skill echoes valid options |
| source hash changes mid-review | old promises invalidated, must re-promise |
| no route bound | `route.drive` is a no-op, no error |
| route bound but all stones passed | `route.drive` says "route complete!" |
| clone tries to skip a review.self | skill blocks until all promised |

### what could be awkward?

1. **long promise slugs**: `--as promised --that all-tests-pass-including-priors-even-unrelated` is verbose
   - mitigation: keep slugs short and memorable

2. **too many self-reviews**: 10 items per stone would be exhausting
   - mitigation: recommend 2-4 per stone, document best practices

3. **promise vs approve confusion**: when to use `--as passed` vs `--as approved`?
   - `--as passed` = clone self-review (i did the work)
   - `--as approved` = human/peer review (someone else checked)
   - document clearly

4. **onStop timing**: what if clone is mid-thought when session ends?
   - the reminder is helpful, not interruptive; clone was going to stop anyway

## summary

`route.drive` transforms clones from amnesiac workers into gps-guided navigators who:
1. always know their current milestone
2. are reminded at every session end
3. must explicitly promise self-review before claiming completion
4. progress through stones with clear next-steps

the human prescribes the route; the clone drives it. trust is earned through explicit promises. no more drift. no more forgotten context. just steady, honest progress toward the goal.

slow and steady builds reliable software.
