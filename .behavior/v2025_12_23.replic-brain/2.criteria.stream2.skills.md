# behavioral criteria for replic-brain â€” stream 2: skills

**focus:** implementation, testing, execution

**deliverables:**
- `src/roles/architect/skills/brain.replic.struct1/`

---

## usecase.1 = define executable blueprint for brain.replic.struct1

given('the reference blueprint from briefs is understood')
  when('the executable blueprint is created')
    then('it specifies exact typescript interfaces for each component')
      sothat('developers have concrete contracts to implement')
    then('it specifies exact file structure and module boundaries')
      sothat('developers know where code lives')
    then('it specifies exact dependencies between components')
      sothat('developers know the build order')

given('the executable blueprint targets mvp parity with claude-code')
  when('scoping the mvp')
    then('core repl loop is in scope')
      sothat('the fundamental interaction pattern works')
    then('tool invocation is in scope')
      sothat('the brain can take actions in the environment')
    then('context management is in scope')
      sothat('the brain maintains coherent state across turns')
    then('error handling is in scope')
      sothat('the brain recovers gracefully from failures')

given('the executable blueprint supports multiple llm backends')
  when('defining the llm adapter interface')
    then('it specifies a backend-agnostic llm interface')
      sothat('any conforming llm can be plugged in')
    then('it specifies anthropic adapter implementation')
      sothat('claude api can be used')
    then('it specifies qwen adapter implementation')
      sothat('opensource llm can be used')
    then('adapter-specific quirks are documented')
      sothat('implementers know what to handle per backend')

given('the executable blueprint is complete')
  when('a developer reads it')
    then('they can implement without ambiguity')
      sothat('no guesswork is required')
    then('they can test each component independently')
      sothat('incremental progress is possible')
    then('they can integrate components in defined order')
      sothat('the system assembles predictably')

---

## usecase.2 = test atomic components of brain structure

given('an atomic component of the brain structure')
  when('the component is tested in isolation')
    then('its inputs and outputs are validated against contract')
      sothat('we know it behaves as specified')
    then('its boundary conditions are exercised')
      sothat('we know it handles edge cases')
    then('its failure modes are verified')
      sothat('we know it fails fast and observably')

given('a prompt construction component')
  when('tested')
    then('it produces deterministic output for the same input')
      sothat('behavior is reproducible')
    then('it includes all required context elements')
      sothat('the llm has what it needs')
    then('it respects token limits')
      sothat('it does not exceed model constraints')

given('a tool execution component')
  when('tested')
    then('it parses tool calls correctly from llm output')
      sothat('the brain can understand what action to take')
    then('it executes tools with correct arguments')
      sothat('actions have the intended effect')
    then('it formats tool results for llm consumption')
      sothat('the brain can understand what happened')

given('a context management component')
  when('tested')
    then('it tracks conversation history correctly')
      sothat('the brain remembers what was said')
    then('it summarizes or truncates when context exceeds limits')
      sothat('the brain can continue operating')
    then('it preserves critical information during truncation')
      sothat('important context is not lost')

---

## usecase.3 = test integrated brain behavior

given('brain.replic.struct1 is assembled from components')
  when('the integrated system is tested')
    then('end-to-end repl loops complete successfully')
      sothat('the full cycle works')
    then('multi-turn conversations maintain coherence')
      sothat('the brain tracks context across interactions')
    then('tool sequences execute in correct order')
      sothat('complex tasks complete correctly')

given('brain.replic.struct1 is tested against reference behaviors')
  when('compared to claude-code on equivalent tasks')
    then('it produces functionally equivalent outcomes')
      sothat('parity is validated')
    then('divergences are documented with rationale')
      sothat('differences are understood, not hidden')

given('brain.replic.struct1 is tested with different llm backends')
  when('swapping from anthropic to qwen')
    then('the same test suite passes')
      sothat('the architecture is validated as backend-agnostic')
    then('performance characteristics are documented')
      sothat('tradeoffs between backends are understood')

---

## usecase.4 = leverage rhachet for implementation

given('rhachet provides thought route construction via typescript')
  when('implementing brain.replic.struct1')
    then('components are defined as rhachet-compatible modules')
      sothat('we leverage existing infrastructure')
    then('thought routes wire components together')
      sothat('the repl loop is expressed declaratively')
    then('tests use rhachet testing patterns')
      sothat('test code is consistent with prod code')

given('rhachet patterns are used')
  when('a new component is added to brain.replic.struct1')
    then('it follows the (input, context) signature pattern')
      sothat('it integrates cleanly with existing code')
    then('it is testable in isolation')
      sothat('unit tests can cover it independently')
    then('it is composable into larger flows')
      sothat('it can be wired into thought routes')

---

## boundary.1 = invalid inputs to brain

given('the brain receives malformed input')
  when('the input cannot be parsed')
    then('it fails fast with a clear error')
      sothat('the failure is observable and debuggable')
    then('it does not hallucinate a response')
      sothat('garbage in does not produce misleading output')

given('the brain receives input exceeding context limits')
  when('the input is too large')
    then('it truncates or summarizes gracefully')
      sothat('operation can continue')
    then('it signals that truncation occurred')
      sothat('the caller knows context was reduced')

---

## boundary.2 = llm failures

given('the underlying llm returns an error')
  when('the error is transient (rate limit, timeout)')
    then('the brain retries with appropriate backoff')
      sothat('temporary issues are handled automatically')
    then('it eventually fails if retries exhaust')
      sothat('it does not loop forever')

given('the underlying llm returns an error')
  when('the error is permanent (invalid request, auth failure)')
    then('the brain fails fast without retry')
      sothat('unrecoverable errors surface immediately')
    then('the error includes diagnostic context')
      sothat('the cause can be identified')

---

## boundary.3 = tool execution failures

given('a tool execution fails')
  when('the tool returns an error')
    then('the error is formatted and returned to the llm')
      sothat('the brain can reason about the failure')
    then('the brain can attempt recovery or alternative actions')
      sothat('single tool failures do not halt progress')

given('a tool execution hangs')
  when('the timeout is exceeded')
    then('the tool is terminated')
      sothat('the brain does not wait forever')
    then('a timeout error is returned to the llm')
      sothat('the brain knows what happened')

---

## boundary.4 = llm backend swapping

given('brain.replic.struct1 is running with anthropic backend')
  when('the backend is swapped to qwen')
    then('no changes to the repl loop logic are required')
      sothat('the architecture is truly backend-agnostic')
    then('only the llm adapter layer changes')
      sothat('the swap is localized and minimal')

given('a new llm backend is added')
  when('implementing the adapter')
    then('it conforms to the llm interface contract')
      sothat('it plugs in without structural changes')
    then('backend-specific quirks are encapsulated in the adapter')
      sothat('the rest of the system is unaffected')
