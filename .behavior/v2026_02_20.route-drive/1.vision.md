# vision: route.drive

## the outcome world

### before: clones drift without gps

a human delegates work to a clone on a feature branch. the clone works for a while, gets distracted by a tangent, forgets the milestone, and when the session ends... no reminder fires. the clone just stops. next session, a new clone spawns with no memory of where the prior clone was headed or what they promised to deliver. the human must re-explain the goal, re-orient the clone, and hope this one stays on track.

worse: a clone thinks they're done but missed an obvious defect. they mark the stone as passed without a self-check. the human reviews hours later, finds blatant omissions, and has to re-delegate. wasted cycles. frustration. broken trust.

### after: clones have a gps that keeps them honest

```
onStop hook fires...

ğŸ¦‰ where were we?

ğŸ—¿ route.drive
   â”œâ”€ where do we go?
   â”‚  â”œâ”€ route = .behavior/v2026_02_20.my-feature
   â”‚  â””â”€ stone = 3.3.blueprint.v1
   â”‚
   â”œâ”€ are we there yet? if so, run
   â”‚  â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed
   â”‚
   â”œâ”€ here's the stone
   â”‚  â”œâ”€
   â”‚  â”‚
   â”‚  â”‚  propose a blueprint for how we can implement the wish described
   â”‚  â”‚  - in .behavior/v2026_02_20.my-feature/0.wish.md
   â”‚  â”‚
   â”‚  â”‚  with the domain distillation declared
   â”‚  â”‚  ...
   â”‚  â”‚
   â”‚  â””â”€
   â”‚
   â””â”€ are we there yet? if so, run
      â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed
```

the stone content contains the literal contents of the stone file. the clone sees exactly what the human prescribed - the full goal, done-when criteria, and guard configuration. no ambiguity, no restatement.

the clone is never lost. every session end reminds them: here's your mission in full, here's how to signal completion.

### the "aha" moment

the clone runs `rhx route.stone.set --stone 2.criteria.blackbox --as passed`:

```
ğŸ¦‰ so you're saying there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 2.criteria.blackbox
   â””â”€ passage = blocked (self-review required)

ğŸ” check yo'self
   â”œâ”€ review.self 1/3
   â”‚  â”œâ”€ slug = all-done
   â”‚  â”œâ”€ question everything, especially yourself
   â”‚  â””â”€ see the guide below
   â”‚
   â”œâ”€ promise its done? if so, run
   â”‚  â””â”€ rhx route.stone.set --stone 2.criteria.blackbox --as promised --that all-done
   â”‚
   â”œâ”€ here's the guide
   â”‚  â”œâ”€
   â”‚  â”‚
   â”‚  â”‚  did you complete all that was requested in this stone?
   â”‚  â”‚  have you re-read the stone goal and verified each
   â”‚  â”‚  requirement is fulfilled with no omissions?
   â”‚  â”‚
   â”‚  â””â”€
   â”‚
   â””â”€ promise its done? if so, run
      â””â”€ rhx route.stone.set --stone 2.criteria.blackbox --as promised --that all-done
```

the clone pauses. "wait, did i actually do all of it?" they re-read the stone. they find they forgot to document edge cases. they fix it. then they promise.

this is the ralph wiggum loop in action: the self-check is forced before the claim of completion is allowed.

after the promise, clone runs `rhx route.stone.set --stone 2.criteria.blackbox --as promised --that all-done`:

```
ğŸ¦‰ so you're saying there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 2.criteria.blackbox
   â””â”€ passage = progressed (self-review 1/3 promised)

ğŸ” check yo'self
   â”œâ”€ review.self 2/3
   â”‚  â”œâ”€ slug = tests-pass
   â”‚  â”œâ”€ question everything, especially yourself
   â”‚  â””â”€ see the guide below
   â”‚
   â”œâ”€ promise its done? if so, run
   â”‚  â””â”€ rhx route.stone.set --stone 2.criteria.blackbox --as promised --that tests-pass
   â”‚
   â”œâ”€ here's the guide
   â”‚  â”œâ”€
   â”‚  â”‚
   â”‚  â”‚  do all tests pass? have you run the full test suite
   â”‚  â”‚  and verified no regressions were introduced?
   â”‚  â”‚
   â”‚  â””â”€
   â”‚
   â””â”€ promise its done? if so, run
      â””â”€ rhx route.stone.set --stone 2.criteria.blackbox --as promised --that tests-pass
```

clone promises that one. then runs `--as promised --that tests-pass`. system shows 3/3:

```
ğŸ¦‰ so you're saying there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 2.criteria.blackbox
   â””â”€ passage = progressed (self-review 2/3 promised)

ğŸ” check yo'self
   â”œâ”€ review.self 3/3
   â”‚  â”œâ”€ slug = no-dead-code
   â”‚  â”œâ”€ question everything, especially yourself
   â”‚  â””â”€ see the guide below
   â”‚
   â”œâ”€ promise its done? if so, run
   â”‚  â””â”€ rhx route.stone.set --stone 2.criteria.blackbox --as promised --that no-dead-code
   â”‚
   â”œâ”€ here's the guide
   â”‚  â”œâ”€
   â”‚  â”‚
   â”‚  â”‚  did you remove all dead code?
   â”‚  â”‚  no commented-out blocks? no unused imports?
   â”‚  â”‚
   â”‚  â””â”€
   â”‚
   â””â”€ promise its done? if so, run
      â””â”€ rhx route.stone.set --stone 2.criteria.blackbox --as promised --that no-dead-code
```

clone promises that one. all self-reviews done. system proceeds to peer reviews and judges:

```
ğŸ¦‰ so you're saying there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 2.criteria.blackbox
   â”œâ”€ passage = blocked (guard review failed)
   â”œâ”€ reason = blockers exceed threshold (2 > 0)
   â””â”€ guard
      â”œâ”€ artifacts
      â”‚  â””â”€ 2.criteria.blackbox.i1.md
      â”œâ”€ reviews
      â”‚  â””â”€ r1: rhx review --rules .agent/**/rules/*.md --paths 2.criteria.blackbox*.md
      â”‚     â”œâ”€ finished 12.3s âœ“
      â”‚     â”œâ”€ review: .route/2.criteria.blackbox.review.r1.md
      â”‚     â””â”€ 2 blockers ğŸ”´
      â””â”€ judges
         â””â”€ j1: rhx route.stone.judge --mechanism reviewed? --stone $stone --route $route
            â”œâ”€ finished 0.1s âœ—
            â”œâ”€ judge: .route/2.criteria.blackbox.judge.j1.md
            â””â”€ reason: blockers exceed threshold (2 > 0)
```

clone fixes blockers, runs `--as passed` again. self-reviews invalidated (hash changed), must re-promise. cycle repeats until guards pass.

## user experience

### usecase 1: human prescribes a route, clone follows

**timeline:**

1. human creates behavior route at `.behavior/v2026_02_20.my-feature/`
2. human runs `rhx route.bind --route .behavior/v2026_02_20.my-feature`
3. human spawns clone, says "work on this feature"
4. clone session starts, boot hook shows bound route context
5. clone works on first stone
6. clone session ends -> onStop hook fires `rhx route.drive`
7. `route.drive` echoes current stone contents, shows next command
8. clone returns next session, picks up where they left off
9. clone thinks they're done, runs `rhx route.stone.set --as passed`
10. review.self prompts: "did you complete all of it?" -> clone promises
11. review.self prompts: "do all tests pass?" -> clone promises
12. review.self prompts: "is there dead code?" -> clone promises
13. all reviews promised -> stone proceeds to peer reviews (guard.review.peer)
14. guards pass -> stone marked as passed
15. `route.drive` shows next stone

### usecase 2: human defines self-reviews per stone

**flat array (peer only, backwards compatible):**

```yaml
# .behavior/v2026_02_20.my-feature/2.criteria.blackbox.guard
artifacts:
  - 2.criteria.blackbox*.md

reviews:
  - rhx review --rules .agent/**/rules/*.md --paths 2.criteria.blackbox*.md

judges:
  - rhx route.stone.judge --mechanism reviewed? --stone $stone --route $route --allow-blockers 0
  - rhx route.stone.judge --mechanism approved? --stone $stone --route $route
```

**structured object (with self-reviews):**

```yaml
# .behavior/v2026_02_20.my-feature/2.criteria.blackbox.guard
artifacts:
  - 2.criteria.blackbox*.md

reviews:
  self:
    - slug: all-done
      say: |
        did you complete all that was requested in this stone?
        have you re-read the stone goal and verified each requirement?

    - slug: tests-pass
      say: "@briefs/self-review.tests-pass.md"

    - slug: no-dead-code
      say: |
        did you remove all dead code?
        no commented-out blocks? no unused imports?

  peer:
    - rhx review --rules .agent/**/rules/*.md --paths 2.criteria.blackbox*.md

judges:
  - rhx route.stone.judge --mechanism reviewed? --stone $stone --route $route --allow-blockers 0
  - rhx route.stone.judge --mechanism approved? --stone $stone --route $route
```

the `say` can be inline text or a link to a brief via `@path/to/brief.md`. either way, it's echoed to the clone in the self-review flow.

### usecase 3: clone resumes after interruption

clone gets interrupted mid-stone. session ends. next session:

```
onStop hook fires (or boot hook on fresh session)...

ğŸ¦‰ where were we?

ğŸ—¿ route.drive
   â”œâ”€ where do we go?
   â”‚  â”œâ”€ route = .behavior/v2026_02_20.my-feature
   â”‚  â””â”€ stone = 3.3.blueprint.v1
   â”‚
   â”œâ”€ are we there yet? if so, run
   â”‚  â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed
   â”‚
   â”œâ”€ here's the stone
   â”‚  â”œâ”€
   â”‚  â”‚
   â”‚  â”‚  propose a blueprint for how we can implement the wish described
   â”‚  â”‚  - in .behavior/v2026_02_20.my-feature/0.wish.md
   â”‚  â”‚
   â”‚  â”‚  with the domain distillation declared
   â”‚  â”‚  ...
   â”‚  â”‚
   â”‚  â””â”€
   â”‚
   â””â”€ are we there yet? if so, run
      â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed
```

clone immediately knows: this is where i was, this is what i need to do next.

### usecase 4: source changes invalidate prior promises

clone promises "all-done" for a stone. then realizes they missed an item, edits the artifact. runs `--as passed` again:

```
ğŸ¦‰ so you're saying there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 2.criteria.blackbox
   â””â”€ passage = blocked (self-review required)

ğŸ” check yo'self
   â”œâ”€ review.self 1/3
   â”‚  â”œâ”€ slug = all-done
   â”‚  â”œâ”€ status = invalidated (source hash changed)
   â”‚  â”œâ”€ question everything, especially yourself
   â”‚  â””â”€ see the guide below
   â”‚
   â”œâ”€ promise its done? if so, run
   â”‚  â””â”€ rhx route.stone.set --stone 2.criteria.blackbox --as promised --that all-done
   â”‚
   â”œâ”€ here's the guide
   â”‚  â”œâ”€
   â”‚  â”‚
   â”‚  â”‚  ...
   â”‚  â”‚
   â”‚  â””â”€
   â”‚
   â””â”€ promise its done? if so, run
      â””â”€ rhx route.stone.set --stone 2.criteria.blackbox --as promised --that all-done
```

the promise was invalidated because the guarded artifact's hash changed. clone must re-promise. no stale self-reviews.

## mental model

### how humans describe it

"it's like a gps for the robot. you set the destination (the route), and every time the ai stops, it reminds them where they are and what exit to take next. and before they can claim they've arrived, they have to promise they actually checked the address."

### analogies

| concept | analogy |
|---------|---------|
| route | a trail with waypoints |
| stone | a waypoint / checkpoint |
| route.bind | set gps destination |
| route.drive | gps voice: "in 100 meters, turn right" |
| review.self | pilot checklist before "ready for takeoff" |
| review.peer | co-pilot that verifies the checklist |
| --as promised --that | sign each checklist item |

### terms comparison

| what we call it | what users might say |
|-----------------|---------------------|
| stone | milestone, checkpoint, stage |
| route.drive | autopilot, navigator, reminder |
| review.self | self-check, sanity check, promise list |
| review.peer | code review, peer review |
| --as promised --that | checked off, verified, confirmed |

## evaluation

### how well does it solve the goals?

| goal | solved? | how |
|------|---------|-----|
| clones know what they're active on | yes | onStop hook echoes current stone contents |
| clones remember across sessions | yes | route is bound to branch, persists |
| clones self-check before they claim done | yes | review.self with promise flow |
| humans trust clone completion claims | yes | promises create explicit contract |
| guards still run as peer review | yes | review.peer (extant) unchanged |
| stale promises don't count | yes | hash-based invalidation |

### pros

- **always-on orientation**: clone never forgets the mission
- **explicit promises**: forces self-reflection, reduces false-positives
- **composable reviews**: inline text or brief refs for reusable checklists
- **hash-based invalidation**: promises expire when source changes
- **progressive disclosure**: one review at a time, not too much
- **separation of concerns**: review.self = clone's work, review.peer = external validation

### cons

- **ceremony overhead**: extra steps to mark as passed (mitigated: only when review.self defined)
- **promise fatigue**: too many self-reviews could feel tedious (mitigated: keep lists short, 2-4 items)
- **false promises**: clone could lie (mitigated: peer reviews still run after; this catches honest mistakes)

### edgecases and pit of success

| edgecase | pit of success design |
|----------|----------------------|
| clone runs `--as passed` without review.self defined | proceeds directly to peer reviews |
| clone forgets `--that` slug | skill echoes valid options |
| source hash changes mid-review | old promises invalidated, must re-promise |
| no route bound | `route.drive` is a no-op, no error |
| route bound but all stones passed | `route.drive` says "route complete!" |
| clone tries to skip a review.self | skill blocks until all promised |
| review.self `say` references absent brief | skill errors with path, not cryptic failure |

### what could be awkward?

1. **long promise slugs**: `--as promised --that all-tests-pass-and-priors-even-unrelated` is verbose
   - mitigation: keep slugs short and memorable (e.g., `tests-pass`, `no-dead-code`)

2. **too many self-reviews**: 10 items per stone would be tedious
   - mitigation: recommend 2-4 per stone, document best practices

3. **promise vs passed vs approved confusion**: when to use each?
   - `--as promised --that $slug` = clone promises a specific self-review item
   - `--as passed` = clone attempts to mark stone as complete (triggers reviews)
   - `--as approved` = human/peer review (someone else checked)
   - document clearly, skill echoes correct command at each step

4. **onStop slot**: what if clone is mid-thought when session ends?
   - the reminder is helpful, not interruptive; clone was about to stop anyway

## summary

`route.drive` transforms clones from amnesiac workers into gps-guided navigators who:

1. always know their current milestone (stone contents echoed)
2. are reminded at every session end (onStop hook)
3. must explicitly promise self-review before they claim completion (ralph wiggum loop)
4. can't rely on stale promises (hash invalidation)
5. progress through stones with clear next-steps

the human prescribes the route; the clone drives it. trust is earned through explicit promises. no more drift. no more forgotten context. just steady, honest progress toward the goal.

slow and steady builds reliable software. ğŸ¢
