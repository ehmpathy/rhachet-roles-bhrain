# vision: route.bind

## the outcome world

### before

every route stone operation requires the full `--route` path:

```sh
route.stone.get --stone @next-one --route .behavior/v2026_02_05.driver-route-bind
route.stone.set --stone 1.vision --as passed --route .behavior/v2026_02_05.driver-route-bind
route.stone.get --stone @next-one --route .behavior/v2026_02_05.driver-route-bind
route.stone.set --stone 2.1.criteria.blackbox --as passed --route .behavior/v2026_02_05.driver-route-bind
```

the same `--route .behavior/v2026_02_05.driver-route-bind` repeated on every call. noisy, error-prone, tedious. agents and humans both need to remember and paste it every time.

### after

bind the route once, then forget about it:

```sh
# bind once at the start of a branch
route.bind --route .behavior/v2026_02_05.driver-route-bind

# every subsequent call just works
route.stone.get --stone @next-one
route.stone.set --stone 1.vision --as passed
route.stone.get --stone @next-one
route.stone.set --stone 2.1.criteria.blackbox --as passed
```

the `--route` is resolved from the bind. less noise, fewer mistakes, faster flow.

### the "aha" moment

the first time you type `route.stone.get --stone @next-one` without `--route` and it just works — you realize the bind turned a multi-arg ceremony into a one-arg command. it feels like `cd` into a directory and then just run commands there.

---

## user experience

### usecase 1: bind at branch start

a developer starts work on a new behavior and binds the route:

```sh
route.bind --route .behavior/v2026_02_05.driver-route-bind
# → writes .route/bind file
# → confirms: "✨ bound route: .behavior/v2026_02_05.driver-route-bind"

# all subsequent route commands auto-resolve
route.stone.get --stone @next-one
# → resolves --route from .route/bind
# → returns: 1.vision
```

### usecase 2: external callers can invoke route.bind

bhrain has no knowledge of external tools. but external tools (e.g., bhuild) can call `route.bind` as a public contract to set the route on behalf of the branch:

```sh
# an external tool calls bhrain's route.bind
npx rhachet run --skill route.bind --route .behavior/v2026_02_05.driver-route-bind
# → bhrain writes its own .route/bind state
# → bhrain has zero awareness of who called it or why
```

this keeps bhrain self-contained. the contract is: "give me a route path, i'll bind it." who calls it and when is not bhrain's concern.

### usecase 3: check what's bound

```sh
route.bind --get
# → "bound to: .behavior/v2026_02_05.driver-route-bind"

# or when none is bound:
route.bind --get
# → "not bound"
```

### usecase 4: unbind

```sh
route.bind --del
# → removes the bind state
# → "unbound route"
```

### usecase 5: explicit --route still works

the bind is a fallback, not a mandate. explicit `--route` always wins:

```sh
# even with a bind active, you can override
route.stone.get --stone @next-one --route .behavior/some-other-route
```

### timeline

```
branch created
  → route.bind --route .behavior/xyz    (by human, agent, or external tool)
  → route.stone.get --stone @next-one   # auto-resolves
  → route.stone.set --stone 1.vision --as passed
  → route.stone.get --stone @next-one
  → ... iterate through all stones ...
  → branch merged
  → .route/bind is historical artifact
```

---

## mental model

### how a user would describe it

> "you bind a route to your branch once, then all route commands know which route you're on. like set a work directory."

### analogy

it's like `cd` — you change into a directory once, and then every command runs relative to it. `route.bind` sets the route once, and every route command operates on it.

### terms

| user term | system term | definition |
|-----------|-------------|------------|
| "bind" | `route.bind` | associate a route path with the current branch |
| "bound route" | `.route/bind` | the file that stores the bound route path |
| "auto-resolve" | cli fallback logic | when --route is absent, read from `.route/bind` |

---

## persistence

### file location

the bind flag lives inside the route directory's own `.route/`, alongside passage markers and other artifacts:

```
.behavior/v2026_02_05.driver-route-bind/
├── 0.wish.md
├── 1.vision.md
├── ...stones...
└── .route/
    ├── .bind.vlad.driver-route-bind.flag   ← bind: branch vlad/driver-route-bind → this route
    ├── 1.vision.passed                     ← passage marker
    ├── 2.1.criteria.blackbox.passed
    └── ...artifacts...
```

the route directory owns all its state — binds, passage markers, reviews, judges. no separate global directory needed.

### flag file convention

**filename**: `.bind.<flattened-branch>.flag`

- dot-prefixed (`.bind.`) so it sorts to the top and is visually distinct from artifact files
- `<flattened-branch>` uses the same flatten algorithm as bhuild (`/` → `.`)

**example**: branch `vlad/driver-route-bind` → file `.bind.vlad.driver-route-bind.flag`

**file format**:
```
branch: vlad/driver-route-bind
bound_by: route.bind skill
```

- `branch:` = the original branch name (before flatten)
- `bound_by:` = what created this bind (for observability)

no need for a `route:` field — the flag's location IS the route. the parent directory of `.route/` is the route path.

flag files are committed to git. this means:
- the bind travels with the branch
- it's visible in prs and diffs
- multiple branches can each bind to the same route (each gets its own flag file)

### resolution algorithm

when `--route` is not provided on a route command:

1. get current branch name via `git rev-parse --abbrev-ref HEAD`
2. flatten the branch name (`/` → `.`)
3. scan for `**/.route/.bind.<flattened-branch>.flag` from repo root
4. if exactly one match → use the parent of `.route/` as the route path
5. if zero matches → error: "no route bound to this branch. use --route or route.bind"
6. if multiple matches → error: "multiple routes bound to this branch. use --route to disambiguate"

### design: bhrain is self-contained

bhrain has zero knowledge of any external tool. the `route.bind` skill is a public contract:

- **input**: `--route <path>` (the route directory to bind to)
- **output**: flag file at `<route-dir>/.route/.bind.<branch>.flag`
- **consumer**: bhrain's own `route.stone.*` commands

external tools can call `route.bind` if they want to set the route. bhrain doesn't know or care who calls it. the boundary is clean: bhrain owns its own state, no coupled dependencies.

---

## evaluation

### how well does it solve the goals?

- eliminates `--route` repetition on every command → primary goal fulfilled
- bhrain is self-contained with its own bind state → no external dependencies
- external tools can call `route.bind` as a contract → composable without tight deps
- explicit `--route` still works → no break, progressive adoption

### pros

- **less noise**: commands go from 2 required args to 1
- **fewer mistakes**: no risk of copy-paste the wrong route path
- **self-contained**: bhrain owns the bind flags, no knowledge of external tools
- **colocated**: bind lives in the route directory's `.route/` alongside all other route state
- **composable**: external tools call `route.bind` as a contract, not the other way around
- **idempotent**: bind of the same route twice is a no-op
- **per-branch**: each branch has its own flag file, committed to git, travels with the branch
- **explicit override**: `--route` flag always wins over the bind
- **no new directories**: reuses the route's own `.route/` — no repo-root `.route/` needed

### cons

- **scan cost**: resolution scans `**/.route/.bind.<branch>.flag` (trivial for typical repos)
- **one bind per branch**: each branch can only bind one route (mitigated by explicit `--route` for ad-hoc access to other routes)

### edge cases and pit of success

| edge case | behavior | pit of success |
|-----------|----------|----------------|
| no bind and no --route | error: "no route bound. use --route or route.bind" | clear guidance |
| multiple routes bound to same branch | error: "multiple routes bound. use --route to disambiguate" | prevents silent wrong-route |
| explicit --route with active bind | explicit wins, bind ignored | power users retain control |
| bind to protected branch (main) | error: "cannot bind route on main" | prevents shared-branch pollution |
| bind same route twice | idempotent success | safe to retry |
| bind different route when one exists | error: "already bound to X. use route.bind --del first" | prevents accidental overwrite |
| bound route directory deleted | error on resolve: "bound route path does not exist" | clear diagnostic |
| flag file malformed | error: "invalid bind file format" | fail-fast, no silent misbehavior |
