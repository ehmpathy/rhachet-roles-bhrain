# usecase.1 = pass single ref file to review skill

given('a rule that expects referenced context')
given('a ref file exists at the specified path')
  when('review is invoked with --refs set to a single file')
    then('the review completes successfully')
      sothat('the reviewer has access to ref content')
    then('the review output reflects awareness of the ref content')
      sothat('rules can leverage referenced context in their evaluation')


# usecase.2 = pass multiple refs via glob pattern

given('a rule that expects referenced context')
given('multiple ref files match the glob pattern')
  when('review is invoked with --refs set to a glob pattern')
    then('all matched files are included as refs')
      sothat('rules can reference multiple documents in one invocation')
    then('the review output reflects awareness of all matched ref content')


# usecase.3 = ref content is accessible to rules in review

given('a rule that instructs the reviewer to verify criteria from refs')
given('a ref file with criteria definitions')
  when('review is invoked with that rule and ref')
    then('the review output demonstrates that ref content was evaluated')
      sothat('rules can instruct the reviewer to cross-reference external docs')
    then('violations found via ref comparison appear in review output')


# usecase.4 = no refs provided (backwards compatibility)

given('a rule that does not require refs')
  when('review is invoked without --refs')
    then('the review completes successfully')
      sothat('prior review invocations continue to work')


# usecase.5 = invalid ref path

given('a ref path that does not exist')
  when('review is invoked with --refs set to a non-existent file')
    then('the review fails with a clear error message')
      sothat('users understand which ref path was invalid')


# usecase.6 = glob matches zero files

given('a glob pattern that matches no files')
  when('review is invoked with --refs set to that glob')
    then('the review fails with a clear error message')
      sothat('users understand no refs were found')


# usecase.7 = multiple --refs via repeated flags

given('multiple separate ref files needed')
given('some refs are explicit paths, others are globs')
  when('review is invoked with --refs specified multiple times')
    then('each --refs value is resolved independently')
      sothat('users can mix explicit paths and globs')
    then('all resolved refs are included in the review context')
    then('metrics.expected.files.refs reflects total count of resolved files')
      sothat('users see how many ref files were loaded')


# usecase.8 = repeated flags work for --rules and --paths too

given('multiple rule files needed')
given('multiple target paths needed')
  when('review is invoked with --rules and --paths each specified multiple times')
    then('all resolved rules are applied')
    then('all resolved paths are evaluated')
      sothat('the repeated-flag pattern is consistent across all file arguments')
