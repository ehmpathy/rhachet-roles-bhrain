# blackbox criteria: route.drive

## usecase.1 = clone receives gps reminder on session end

```
given(a route is bound to the current branch)
given(at least one stone remains unpassed)
  when(the clone session ends / onStop fires)
    then(route.drive echoes the current stone)
      sothat(the clone knows what they were focused on)
    then(route.drive shows the command to mark as passed)
      sothat(the clone knows how to signal completion)

given(a route is bound to the current branch)
given(all stones are passed)
  when(the clone session ends / onStop fires)
    then(route.drive indicates the route is complete)
      sothat(the clone knows there is no more work)

given(no route is bound)
  when(the clone session ends / onStop fires)
    then(route.drive is a no-op)
      sothat(clones without routes are not interrupted)
```

## usecase.2 = clone marks stone as passed with self-review

```
given(a stone has review.self guards defined)
given(no promises have been made yet)
  when(clone runs `rhx route.stone.set --stone $stone --as passed`)
    then(the system blocks passage)
    then(the system echoes the first review.self.guide)
    then(the system shows the promise command)
      sothat(clone must self-review before they claim done)

given(a stone has review.self guards defined)
given(clone has promised some but not all reviews)
  when(clone runs `rhx route.stone.set --stone $stone --as passed`)
    then(the system blocks passage)
    then(the system echoes the next unpromised review.self.guide)
    then(the system shows the promise command for that review)
      sothat(clone progresses through reviews one at a time)

given(a stone has review.self guards defined)
given(clone has promised all reviews)
  when(clone runs `rhx route.stone.set --stone $stone --as passed`)
    then(the system proceeds to peer reviews)
    then(the stone is marked as passed if peer reviews pass)
      sothat(self-review completes before peer-review)

given(a stone has no review.self guards)
  when(clone runs `rhx route.stone.set --stone $stone --as passed`)
    then(the system proceeds directly to peer reviews)
      sothat(stones without self-review work as before)
```

## usecase.3 = clone makes a promise

```
given(a review.self is awaited)
  when(clone runs `rhx route.stone.set --stone $stone --as promised --that $slug`)
    then(the promise is recorded in the guard artifacts directory)
    then(the system acknowledges the promise)
    then(the system instructs clone to call --as passed for next review)
      sothat(clone progresses through self-review checklist)

given(clone provides invalid slug)
  when(clone runs `rhx route.stone.set --stone $stone --as promised --that invalid-slug`)
    then(the system rejects the promise)
    then(the system echoes valid slug options)
      sothat(clone can correct their command)
```

## usecase.4 = promises invalidate on source change

```
given(clone has made promises for a stone)
given(the source artifacts have not changed)
  when(clone runs `rhx route.stone.set --stone $stone --as passed`)
    then(the prior promises are still valid)
      sothat(clone does not repeat work)

given(clone has made promises for a stone)
given(the source artifacts have changed since promises were made)
  when(clone runs `rhx route.stone.set --stone $stone --as passed`)
    then(the prior promises are invalidated)
    then(the system requires fresh promises)
      sothat(promises reflect the current state of work)
```

## usecase.5 = review.self configuration

```
given(a stone file with yaml frontmatter)
  when(guard.review.self is defined with slug and say)
    then(the slug identifies the review)
    then(the say content is echoed as the guide)
      sothat(humans can prescribe custom self-review prompts)

given(a stone file with yaml frontmatter)
  when(guard.review.self.say is an @path/to/brief.md link)
    then(the system resolves the path to its content)
    then(the resolved content is echoed as the guide)
      sothat(self-review prompts can be reused across stones)

given(a stone file with yaml frontmatter)
  when(guard.review.self.say is inline text)
    then(the inline text is echoed as the guide)
      sothat(simple prompts can be embedded directly)
```

## boundary conditions

- route.drive only fires if a route is bound
- review.self is optional; stones without it skip to peer review
- promises are tracked per-stone in the guard artifacts directory
- promise validity is tied to source artifact hashes
- multiple review.self entries are processed sequentially
- slug must match exactly for promise to be accepted
