# domain research: replic brain architectures

## sources catalog

| # | title | url | date | relevance |
|---|-------|-----|------|-----------|
| 1 | Claude Code: Behind-the-scenes of the master agent loop | https://blog.promptlayer.com/claude-code-behind-the-scenes-of-the-master-agent-loop/ | 2025 | core architecture |
| 2 | Claude Code: Best practices for agentic coding | https://www.anthropic.com/engineering/claude-code-best-practices | 2025 | official patterns |
| 3 | Building agents with the Claude Agent SDK | https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk | 2025 | SDK architecture |
| 4 | Piebald-AI/claude-code-system-prompts | https://github.com/Piebald-AI/claude-code-system-prompts | 2025 | system prompts |
| 5 | ReAct: Synergizing Reasoning and Acting in Language Models | https://arxiv.org/abs/2210.03629 | 2022 | foundational paper |
| 6 | Chain-of-Thought Prompting Elicits Reasoning in Large Language Models | https://arxiv.org/abs/2201.11903 | 2022 | reasoning patterns |
| 7 | Devin AI - Cognition Labs | https://cognition.ai/blog/introducing-devin | 2024 | alternative architecture |
| 8 | Aider - AI Pair Programming | https://aider.chat/ | 2024 | alternative architecture |
| 9 | Cursor Features | https://cursor.com/features | 2024 | alternative architecture |
| 10 | Introducing Codex | https://openai.com/index/introducing-codex/ | 2025 | alternative architecture |
| 11 | Agent Memory: How to Build Agents that Learn and Remember | https://www.letta.com/blog/agent-memory | 2024 | memory patterns |
| 12 | Context Engineering for Agents | https://blog.langchain.com/context-engineering-for-agents/ | 2025 | context management |
| 13 | Cutting Through the Noise: Smarter Context Management | https://blog.jetbrains.com/research/2025/12/efficient-context-management/ | 2025 | context research |
| 14 | Function Calling vs MCP vs A2A | https://zilliz.com/blog/function-calling-vs-mcp-vs-a2a-developers-guide-to-ai-agent-protocols | 2025 | tool protocols |
| 15 | ZenML: Claude Code Agent Architecture | https://www.zenml.io/llmops-database/claude-code-agent-architecture-single-threaded-master-loop-for-autonomous-coding | 2025 | architecture analysis |

---

## domain objects

### entities (identity + lifecycle)

#### RepicBrain
the autonomous agent system itself; the orchestrator of the agentic loop

> "At its core lies a deceptively simple architecture: a layered system built around a single-threaded master loop" [1]

- has: systemPrompt, tools[], contextWindow, config
- unique: sessionId
- lifecycle: initialized → running → terminated

#### Session
a single interaction session between user and agent

> "This design maintains a single main thread with one flat list of messages—no swarms, no multiple agent personas competing for control" [1]

- has: messages[], contextWindow, startedAt, endedAt
- unique: sessionId
- lifecycle: started → active → compacted → ended

#### Message
a single message in the conversation thread

> "The loop continues as long as the model's response includes tool usage; when Claude produces a plain text response without tool calls, the loop naturally terminates" [1]

- has: role, content, toolCalls[], toolResults[], timestamp
- role: user | assistant | system | tool
- unique: messageId within session

#### Tool
a capability the agent can invoke to interact with the environment

> "The key design principle behind Claude Code is that Claude needs the same tools that programmers use every day" [2]

- has: name, description, inputSchema, handler
- unique: toolName
- types: file operations, code execution, web search, MCP extensions

#### Subagent
a spawned child agent with isolated context

> "Subagents are useful for two main reasons: they enable parallelization... and they help manage context (subagents use their own isolated context windows)" [3]

- has: agentType, parentSession, ownContextWindow, task
- unique: subagentId
- types: Explore, Plan, Task [4]

#### ContextWindow
the working memory of the agent; what it can "see" at any moment

> "What an agent 'remembers' is fundamentally determined by what exists in its context window at any given moment. Think of the context window as the agent's working memory" [11]

- has: messages[], tokenCount, maxTokens, summaries[]
- unique: bound to session
- capacity: 128k-500k tokens typical [11]

---

### literals (immutable values)

#### SystemPrompt
the initial instructions that define agent behavior

> "Claude Code doesn't just have one single string for its system prompt. Large portions conditionally added depending on the environment and various configs" [4]

- has: basePrompt, conditionalSegments[], toolDescriptions[]
- immutable once session starts

#### ToolDefinition
the schema describing a tool's interface

> "Usually, there are three elements of a tool definition: Name, Description, and Parameters (a JSON schema)" [14]

- has: name, description, inputSchema (JSON schema)
- immutable per tool version

#### ToolCall
a request from the LLM to invoke a tool

> "The model does not actually execute any actions; it simply provides the arguments or parameters for a 'tool' or function" [14]

- has: toolName, arguments, callId
- generated by LLM

#### ToolResult
the response returned after tool execution

> "Anthropic returns all its content as a list of messages. Those message objects can have different types such as text, tool_use, tool_result" [14]

- has: callId, output, error?
- generated by tool handler

#### ReasoningTrace
chain-of-thought reasoning output

> "Generating a chain of thought—a series of intermediate reasoning steps—significantly improves the ability of large language models to perform complex reasoning" [6]

- has: steps[], conclusion
- interleaved with actions in ReAct pattern [5]

#### ContextSummary
compressed representation of older context

> "When the context window reaches capacity, intelligent eviction strategies determine what information to remove. This might involve summarizing and storing important details before removing them from active context" [13]

- has: content, originalTokenCount, compressedTokenCount, coveredMessageIds[]

---

### events (things that happen)

#### UserMessageReceived
user sends input to the agent

- has: content, timestamp, attachments[]

#### ToolInvocationRequested
LLM decides to call a tool

- has: toolCall, reasoningTrace?

#### ToolExecuted
tool handler completes execution

- has: toolCall, toolResult, durationMs

#### AgentResponseGenerated
LLM produces final text response (no tool calls)

- has: content, tokenCount

#### ContextCompactionTriggered
context window approaching capacity

- has: currentTokenCount, threshold, strategy

#### SubagentSpawned
new subagent created for parallel/isolated work

- has: subagentType, task, parentSessionId

#### SessionTerminated
agent loop ends

- has: reason (user_ended | task_complete | error | timeout)

---

## domain operations

### core loop operations

#### processMessage
the main agentic loop; the heart of the replic brain

> "The core pattern is beautifully minimal: while(tool_call) → execute tool → feed results → repeat" [1]

```
input: { message: Message, session: Session }
output: { response: Message, session: Session }

pseudocode:
  1. append message to session.contextWindow
  2. while true:
       response = llm.generate(session.contextWindow)
       if response.hasToolCalls:
         for each toolCall in response.toolCalls:
           result = executeTool(toolCall)
           append result to contextWindow
       else:
         return response  // loop terminates
```

#### selectTool
LLM decides which tool to use based on context

> "Tools are the primary building blocks of execution for your agent. Tools are prominent in Claude's context window, making them the primary actions Claude will consider" [3]

```
input: { context: ContextWindow, tools: Tool[] }
output: { toolCall: ToolCall | null, reasoning: ReasoningTrace }
```

#### executeTool
run tool handler and capture result

```
input: { toolCall: ToolCall, tool: Tool }
output: { toolResult: ToolResult }
```

### context management operations

#### compactContext
summarize and evict older messages when approaching capacity

> "The Claude Agent SDK's compact feature automatically summarizes previous messages when the context limit approaches" [3]

```
input: { contextWindow: ContextWindow, threshold: number }
output: { contextWindow: ContextWindow, summary: ContextSummary }

pseudocode:
  1. if tokenCount < threshold: return unchanged
  2. select messages to evict (oldest, keeping recent)
  3. summarize evicted messages via LLM
  4. replace evicted messages with summary
  5. return compacted contextWindow
```

#### injectUserInterjection
handle mid-task user input without full restart

> "The h2A async dual-buffer queue... ability to incorporate user interjections mid-task without requiring a full restart" [1]

```
input: { interjection: Message, session: Session }
output: { session: Session }
```

### subagent operations

#### spawnSubagent
create isolated child agent for parallel work

```
input: { agentType: 'Explore' | 'Plan' | 'Task', task: string, parentSession: Session }
output: { subagent: Subagent }
```

#### collectSubagentResult
retrieve result from completed subagent

```
input: { subagent: Subagent }
output: { result: Message, relevantContext: ContextSummary }
```

---

## relationships

### treestruct of composition

```
RepicBrain
├── SystemPrompt
│   ├── basePrompt
│   ├── conditionalSegments[]
│   └── toolDescriptions[]
├── Tools[]
│   └── ToolDefinition
├── Session
│   ├── ContextWindow
│   │   ├── Messages[]
│   │   │   ├── ToolCalls[]
│   │   │   └── ToolResults[]
│   │   └── ContextSummaries[]
│   └── Subagents[]
│       └── (recursive Session)
└── Config
```

### treestruct of the agentic loop (temporal flow)

```
UserMessageReceived
    ↓
processMessage
    ↓
┌───────────────────────────────────┐
│ while (hasToolCalls):             │
│   ├── selectTool                  │
│   │   └── ReasoningTrace          │
│   ├── ToolInvocationRequested     │
│   ├── executeTool                 │
│   │   └── ToolExecuted            │
│   └── append ToolResult           │
│                                   │
│   if (contextNearCapacity):       │
│   └── compactContext              │
│       └── ContextCompactionTriggered │
└───────────────────────────────────┘
    ↓
AgentResponseGenerated
    ↓
(await next UserMessageReceived or SessionTerminated)
```

### dependencies between domain objects

| object | depends on |
|--------|------------|
| RepicBrain | SystemPrompt, Tools[], Session |
| Session | ContextWindow, Messages[] |
| Message | ToolCalls[]?, ToolResults[]? |
| ToolCall | ToolDefinition |
| ToolResult | ToolCall |
| ContextSummary | Messages[] (the ones being summarized) |
| Subagent | Session (parent), Task |
| ReasoningTrace | ContextWindow (input to reasoning) |

### cross-architecture comparison

| concept | claude-code | devin | aider | cursor | codex |
|---------|-------------|-------|-------|--------|-------|
| loop type | single-threaded master [1] | planner + executor [7] | single-threaded [8] | multi-agent parallel [9] | cloud sandbox [10] |
| context mgmt | auto-compaction [3] | unknown | repo map [8] | rules + memories [9] | full context [10] |
| tool interface | native + MCP [4] | browser + shell + editor [7] | git + linter [8] | semantic search + editor [9] | tests + iteration [10] |
| subagents | Explore, Plan, Task [4] | multi-agent dispatch [7] | none | 8 parallel agents [9] | parallel tasks [10] |
| git integration | manual via tools | auto commits | auto commits per edit [8] | worktrees [9] | PR proposals [10] |

---

## how domain objects compose to support the wish

the wish requires understanding how replic brains work. the domain model above reveals:

1. **the core loop** = the `processMessage` operation is the atomic unit of behavior
   - all replic brains share this: receive → reason → act → observe → repeat

2. **the tool interface** = the bridge between LLM and environment
   - `ToolDefinition` + `ToolCall` + `ToolResult` form the contract
   - MCP standardizes this across implementations [14]

3. **the context window** = the working memory constraint that shapes all design
   - compaction, summarization, and subagent isolation all exist to manage this limit
   - "context engineering" is the new prompt engineering [12]

4. **the reasoning trace** = the chain-of-thought that makes agents reliable
   - ReAct pattern interleaves reasoning + action [5]
   - enables debugging, steering, and verification

5. **the subagent pattern** = parallelism and context isolation
   - claude-code uses typed subagents (Explore, Plan, Task)
   - cursor uses up to 8 parallel agents
   - enables scaling beyond single-context limits

the blueprints will document how each implementation instantiates these domain objects and operations.
