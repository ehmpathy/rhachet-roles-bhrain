wish =

wish =

we've got thought routes distilled in a usable way via the skills of `route.stone.get|set|del` and `route.bind`

the last step for clones to be able to use them in order to drive themselves is to `route.drive`

specifically

- if a route is bound 

then

- a hook should be declared (see how hooks are registered on the gen Role interface)
- which will drive the next stone 

i.e., 

- onStop
	- first, self-review: "did you finish the goal?" 
		- this is similar to the "ralph wiggum loop" concept; 
			- we only want to attempt to "set" the stone as passed if the clone promises that they believe they truely fulfilled it;
			- its all too common that when you ask "did you do everything?" or "is there anything left?" or "are there omissions?" that the self-check prompt will get the agent to realize tehy are nto yet done
			- just like proposed in the "ralph wiggum loop", we want the agent to "promise" that tehy've self checked and to the best of their ability they see no omissions or defects 
		- contractually, we want to update the stone.guard to support two types of reviews
			- review.self (netnew)
			- review.peer (extant)
			- where the review.self is a record that contains two parts
				- 1. = slug 
				- 2. = say 
					can just be either!
					- a plaintext prompt string embedded in the yaml
					- or
					- an @path/to/brief.md formatted link, which we resolve to the text
			- upon detection of review.self registered
				- then, we should echo that prompt, one at a time, back, whenever `set` is called
				- and tell them they must call the `set` command with `--i-promise $slug` 

			- for example
				- `rhx route.stone.set --stone $stone --i-promise all-done` (where all-done is the slug of the review.self entry w/ content "did you do everything requested in the stone?")
				- `rhx route.stone.set --stone $stone --i-promise all-paths-have-test-coverage` 
				- `rhx route.stone.set --stone $stone --i-promise all-tests-pass-even-priors` 
				- `rhx route.stone.set --stone $stone --i-promise zero-dead-code` 
				- `rhx route.stone.set --stone $stone --i-promise zero-unprescribed-backwards-compat` 

where the expectation is, 

onStop, the hook will automatically try to fire `rhx route.drive` 

`route.drive` will fire `route.stone.get --stone @next-one`, echo its outputs, and then say "if you have completed this, call `rhx route.stone.set --stone $stone --as passed`

and `route.stone.set --stone $stone --as passed` will go through its review process

and if it sees `review.self`, it will kickoff the self-review via echo of that review.self.say for the first review that is not already marked as 'promised'

and then it will say 'if you promise this has been done, call `rhx route.stone.set --stone $stone --as promised --that $slug` (lets use the `--as promised --that $review.self.slug` pattern instead)

upon setting that, the route should respond with `great! thank you for your effort - we count on you and its critical that we always critically and thoroughly self review the work. now, call 'rhx route.stone.set --stone $stone --as passed' for the next review` 


that way, the progression becomes

onStop -> rhx route.drive reminds the clone
	1. what they were working on (the current stone)
	2. what they should do if they think they're done (rhx route.stone.set --as passed)

onCall(rhx route.stone.set --as passed) -> route.stone.set triggers the self review && tracks the state of their promises
	- promises are kept in the same dir of artifacts that track the other guard outputs 
	- this enables route.stone.set to figure out which review.self the clone has promised they completed and which they have still not, to support mulitple self-reviews in a row
	- this also enables route.stone.set to figure out which promises are still relevant; if the source artifacts that the guard guards have changed in hash, then the old promises are no longer valid (just like with the reviews)


that same `set --as passed` flow also triggers the normal guards which already inform the clone what to do next, too

in this way, the onStop(rhx route.drive) hook becomes a gps for the clone; it tells them whats next, keeps their milestone top of mind, and lets them know what to do when they think they've reached it 


---

leverage this prior behavior (originally started in the wrong repo) to help guide the though

the vision should be pretty close!

behavior/v2026_02_20.route-drive/priors/v2026_02_20.route-drive
