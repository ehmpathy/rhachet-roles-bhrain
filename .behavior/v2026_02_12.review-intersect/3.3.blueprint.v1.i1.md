# blueprint: review --join intersect fix

## summary

fix the `--join intersect` mode and make it the default. the bug is in early return logic that bypasses intersect semantics when one source is empty.

## filediffs treestruct

```
src/
├── contract/cli/
│   └── [~] review.ts                           # change default: 'union' → 'intersect', update help text
└── domain.operations/review/
    └── [~] stepReview.ts                       # fix early returns to respect join mode

blackbox/
├── [+] review.join-intersect.acceptance.test.ts  # new: acceptance tests for intersect mode
└── .test/
    └── [○] invokeReviewSkill.ts                # retain: already supports --join param
```

## codepaths treestruct

```
review.ts::parseArgs
├── [~] join default                            # 'union' → 'intersect'
└── [○] join parse logic                        # retain

review.ts::printHelp
└── [~] help text                               # update default in docs: "(default: intersect)"

stepReview.ts::stepReview
├── [○] enumerate files from diffs              # retain
├── [○] enumerate files from paths              # retain
└── [~] join target files logic                 # fix early returns to respect join mode
    ├── [~] early return: diffs empty           # respect join mode
    ├── [~] early return: paths empty           # respect join mode
    ├── [○] intersect logic                     # retain (already correct)
    └── [○] union logic                         # retain (already correct)
```

## implementation details

### 1. fix stepReview.ts join logic (lines 228-240)

**before (broken):**
```ts
const joinMode = input.join ?? 'union';
const targetFilesJoined = (() => {
  // early returns bypass join mode!
  if (targetFilesFromDiffs.length === 0) return targetFilesFromPaths;
  if (targetFilesFromPaths.length === 0) return targetFilesFromDiffs;

  if (joinMode === 'intersect') {
    const pathsSet = new Set(targetFilesFromPaths);
    return targetFilesFromDiffs.filter((file) => pathsSet.has(file));
  }
  return [...new Set([...targetFilesFromDiffs, ...targetFilesFromPaths])];
})();
```

**after (fixed):**
```ts
const joinMode = input.join ?? 'intersect';
const targetFilesJoined = (() => {
  // handle single-source cases (join mode doesn't apply)
  const hasDiffs = targetFilesFromDiffs.length > 0;
  const hasPaths = targetFilesFromPaths.length > 0;

  if (!hasDiffs && !hasPaths) return [];
  if (!hasDiffs && !input.diffs) return targetFilesFromPaths;  // diffs not requested
  if (!hasPaths && !input.paths) return targetFilesFromDiffs;  // paths not requested

  // both sources requested; apply join mode
  if (joinMode === 'intersect') {
    const pathsSet = new Set(targetFilesFromPaths);
    return targetFilesFromDiffs.filter((file) => pathsSet.has(file));
  }
  return [...new Set([...targetFilesFromDiffs, ...targetFilesFromPaths])];
})();
```

**key insight:** the early returns should only apply when ONE source was NOT requested (no `--diffs` or no `--paths`). when BOTH are requested, the join mode determines the result — even if one source resolves to zero files.

### 2. change default in review.ts::parseArgs (line 124)

```ts
// before
join: (options.join as 'union' | 'intersect') ?? 'union',

// after
join: (options.join as 'union' | 'intersect') ?? 'intersect',
```

### 3. update help text in review.ts::printHelp (line 39)

```ts
// before
--join <mode>       how to join --paths and --diffs: union or intersect (default: union)

// after
--join <mode>       how to join --paths and --diffs: intersect or union (default: intersect)
```

## acceptance tests

### new file: `blackbox/review.join-intersect.acceptance.test.ts`

```ts
describe('review.acceptance', () => {
  given('[case1] intersect mode with both sources', () => {
    // setup: create temp dir with files, commit some, modify subset
    // invoke: --diffs since-main --paths "src/*.ts" --join intersect
    // assert: only files that are BOTH changed AND match glob are reviewed
  });

  given('[case2] intersect mode with empty diffs', () => {
    // setup: temp dir on main branch (no changes)
    // invoke: --diffs since-main --paths "src/*.ts" --join intersect
    // assert: error "combined scope resolves to zero files"
  });

  given('[case3] union mode with empty diffs', () => {
    // setup: temp dir on main branch (no changes)
    // invoke: --diffs since-main --paths "src/*.ts" --join union
    // assert: reviews all src/*.ts files (union behavior)
  });

  given('[case4] default mode is intersect', () => {
    // setup: temp dir with changes
    // invoke: --diffs since-main --paths "src/*.ts" (no --join)
    // assert: behaves like intersect (the new default)
  });
});
```

## test matrix

| scenario | diffs | paths | join | expected result |
|----------|-------|-------|------|-----------------|
| both sources, overlap exists | [a,b] | [b,c] | intersect | [b] |
| both sources, no overlap | [a] | [b] | intersect | [] → error |
| diffs empty, paths non-empty | [] | [a,b] | intersect | [] → error |
| diffs non-empty, paths empty | [a,b] | [] | intersect | [] → error |
| both sources, overlap exists | [a,b] | [b,c] | union | [a,b,c] |
| diffs empty, paths non-empty | [] | [a,b] | union | [a,b] |
| only --paths (no --diffs) | n/a | [a,b] | any | [a,b] |
| only --diffs (no --paths) | [a,b] | n/a | any | [a,b] |

## validation

- [ ] unit tests pass: `npm run test:unit`
- [ ] integration tests pass: `npm run test:integration`
- [ ] acceptance tests pass: `npm run test:acceptance:locally`
- [ ] help text shows correct default
- [ ] intersect mode works when both sources have files
- [ ] intersect mode returns empty when one source is empty (and both requested)
- [ ] union mode works as before (explicit opt-in)
