# blackbox criteria = experience bounds

these are the constraints on what users must experience when they use the rhachet actor sdk powered skills

---

# usecase.1 = review skill with brain choice

given('a user wants to run a code review')
  when('they invoke review without --brain flag')
    then('the review uses xai code-fast-1 by default')
      sothat('users get max speed and min cost out of the box')
    then('the review output contains blockers and nitpicks as before')
    then('the metrics show token usage and cost')

  when('they invoke review with --brain anthropic/claude/sonnet')
    then('the review uses claude-sonnet for the review')
      sothat('users can opt for higher quality when needed')
    then('the review output format remains identical')
    then('the metrics reflect anthropic price rates')

  when('they invoke review with --brain openai/gpt/4o')
    then('the review uses gpt-4o for the review')
    then('the review output format remains identical')
    then('the metrics reflect openai price rates')

  when('they invoke review with --brain xai/grok/3')
    then('the review uses grok-3 for the review')
    then('the review output format remains identical')

given('a user provides an invalid brain')
  when('they invoke review with --brain invalid/model')
    then('the skill fails with clear error message')
      sothat('users know which brains are available')
    then('the error lists available brain providers')
    then('the error lists available models per provider')

---

# usecase.2 = reflect skill with brain choice

given('a user wants to extract rules from feedback')
  when('they invoke reflect without --brain flag')
    then('the reflect uses xai code-fast-1 by default')
      sothat('users get max speed and min cost out of the box')
    then('pure rules are written to draft/pure/')
    then('sync rules are written to draft/sync/')
    then('manifest.json tracks all operations')

  when('they invoke reflect with --brain anthropic/claude/sonnet')
    then('the reflect uses claude-sonnet for rule extraction')
      sothat('users can opt for higher quality extraction')
    then('output structure remains identical')
    then('metrics reflect anthropic price rates')

  when('they invoke reflect with --brain openai/gpt/4o')
    then('the reflect uses gpt-4o for rule extraction')
    then('output structure remains identical')

given('a user provides an invalid brain')
  when('they invoke reflect with --brain unknown/model')
    then('the skill fails with clear error message')
    then('the error lists available brain providers')

---

# usecase.3 = brain discovery and validation

given('a user wants to know available brains')
  when('they invoke a skill with --brain help')
    then('the skill lists all available brain providers')
      sothat('users can discover what options exist')
    then('each provider shows its available models')
    then('each model shows its cost tier (fast/balanced/quality)')

given('a user environment lacks required api keys')
  when('they invoke a skill with --brain anthropic/claude/sonnet')
    then('the skill fails with clear error about absent ANTHROPIC_API_KEY')
      sothat('users know exactly what to configure')

  when('they invoke a skill with --brain openai/gpt/4o')
    then('the skill fails with clear error about absent OPENAI_API_KEY')

  when('they invoke a skill with --brain xai/grok/code-fast-1')
    then('the skill fails with clear error about absent XAI_API_KEY')

---

# usecase.4 = programmatic brain choice via context

given('a developer who builds a custom skill')
  when('they access context.brain.choice')
    then('they receive the resolved brain atom or repl')
      sothat('skills can use the brain without need to know which provider')
    then('context.brain.choice.ask() returns a response')
    then('context.brain.choice.act() executes with tools')

  when('they access context.brain without a call to genContextBrainChoice')
    then('context.brain.choice is undefined')
      sothat('skills must explicitly opt into brain choice')

given('a developer wants to use multiple brains in one skill')
  when('they call genContextBrainChoice with different brain refs')
    then('each call returns a fresh context with the specified brain')
      sothat('skills can orchestrate multiple brains in sequence')

---

# usecase.5 = backward compatibility

given('a user with prior skill invocations')
  when('they invoke review without any new flags')
    then('the skill works exactly as before')
      sothat('prior workflows are not broken')
    then('output format is identical')
    then('log structure is identical')

  when('they invoke reflect without any new flags')
    then('the skill works exactly as before')
    then('output format is identical')

given('prior tests against review and reflect')
  when('tests run after brain choice is added')
    then('all prior tests continue to pass')
      sothat('no regressions are introduced')

---

# boundary.1 = supported brain providers

these brain providers must be loadable:
- xai (via rhachet-brain-xai)
- anthropic (via rhachet-brain-anthropic)
- openai (via rhachet-brain-openai)

---

# boundary.2 = brain reference format

brain references must follow the format: `{provider}/{family}/{model}`
- `xai/grok/code-fast-1` = xai fast model (default)
- `xai/grok/3` = xai quality model
- `anthropic/claude/sonnet` = anthropic balanced model
- `anthropic/claude/haiku` = anthropic fast model
- `openai/gpt/4o` = openai balanced model
- `openai/gpt/4o-mini` = openai fast model

---

# boundary.3 = default brain

when no --brain flag is provided:
- default = `xai/grok/code-fast-1`
- rationale = max speed, min cost for iteration

---

# boundary.4 = error messages

error messages must include:
- what went wrong (e.g., "brain not found")
- what was expected (e.g., "valid brain reference")
- what options exist (e.g., "available brains: xai/grok/code-fast-1, ...")
- what to do next (e.g., "set XAI_API_KEY environment variable")

---

# boundary.5 = metrics consistency

regardless of brain choice:
- metrics.expected must show token estimate and cost estimate
- metrics.realized must show actual tokens and actual cost
- cost calculations must use correct price rates per provider
