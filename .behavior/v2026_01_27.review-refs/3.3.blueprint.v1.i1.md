# blueprint: --refs for review skill

## overview

implement support for `--refs` argument in the review skill, to enable rules to reference external documents in review.

---

## filediff treestruct

```
legend: [+] create, [~] update, [-] delete

src/
â”œâ”€ contract/
â”‚  â””â”€ cli/
â”‚     â””â”€ [~] review.ts                    # add refs to schema + pass to stepReview
â”œâ”€ infra/
â”‚  â””â”€ cli/
â”‚     â””â”€ [~] getCliArgs.ts                # support repeated flags (accumulate arrays)
â”œâ”€ domain.operations/
â”‚  â””â”€ review/
â”‚     â”œâ”€ [~] stepReview.ts                # add ref enumeration + metrics display
â”‚     â”œâ”€ [~] compileReviewPrompt.ts       # add refs input + <refs> section in prompt
â”‚     â””â”€ [+] compileReviewPrompt.test.ts  # unit tests for refs in prompt

blackbox/
â”œâ”€ .test/
â”‚  â”œâ”€ assets/
â”‚  â”‚  â””â”€ codebase-mechanic/
â”‚  â”‚     â””â”€ behavior/
â”‚  â”‚        â””â”€ getWeather/
â”‚  â”‚           â”œâ”€ [+] criteria.blackbox.md  # ref fixture: behavior criteria
â”‚  â”‚           â””â”€ [+] criteria.blueprint.md # second ref for glob tests
â”‚  â””â”€ [~] invokeReviewSkill.ts              # add refs parameter
â”œâ”€ [+] review.refs-single.acceptance.test.ts     # usecase.1: single ref
â”œâ”€ [+] review.refs-glob.acceptance.test.ts       # usecase.2: glob refs
â””â”€ [+] review.refs-error.acceptance.test.ts      # usecase.5,6: error cases
```

---

## codepath treestruct

```
cli invocation
â””â”€ src/contract/cli/review.ts
   â”œâ”€ parse args via getCliArgs()
   â”‚  â””â”€ src/infra/cli/getCliArgs.ts
   â”‚     â””â”€ [EXTEND] accumulate repeated flags into arrays
   â”œâ”€ validate schema (refs?: string | string[])
   â””â”€ call stepReview({ ..., refs })
      â””â”€ src/domain.operations/review/stepReview.ts
         â”œâ”€ enumerate ref files via enumFilesFromGlob() [REUSE]
         â”œâ”€ validate refs exist (fail-fast on zero matches)
         â”œâ”€ display metrics.expected.files.refs
         â”œâ”€ read ref file contents
         â”œâ”€ call compileReviewPrompt({ ..., refs })
         â”‚  â””â”€ src/domain.operations/review/compileReviewPrompt.ts
         â”‚     â”œâ”€ [EXTEND] accept refs array in input
         â”‚     â”œâ”€ [EXTEND] build <refs> section
         â”‚     â””â”€ [EXTEND] inject into prompt template
         â”œâ”€ invoke brain
         â”œâ”€ format output
         â””â”€ display summary (blockers/nitpicks)
```

---

## contracts

### cli schema extension

```typescript
// src/contract/cli/review.ts
const schemaOfArgs = z.object({
  named: z.object({
    rules: z.union([z.string(), z.array(z.string())]).optional(),
    diffs: z.string().optional(),
    paths: z.union([z.string(), z.array(z.string())]).optional(),
    refs: z.union([z.string(), z.array(z.string())]).optional(),  // [+] NEW
    output: z.string().optional(),
    mode: z.enum(['pull', 'push']).optional(),
    goal: z.enum(['exhaustive', 'representative']),
    brain: z.string().optional(),
    rapid: z.string().optional(),
    // rhachet passthrough args
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});
```

### stepReview input extension

```typescript
// src/domain.operations/review/stepReview.ts
export const stepReview = async (input: {
  rules: string | string[];
  diffs?: 'uptil-main' | 'uptil-commit' | 'uptil-staged';
  paths?: string | string[];
  refs?: string | string[];  // [+] NEW
  output: string;
  focus: 'pull' | 'push';
  goal: 'exhaustive' | 'representative';
  brain?: string;
}): Promise<StepReviewResult> => { ... }
```

### compileReviewPrompt input extension

```typescript
// src/domain.operations/review/compileReviewPrompt.ts
export const compileReviewPrompt = (input: {
  rules: Array<{ path: string; content: string }>;
  refs: Array<{ path: string; content: string }>;  // [+] NEW (empty array when no refs)
  targets: Array<{ path: string; content: string }>;
  focus: 'pull' | 'push';
  goal: 'exhaustive' | 'representative';
  contextWindow: number;
}): {
  prompt: string;
  tokenEstimate: number;
  contextWindowPercent: number;
  costEstimate: number;
}
```

---

## domain decomposition

### domain.operations to extend

| operation           | change               | reason                                 |
| ------------------- | -------------------- | -------------------------------------- |
| stepReview          | add refs enumeration | enumerate and validate ref files       |
| stepReview          | add refs metrics     | display refs count in metrics.expected |
| stepReview          | add refs read        | read ref file contents for prompt      |
| compileReviewPrompt | add refs input       | accept refs array                      |
| compileReviewPrompt | add refs section     | build `<refs>` section in prompt       |

### infra to extend

| module     | change                    | reason                              |
| ---------- | ------------------------- | ----------------------------------- |
| getCliArgs | accumulate repeated flags | support `--refs x --refs y` pattern |

---

## prompt template extension

```typescript
// src/domain.operations/review/compileReviewPrompt.ts

const prompt = `# review task

you are a reviewer. apply the rules below to the target files.

## CRITICAL INSTRUCTIONS â€” READ CAREFULLY

1. ONLY review content in the <target> section
2. NEVER flag content from the <rules> section â€” rules contain examples of bad patterns for illustration only
3. if you see "bad: X" or "good: Y" in a rule, those are examples to learn from, NOT content to flag
4. the "locations" array must ONLY contain paths from <target>, never from <rules>
5. if you cannot find the violation in <target>, do not report it
6. <refs> section contains reference documents for context â€” use them to inform your review but do not flag content from refs

${goalInstructions}

## rules (FOR REFERENCE ONLY â€” DO NOT FLAG CONTENT FROM THIS SECTION)

<rules>
${rulesSection}
</rules>

${refsSection ? `## refs (REFERENCE DOCUMENTS â€” USE FOR CONTEXT, DO NOT FLAG)

<refs>
${refsSection}
</refs>

` : ''}## target (REVIEW THIS SECTION ONLY)

<target>
${targetSection}
</target>`;
```

---

## metrics display extension

```
ðŸ”­ metrics.expected
   â”œâ”€ files
   â”‚  â”œâ”€ rules: ${ruleFiles.length}
   â”‚  â”œâ”€ refs: ${refFiles.length}           // [+] NEW (only if refs provided)
   â”‚  â””â”€ targets: ${targetFiles.length}
   â”œâ”€ tokens
   â”‚  â”œâ”€ estimate: ${promptResult.tokenEstimate}
   â”‚  â””â”€ context: ${promptResult.contextWindowPercent.toFixed(1)}%
   â””â”€ cost
      â””â”€ estimate: $${promptResult.costEstimate.toFixed(4)}
```

---

## error handle

### usecase.5: invalid ref path

```typescript
// in stepReview.ts, after ref enumeration
if (refFiles.length === 0 && input.refs) {
  const refGlobs = Array.isArray(input.refs) ? input.refs : [input.refs];

  // check if any glob looks like an explicit path (no wildcards)
  const explicitPaths = refGlobs.filter(g => !g.includes('*'));
  if (explicitPaths.length > 0) {
    // suggest similar files
    const suggestions = await findSimilarFiles({
      path: explicitPaths[0],
      cwd
    });
    throw new BadRequestError(
      `ref not found: ${explicitPaths[0]}` +
      (suggestions.length > 0
        ? `\n\ndid you mean?\n${suggestions.map(s => `  â€¢ ${s}`).join('\n')}`
        : ''),
      { path: explicitPaths[0], suggestions }
    );
  }

  // glob matched zero files
  throw new BadRequestError(
    `no refs matched glob: ${refGlobs.join(', ')}\n\nhint: verify the path exists and contains matched files`,
    { globs: refGlobs }
  );
}
```

---

## test coverage

### unit tests

| file                        | coverage                                            |
| --------------------------- | --------------------------------------------------- |
| compileReviewPrompt.test.ts | refs section generation, token estimation with refs |

### integration tests

| file                           | coverage                               |
| ------------------------------ | -------------------------------------- |
| stepReview.integration.test.ts | ref enumeration, ref content in prompt |

### acceptance tests

| file                                           | usecases covered                         |
| ---------------------------------------------- | ---------------------------------------- |
| review.refs-single.acceptance.test.ts          | usecase.1, usecase.3                     |
| review.refs-glob.acceptance.test.ts            | usecase.2, usecase.7                     |
| review.refs-error.acceptance.test.ts           | usecase.5, usecase.6                     |
| review.representative-clean.acceptance.test.ts | usecase.4 (prior test, no change needed) |

### test fixtures to add

```
blackbox/.test/assets/codebase-mechanic/behavior/getWeather/
â”œâ”€ criteria.blackbox.md   # behavior criteria doc for ref test
â””â”€ criteria.blueprint.md  # second ref for glob pattern test (behavior/getWeather/*.md)
```

---

## implementation order

1. **phase.0: infra** â€” extend getCliArgs to accumulate repeated flags
2. **phase.1: contract** â€” extend cli schema with refs field
3. **phase.2: prompt** â€” extend compileReviewPrompt with refs section
4. **phase.3: stepReview** â€” add ref enumeration, validation, metrics
5. **phase.4: tests** â€” add test fixtures and acceptance tests
6. **phase.5: validation** â€” run full test suite, verify all usecases

---

## backwards compatibility

- refs is optional in all contracts
- when refs is undefined/empty, behavior is identical to prior version
- usecase.4 validates this via prior acceptance tests (no modification needed)

