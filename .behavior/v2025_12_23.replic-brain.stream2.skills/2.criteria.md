# behavioral criteria: bhrain.struct.v1

---

## usecase.1 = basic invocation

```
given('a valid bhrain.struct.v1 configuration')
  given('an llm atom is specified (e.g., claude, qwen)')
    when('invoked with a simple input requiring no tools')
      then('the brain produces a text response')
        sothat('users receive answers to simple questions')
      then('the response is coherent and addresses the input')
      then('no tool calls are made')
        sothat('simple queries complete quickly')

    when('invoked with an input requiring tool use')
      then('the brain identifies which tools are needed')
      then('the brain generates valid tool calls')
      then('the brain waits for tool results before continuing')
        sothat('reasoning is grounded in real observations')
```

---

## usecase.2 = agentic loop execution

```
given('a bhrain with tools available (files, bash, websearch)')
  when('the input requires multi-step reasoning')
    then('the brain enters an agentic loop')
    then('each iteration: generates response → checks for tool calls → executes tools → appends results')
      sothat('complex tasks are decomposed into steps')
    then('the loop continues until no tool calls are generated')
      sothat('the brain decides when the task is complete')
    then('the final response is returned to the caller')

  when('the brain generates multiple tool calls in one response')
    then('all tool calls are executed')
    then('all results are appended to context')
      sothat('parallel tool execution is supported')

  when('the loop exceeds max iterations')
    then('the loop terminates gracefully')
    then('the brain returns a partial response with explanation')
      sothat('infinite loops are prevented')
```

---

## usecase.3 = tool execution (files)

```
given('the files tool is available')
  when('the brain calls read with a valid file path')
    then('the file contents are returned')
    then('the result is appended to context')

  when('the brain calls read with a non-existent file')
    then('an error result is returned')
    then('the brain can reason about the error and recover')
      sothat('missing files dont crash the loop')

  when('the brain calls write with content')
    then('the file is written to disk')
    then('a success result is returned')

  when('the brain calls edit with old_string and new_string')
    then('the replacement is performed')
    then('the updated content is confirmed in result')

  when('the brain calls glob with a pattern')
    then('matching file paths are returned')
      sothat('the brain can discover files')

  when('the brain calls grep with a pattern')
    then('matching lines and file paths are returned')
      sothat('the brain can search code')
```

---

## usecase.4 = tool execution (bash)

```
given('the bash tool is available')
  when('the brain calls bash with a valid command')
    then('the command is executed in a shell')
    then('stdout and stderr are captured')
    then('the exit code is returned')
    then('the result is appended to context')

  when('the brain calls bash with a command that fails')
    then('the error output is returned')
    then('the non-zero exit code is returned')
    then('the brain can reason about the failure and recover')
      sothat('command failures dont crash the loop')

  when('the brain calls bash with a long-running command')
    then('a timeout is enforced')
    then('the command is killed if it exceeds the timeout')
    then('a timeout error is returned')
      sothat('runaway processes are prevented')

  when('the brain calls bash with a command producing large output')
    then('output is truncated at a configurable limit')
    then('a truncation notice is included')
      sothat('large outputs dont exhaust context')

  when('the brain attempts a blocked command')
    then('the permission guard is consulted')
    then('execution is denied if not permitted')
      sothat('dangerous commands require explicit approval')
```

---

## usecase.5 = tool execution (websearch)

```
given('the websearch tool is available')
  when('the brain calls websearch with a query')
    then('search results are returned')
    then('results include titles, urls, and snippets')
      sothat('the brain can reason about web content')

  when('the search returns no results')
    then('an empty result set is returned')
    then('the brain can adjust its approach')

  when('the search fails (network error)')
    then('an error result is returned')
    then('the brain can retry or proceed without')
```

---

## usecase.6 = permission management

```
given('a bhrain with a permission configuration')
  when('the brain attempts a pre-approved operation')
    then('the operation executes without prompting')
      sothat('approved workflows are not interrupted')

  when('the brain attempts an operation requiring approval')
    then('the operation is paused')
    then('the user is prompted for approval')
    then('the operation proceeds only if approved')
      sothat('risky operations require consent')

  when('the brain attempts a blocked operation')
    then('the operation is rejected')
    then('the brain receives a rejection result')
    then('the brain can reason about the rejection and adjust')
      sothat('dangerous operations are prevented')

  when('the user denies an approval request')
    then('the operation is not executed')
    then('a denial result is returned to the brain')
    then('the brain can proceed with an alternative approach')
```

---

## usecase.7 = plugin: toolbox configuration

```
given('bhrain.struct.v1 supports pluggable toolboxes')
  when('multiple toolboxes are provided')
    then('tools from all toolboxes are merged')
    then('the system prompt reflects the combined tool set')
      sothat('capabilities can be composed from multiple sources')

  when('a single toolbox is provided')
    then('only the tools in that toolbox are available')

  when('no toolboxes are provided')
    then('a default toolbox is used')
      sothat('basic functionality works out of the box')

  when('toolboxes have conflicting tool names')
    then('an error is raised at configuration time')
      sothat('ambiguity is prevented')

  when('a toolbox is added at runtime')
    then('its tools become available to the brain')
    then('tool definitions are injected into context')
    then('tool execution is routed to the toolbox')
      sothat('tools are extensible without modifying core')

  when('a toolbox is removed at runtime')
    then('its tools are no longer available')
    then('calls to those tools return "tool not found" errors')
```

---

## usecase.8 = plugin: memory manager configuration

```
given('bhrain.struct.v1 supports pluggable memory managers')
  when('a custom memory manager is provided')
    then('that manager controls context window optimization')
      sothat('different use cases can optimize differently')

  when('no memory manager is provided')
    then('a default summarization-on-limit manager is used')
      sothat('basic memory management works out of the box')

given('the memory manager plugin interface')
  when('the agentic loop completes an iteration')
    then('the memory manager plugin is consulted')
    then('the plugin decides whether to update context')
    then('if updating, the plugin provides the new context')
    then('the core applies the replacement before next iteration')
      sothat('memory management is fully delegated to the plugin')

  when('the plugin decides not to update')
    then('context is unchanged')
    then('the loop continues normally')
      sothat('the plugin controls timing of updates')

  when('the plugin externalizes knowledge')
    then('detailed content can be stored externally')
    then('references/summaries replace the content in context')
    then('the brain can retrieve externalized content via tools')
      sothat('advanced memory patterns are possible')

  when('the plugin is configured for background operation')
    then('the plugin can observe context asynchronously')
    then('the plugin can signal updates between iterations')
      sothat('continuous optimization is possible')

given('memory manager strategies are plugins')
  when('no strategy plugin is provided')
    then('"summarize-on-limit" is used as default')
      sothat('basic memory management works out of the box')

  when('a custom strategy plugin is provided')
    then('that plugin controls memory management behavior')
    then('the plugin receives context state and can propose replacements')
      sothat('advanced strategies can be implemented externally')

given('builtin strategy: summarize-on-limit')
  when('context approaches the limit')
    then('earlier messages are summarized by the llm')
    then('tool results are condensed')
      sothat('context is freed while preserving meaning')

given('builtin strategy: truncate')
  when('context approaches the limit')
    then('oldest messages are dropped')
    then('no llm call is made')
      sothat('fast compaction is possible')

given('custom strategy plugins can implement advanced patterns')
  # examples of what custom plugins could implement:
  # - continuous-optimize: background thread proactively externalizes low-value content
  # - virtual-context (memgpt-style): pages content in/out, unbounded effective context
  # - semantic-cache: deduplicates semantically similar content
  when('a custom strategy plugin is registered')
    then('it receives hooks for context observation')
    then('it can propose context replacements asynchronously')
    then('replacements are applied between loop iterations')
      sothat('the plugin architecture supports any memory strategy')
```

---

## usecase.9 = plugin: permission guard configuration

```
given('bhrain.struct.v1 supports pluggable permission guards')
  when('a custom permission guard is provided')
    then('that guard is consulted before each tool execution')
      sothat('custom security policies can be enforced')

  when('no permission guard is provided')
    then('all tool calls are allowed')
      sothat('default is permissive for development')

  when('the permission guard returns "allow"')
    then('the tool executes immediately')

  when('the permission guard returns "deny"')
    then('the tool is not executed')
    then('a denial result is returned to the brain')

  when('the permission guard returns "prompt"')
    then('execution pauses')
    then('the user is asked for approval')
    then('the tool executes only if user approves')

  when('the permission guard throws an error')
    then('the tool is not executed')
    then('the error is logged')
    then('a safe denial result is returned')
      sothat('guard failures fail closed')
```

---

## usecase.10 = llm atom interchangeability

```
given('bhrain.struct.v1 is configured')
  when('the atom is set to "claude"')
    then('anthropic claude API is used for generation')
    then('tool calls follow claude's format')
    then('the agentic loop behaves identically')

  when('the atom is set to "qwen"')
    then('qwen API is used for generation')
    then('tool calls follow qwen's format')
    then('the agentic loop behaves identically')
      sothat('the structure is LLM-agnostic')

  when('the atom produces malformed tool calls')
    then('the error is caught')
    then('the brain can retry or report the issue')
      sothat('llm quirks dont crash the loop')
```

---

## usecase.11 = cli invocation

```
given('rhachet is installed')
  when('invoked with: npx rhachet run --repo bhrain --skill act --arch bhrain.struct.v1 --atom qwen --input "..."')
    then('the bhrain is instantiated with specified config')
    then('the input is passed to the brain')
    then('the brain executes its agentic loop')
    then('the result is printed to stdout')
      sothat('the brain is usable from command line')

  when('invoked without required arguments')
    then('a helpful error message is shown')
    then('the process exits with non-zero code')
      sothat('users know what's missing')

  when('invoked with an unknown atom')
    then('an error is returned')
    then('available atoms are listed')
      sothat('users can correct their command')
```

---

## usecase.12 = error handling

```
given('a bhrain executing an agentic loop')
  when('a tool execution throws an unexpected error')
    then('the error is caught')
    then('an error result is appended to context')
    then('the brain can reason about the error')
      sothat('crashes are converted to recoverable states')

  when('the llm API returns an error')
    then('the error is caught')
    then('retry logic is applied if appropriate')
    then('the error is surfaced if retries fail')
      sothat('transient failures are handled')

  when('the brain receives invalid input')
    then('a clear error message is returned')
    then('no agentic loop is started')
      sothat('garbage in does not cause garbage out')
```

---

## usecase.13 = observability

```
given('a bhrain executing')
  when('tools are called')
    then('tool calls are logged with inputs')
    then('tool results are logged with outputs')
      sothat('execution can be traced')

  when('the agentic loop iterates')
    then('iteration count is tracked')
    then('context token usage is tracked')
      sothat('resource consumption is visible')

  when('execution completes')
    then('total iterations are reported')
    then('total token usage is reported')
    then('elapsed time is reported')
      sothat('performance can be measured')
```

---

## boundary.1 = empty input

```
given('a bhrain is invoked')
  when('the input is empty string')
    then('the brain responds with a clarification request')
      sothat('empty inputs are handled gracefully')
```

---

## boundary.2 = very long input

```
given('a bhrain with a context window limit')
  when('the input exceeds the context window')
    then('an error is returned before execution')
    then('the error explains the size limit')
      sothat('oversized inputs fail fast')
```

---

## boundary.3 = tool returns very large result

```
given('a bhrain executing')
  when('a tool returns a result exceeding truncation limit')
    then('the result is truncated')
    then('a truncation notice is included')
    then('the brain can request more specific queries')
      sothat('large results dont exhaust context')
```

---

## boundary.4 = concurrent tool calls with failures

```
given('a bhrain that calls multiple tools in parallel')
  when('some tools succeed and some fail')
    then('successful results are appended')
    then('failure results are appended')
    then('the brain can reason about partial success')
      sothat('one failure doesnt block all results')
```

---

## boundary.5 = tool call references non-existent tool

```
given('a bhrain with a limited tool set')
  when('the llm generates a call to a non-existent tool')
    then('an error result is returned')
    then('available tools are listed in the error')
    then('the brain can correct and retry')
      sothat('hallucinated tools are handled')
```
