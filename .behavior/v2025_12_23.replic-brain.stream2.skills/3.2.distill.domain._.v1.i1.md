# domain distillation: bhrain.struct.v1

---

## 1. usecases → contracts

### 1.1 invoke brain

```ts
/**
 * .what = invoke a bhrain with config and prompt, run to completion
 * .why = primary entry point for using the brain
 */
const invokeBhrain: (
  input: { config: BhrainConfig; prompt: string },
  context: BhrainContext,
) => Promise<BhrainSessionResult>;
```

### 1.2 run agentic loop

```ts
/**
 * .what = execute the generate → tools → append cycle until completion
 * .why = core orchestration pattern
 */
const runBhrainLoop: (
  input: { session: BhrainSession; messages: BhrainSessionMessage[] },
  context: BhrainContext,
) => Promise<BhrainLoopResult>;
```

### 1.3 execute tool

```ts
/**
 * .what = execute a single tool call through permission check and toolbox
 * .why = atomic unit of tool execution
 */
const executeBhrainToolCall: (
  input: { call: BhrainToolCall; boxes: BhrainToolBox[] },
  context: BhrainContext & { guard: BhrainPermissionGuard },
) => Promise<BhrainToolResult>;
```

### 1.4 compact memory

```ts
/**
 * .what = optimize context window via memory manager
 * .why = enables long-running sessions within token limits
 */
const compactBhrainMemory: (
  input: { messages: BhrainSessionMessage[]; manager: BhrainMemoryManager },
  context: BhrainContext,
) => Promise<BhrainMemoryCompactionResult>;
```

### 1.5 spawn subagent

```ts
/**
 * .what = spawn isolated child agent for delegated task
 * .why = enables parallel/isolated execution with fresh context
 */
const spawnBhrainSubagent: (
  input: { parentSession: BhrainSession; type: BhrainSubagentType; prompt: string },
  context: BhrainContext,
) => Promise<BhrainSessionSubagent>;
```

---

## 2. domain.objects

### 2.1 file structure

```
src/domain.objects/
├── Bhrain/
│   ├── BhrainConfig.ts
│   ├── BhrainAtom.ts
│   └── BhrainContext.ts
│
├── BhrainSession/
│   ├── BhrainSession.ts
│   ├── BhrainSessionMessage.ts
│   └── BhrainSessionSubagent.ts
│
├── BhrainLoop/
│   ├── BhrainLoopIteration.ts
│   ├── BhrainLoopResult.ts
│   └── BhrainLoopIterationCompletedEvent.ts
│
├── BhrainTool/
│   ├── BhrainToolDefinition.ts
│   ├── BhrainToolCall.ts
│   ├── BhrainToolResult.ts
│   ├── BhrainToolBox.ts
│   └── BhrainToolExecutionCompletedEvent.ts
│
├── BhrainMemory/
│   ├── BhrainMemoryManager.ts
│   ├── BhrainMemoryTokenUsage.ts
│   ├── BhrainMemoryCompactionResult.ts
│   └── BhrainMemoryCompactedEvent.ts
│
└── BhrainPermission/
    ├── BhrainPermissionGuard.ts
    └── BhrainPermissionDecision.ts
```

---

### 2.2 entities

#### BhrainConfig

```ts
// src/domain.objects/Bhrain/BhrainConfig.ts
import { DomainEntity } from 'domain-objects';

export interface BhrainConfig {
  uuid?: string;
  atom: BhrainAtom;
  toolBoxes: BhrainToolBox[];
  memoryManager: BhrainMemoryManager;
  permissionGuard: BhrainPermissionGuard;
  maxIterations: number;
  systemPrompt: string | null;
}

export class BhrainConfig
  extends DomainEntity<BhrainConfig>
  implements BhrainConfig
{
  public static primary = ['uuid'] as const;
  public static unique = ['uuid'] as const;
  public static updatable = [
    'toolBoxes',
    'memoryManager',
    'permissionGuard',
    'maxIterations',
    'systemPrompt',
  ] as const;
}
```

#### BhrainSession

```ts
// src/domain.objects/BhrainSession/BhrainSession.ts
import { DomainEntity } from 'domain-objects';

export type BhrainSessionStatus = 'ACTIVE' | 'COMPLETED' | 'TERMINATED';

export interface BhrainSession {
  uuid?: string;
  configUuid: string;
  status: BhrainSessionStatus;
  iterationCount: number;
  tokenUsage: BhrainMemoryTokenUsage;
  startedAt: string;
  endedAt: string | null;
}

export class BhrainSession
  extends DomainEntity<BhrainSession>
  implements BhrainSession
{
  public static primary = ['uuid'] as const;
  public static unique = ['uuid'] as const;
  public static updatable = [
    'status',
    'iterationCount',
    'tokenUsage',
    'endedAt',
  ] as const;
  public static nested = {
    tokenUsage: BhrainMemoryTokenUsage,
  };
}
```

#### BhrainSessionSubagent

```ts
// src/domain.objects/BhrainSession/BhrainSessionSubagent.ts
import { DomainEntity } from 'domain-objects';

export type BhrainSubagentType = 'explore' | 'plan' | 'general-purpose';
export type BhrainSubagentStatus = 'RUNNING' | 'COMPLETED' | 'FAILED';

export interface BhrainSessionSubagent {
  uuid?: string;
  sessionUuid: string;
  type: BhrainSubagentType;
  prompt: string;
  status: BhrainSubagentStatus;
  result: string | null;
}

export class BhrainSessionSubagent
  extends DomainEntity<BhrainSessionSubagent>
  implements BhrainSessionSubagent
{
  public static primary = ['uuid'] as const;
  public static unique = ['uuid'] as const;
  public static updatable = ['status', 'result'] as const;
}
```

---

### 2.3 literals

#### BhrainAtom

```ts
// src/domain.objects/Bhrain/BhrainAtom.ts
import { DomainLiteral } from 'domain-objects';

export type BhrainAtomProvider = 'anthropic' | 'qwen' | 'openai';

export interface BhrainAtom {
  provider: BhrainAtomProvider;
  model: string;
}

export class BhrainAtom extends DomainLiteral<BhrainAtom> implements BhrainAtom {}
```

#### BhrainContext

```ts
// src/domain.objects/Bhrain/BhrainContext.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainContextCreds {
  apiKey: string;
  url: string | null;
}

export interface BhrainContext {
  creds: Record<string, BhrainContextCreds>;
  log: LogMethods;
}

export class BhrainContext
  extends DomainLiteral<BhrainContext>
  implements BhrainContext {}
```

#### BhrainSessionMessage

```ts
// src/domain.objects/BhrainSession/BhrainSessionMessage.ts
import { DomainLiteral } from 'domain-objects';

export type BhrainMessageRole = 'system' | 'user' | 'assistant' | 'tool';

export interface BhrainSessionMessage {
  role: BhrainMessageRole;
  content: string | null;
  toolCalls: BhrainToolCall[] | null;
  toolCallId: string | null;
  timestamp: string;
}

export class BhrainSessionMessage
  extends DomainLiteral<BhrainSessionMessage>
  implements BhrainSessionMessage
{
  public static nested = {
    toolCalls: BhrainToolCall,
  };
}
```

#### BhrainLoopIteration

```ts
// src/domain.objects/BhrainLoop/BhrainLoopIteration.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainLoopIteration {
  number: number;
  hadToolCalls: boolean;
  toolCallCount: number;
  tokenUsage: BhrainMemoryTokenUsage;
}

export class BhrainLoopIteration
  extends DomainLiteral<BhrainLoopIteration>
  implements BhrainLoopIteration
{
  public static nested = {
    tokenUsage: BhrainMemoryTokenUsage,
  };
}
```

#### BhrainLoopResult

```ts
// src/domain.objects/BhrainLoop/BhrainLoopResult.ts
import { DomainLiteral } from 'domain-objects';

export type BhrainLoopTerminationReason =
  | 'NATURAL_COMPLETION'
  | 'MAX_ITERATIONS'
  | 'USER_INTERRUPTION'
  | 'ERROR';

export interface BhrainLoopResult {
  session: BhrainSession;
  messages: BhrainSessionMessage[];
  finalResponse: string;
  terminationReason: BhrainLoopTerminationReason;
}

export class BhrainLoopResult
  extends DomainLiteral<BhrainLoopResult>
  implements BhrainLoopResult {}
```

#### BhrainToolDefinition

```ts
// src/domain.objects/BhrainTool/BhrainToolDefinition.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainToolDefinition {
  name: string;
  description: string;
  inputSchema: Record<string, unknown>; // JSON Schema
  strict: boolean;
}

export class BhrainToolDefinition
  extends DomainLiteral<BhrainToolDefinition>
  implements BhrainToolDefinition {}
```

#### BhrainToolCall

```ts
// src/domain.objects/BhrainTool/BhrainToolCall.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainToolCall {
  id: string;
  name: string;
  input: Record<string, unknown>;
}

export class BhrainToolCall
  extends DomainLiteral<BhrainToolCall>
  implements BhrainToolCall {}
```

#### BhrainToolResult

```ts
// src/domain.objects/BhrainTool/BhrainToolResult.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainToolResult {
  callId: string;
  success: boolean;
  output: string;
  truncated: boolean;
  exitCode: number | null;
}

export class BhrainToolResult
  extends DomainLiteral<BhrainToolResult>
  implements BhrainToolResult {}
```

#### BhrainToolBox

```ts
// src/domain.objects/BhrainTool/BhrainToolBox.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainToolBox {
  name: string;
  definitions: BhrainToolDefinition[];
  execute: (
    input: { call: BhrainToolCall },
    context: BhrainContext,
  ) => Promise<BhrainToolResult>;
}

export class BhrainToolBox
  extends DomainLiteral<BhrainToolBox>
  implements BhrainToolBox
{
  public static nested = {
    definitions: BhrainToolDefinition,
  };
}
```

#### BhrainMemoryTokenUsage

```ts
// src/domain.objects/BhrainMemory/BhrainMemoryTokenUsage.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainMemoryTokenUsage {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
}

export class BhrainMemoryTokenUsage
  extends DomainLiteral<BhrainMemoryTokenUsage>
  implements BhrainMemoryTokenUsage {}
```

#### BhrainMemoryCompactionResult

```ts
// src/domain.objects/BhrainMemory/BhrainMemoryCompactionResult.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainMemoryCompactionResult {
  shouldUpdate: boolean;
  newMessages: BhrainSessionMessage[] | null;
  externalizedRefs: string[] | null;
}

export class BhrainMemoryCompactionResult
  extends DomainLiteral<BhrainMemoryCompactionResult>
  implements BhrainMemoryCompactionResult {}
```

#### BhrainMemoryManager

```ts
// src/domain.objects/BhrainMemory/BhrainMemoryManager.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainMemoryManager {
  name: string;
  shouldUpdate: (
    input: { messages: BhrainSessionMessage[] },
    context: BhrainContext,
  ) => boolean;
  getUpdate: (
    input: { messages: BhrainSessionMessage[] },
    context: BhrainContext,
  ) => Promise<BhrainMemoryCompactionResult>;
  observe: ((
    input: { messages: BhrainSessionMessage[] },
    context: BhrainContext,
  ) => void) | null;
}

export class BhrainMemoryManager
  extends DomainLiteral<BhrainMemoryManager>
  implements BhrainMemoryManager {}
```

#### BhrainPermissionDecision

```ts
// src/domain.objects/BhrainPermission/BhrainPermissionDecision.ts
import { DomainLiteral } from 'domain-objects';

export type BhrainPermissionVerdict = 'allow' | 'deny' | 'prompt';

export interface BhrainPermissionDecision {
  decision: BhrainPermissionVerdict;
  reason: string | null;
}

export class BhrainPermissionDecision
  extends DomainLiteral<BhrainPermissionDecision>
  implements BhrainPermissionDecision {}
```

#### BhrainPermissionGuard

```ts
// src/domain.objects/BhrainPermission/BhrainPermissionGuard.ts
import { DomainLiteral } from 'domain-objects';

export interface BhrainPermissionGuard {
  name: string;
  check: (
    input: { call: BhrainToolCall },
    context: BhrainContext,
  ) => BhrainPermissionDecision;
}

export class BhrainPermissionGuard
  extends DomainLiteral<BhrainPermissionGuard>
  implements BhrainPermissionGuard {}
```

---

### 2.4 events

#### BhrainLoopIterationCompletedEvent

```ts
// src/domain.objects/BhrainLoop/BhrainLoopIterationCompletedEvent.ts
import { DomainEvent } from 'domain-objects';

export interface BhrainLoopIterationCompletedEvent {
  sessionUuid: string;
  iterationNumber: number;
  hadToolCalls: boolean;
  tokenUsage: BhrainMemoryTokenUsage;
  occurredAt: string;
}

export class BhrainLoopIterationCompletedEvent
  extends DomainEvent<BhrainLoopIterationCompletedEvent>
  implements BhrainLoopIterationCompletedEvent
{
  public static unique = ['sessionUuid', 'iterationNumber'] as const;
}
```

#### BhrainToolExecutionCompletedEvent

```ts
// src/domain.objects/BhrainTool/BhrainToolExecutionCompletedEvent.ts
import { DomainEvent } from 'domain-objects';

export interface BhrainToolExecutionCompletedEvent {
  sessionUuid: string;
  callId: string;
  toolName: string;
  durationMs: number;
  success: boolean;
  occurredAt: string;
}

export class BhrainToolExecutionCompletedEvent
  extends DomainEvent<BhrainToolExecutionCompletedEvent>
  implements BhrainToolExecutionCompletedEvent
{
  public static unique = ['sessionUuid', 'callId'] as const;
}
```

#### BhrainMemoryCompactedEvent

```ts
// src/domain.objects/BhrainMemory/BhrainMemoryCompactedEvent.ts
import { DomainEvent } from 'domain-objects';

export interface BhrainMemoryCompactedEvent {
  sessionUuid: string;
  strategy: string;
  tokensBefore: number;
  tokensAfter: number;
  occurredAt: string;
}

export class BhrainMemoryCompactedEvent
  extends DomainEvent<BhrainMemoryCompactedEvent>
  implements BhrainMemoryCompactedEvent
{
  public static unique = ['sessionUuid', 'occurredAt'] as const;
}
```

---

## 3. domain.operations

### 3.1 file structure

```
src/domain.operations/
├── bhrain/
│   ├── invokeBhrain.ts
│   └── invokeBhrain.integration.test.ts
│
├── bhrainLoop/
│   ├── runBhrainLoop.ts
│   ├── runBhrainLoop.integration.test.ts
│   ├── iterateBhrainLoop.ts
│   └── iterateBhrainLoop.test.ts
│
├── bhrainTool/
│   ├── executeBhrainToolCall.ts
│   ├── executeBhrainToolCall.test.ts
│   ├── mergeBhrainToolBoxes.ts
│   └── mergeBhrainToolBoxes.test.ts
│
├── bhrainMemory/
│   ├── compactBhrainMemory.ts
│   ├── compactBhrainMemory.test.ts
│   ├── summarizeBhrainMessages.ts
│   └── truncateBhrainMessages.ts
│
├── bhrainPermission/
│   ├── checkBhrainPermission.ts
│   ├── checkBhrainPermission.test.ts
│   └── promptBhrainPermissionApproval.ts
│
└── bhrainSubagent/
    ├── spawnBhrainSubagent.ts
    └── spawnBhrainSubagent.integration.test.ts
```

---

### 3.2 core operations

#### invokeBhrain

```ts
// src/domain.operations/bhrain/invokeBhrain.ts
import { BhrainConfig, BhrainContext, BhrainLoopResult } from '@/domain.objects';
import { runBhrainLoop } from '../bhrainLoop/runBhrainLoop';

/**
 * .what = invoke a bhrain with config and prompt, run to completion
 * .why = primary entry point for using the brain
 */
export const invokeBhrain = async (
  input: { config: BhrainConfig; prompt: string },
  context: BhrainContext,
): Promise<BhrainLoopResult> => {
  // create initial session
  const session = new BhrainSession({
    configUuid: input.config.uuid,
    status: 'ACTIVE',
    iterationCount: 0,
    tokenUsage: new BhrainMemoryTokenUsage({
      inputTokens: 0,
      outputTokens: 0,
      totalTokens: 0,
    }),
    startedAt: new Date().toISOString(),
    endedAt: null,
  });

  // build initial messages
  const messages: BhrainSessionMessage[] = [
    new BhrainSessionMessage({
      role: 'system',
      content: input.config.systemPrompt,
      toolCalls: null,
      toolCallId: null,
      timestamp: new Date().toISOString(),
    }),
    new BhrainSessionMessage({
      role: 'user',
      content: input.prompt,
      toolCalls: null,
      toolCallId: null,
      timestamp: new Date().toISOString(),
    }),
  ];

  // run the loop
  return runBhrainLoop({ session, messages, config: input.config }, context);
};
```

#### runBhrainLoop

```ts
// src/domain.operations/bhrainLoop/runBhrainLoop.ts

/**
 * .what = execute the agentic loop until completion
 * .why = core orchestration - generate, tools, append, repeat
 */
export const runBhrainLoop = async (
  input: {
    session: BhrainSession;
    messages: BhrainSessionMessage[];
    config: BhrainConfig;
  },
  context: BhrainContext,
): Promise<BhrainLoopResult> => {
  let { session, messages } = input;
  const { config } = input;

  // loop until completion
  while (session.status === 'ACTIVE') {
    // check max iterations
    if (session.iterationCount >= config.maxIterations) {
      session = session.clone({ status: 'TERMINATED' });
      return new BhrainLoopResult({
        session,
        messages,
        finalResponse: 'max iterations reached',
        terminationReason: 'MAX_ITERATIONS',
      });
    }

    // run one iteration
    const iteration = await iterateBhrainLoop(
      { session, messages, config },
      context,
    );

    // update session
    session = session.clone({
      iterationCount: session.iterationCount + 1,
      tokenUsage: iteration.tokenUsage,
    });

    // append messages from iteration
    messages = [...messages, ...iteration.newMessages];

    // check if loop should terminate
    if (!iteration.hadToolCalls) {
      session = session.clone({
        status: 'COMPLETED',
        endedAt: new Date().toISOString(),
      });
      return new BhrainLoopResult({
        session,
        messages,
        finalResponse: iteration.newMessages.at(-1)?.content ?? '',
        terminationReason: 'NATURAL_COMPLETION',
      });
    }

    // check memory manager
    const compactionResult = await compactBhrainMemory(
      { messages, manager: config.memoryManager },
      context,
    );
    if (compactionResult.shouldUpdate && compactionResult.newMessages) {
      messages = compactionResult.newMessages;
    }
  }

  // fallback return
  return new BhrainLoopResult({
    session,
    messages,
    finalResponse: '',
    terminationReason: 'ERROR',
  });
};
```

#### iterateBhrainLoop

```ts
// src/domain.operations/bhrainLoop/iterateBhrainLoop.ts

/**
 * .what = execute one cycle of the agentic loop
 * .why = atomic unit of loop execution: generate → execute tools → collect results
 */
export const iterateBhrainLoop = async (
  input: {
    session: BhrainSession;
    messages: BhrainSessionMessage[];
    config: BhrainConfig;
  },
  context: BhrainContext,
): Promise<{
  iteration: BhrainLoopIteration;
  newMessages: BhrainSessionMessage[];
  hadToolCalls: boolean;
}> => {
  // generate llm response
  const response = await generateBhrainLlmResponse(
    {
      atom: input.config.atom,
      messages: input.messages,
      toolDefinitions: mergeBhrainToolBoxes({ boxes: input.config.toolBoxes }),
    },
    context,
  );

  // collect new messages
  const newMessages: BhrainSessionMessage[] = [response.message];

  // check for tool calls
  if (!response.message.toolCalls?.length) {
    return {
      iteration: new BhrainLoopIteration({
        number: input.session.iterationCount + 1,
        hadToolCalls: false,
        toolCallCount: 0,
        tokenUsage: response.tokenUsage,
      }),
      newMessages,
      hadToolCalls: false,
    };
  }

  // execute each tool call
  for (const call of response.message.toolCalls) {
    const result = await executeBhrainToolCall(
      { call, boxes: input.config.toolBoxes },
      { ...context, guard: input.config.permissionGuard },
    );

    // append tool result as message
    newMessages.push(
      new BhrainSessionMessage({
        role: 'tool',
        content: result.output,
        toolCalls: null,
        toolCallId: call.id,
        timestamp: new Date().toISOString(),
      }),
    );
  }

  return {
    iteration: new BhrainLoopIteration({
      number: input.session.iterationCount + 1,
      hadToolCalls: true,
      toolCallCount: response.message.toolCalls.length,
      tokenUsage: response.tokenUsage,
    }),
    newMessages,
    hadToolCalls: true,
  };
};
```

#### executeBhrainToolCall

```ts
// src/domain.operations/bhrainTool/executeBhrainToolCall.ts

/**
 * .what = execute a tool call through permission guard and toolbox
 * .why = atomic tool execution with security checks
 */
export const executeBhrainToolCall = async (
  input: { call: BhrainToolCall; boxes: BhrainToolBox[] },
  context: BhrainContext & { guard: BhrainPermissionGuard },
): Promise<BhrainToolResult> => {
  // check permission
  const decision = context.guard.check({ call: input.call }, context);

  // handle denial
  if (decision.decision === 'deny') {
    return new BhrainToolResult({
      callId: input.call.id,
      success: false,
      output: `permission denied: ${decision.reason ?? 'no reason given'}`,
      truncated: false,
      exitCode: null,
    });
  }

  // handle prompt
  if (decision.decision === 'prompt') {
    const approved = await promptBhrainPermissionApproval({ call: input.call }, context);
    if (!approved) {
      return new BhrainToolResult({
        callId: input.call.id,
        success: false,
        output: 'permission denied by user',
        truncated: false,
        exitCode: null,
      });
    }
  }

  // find toolbox with this tool
  const box = input.boxes.find((b) =>
    b.definitions.some((d) => d.name === input.call.name),
  );
  if (!box) {
    return new BhrainToolResult({
      callId: input.call.id,
      success: false,
      output: `tool not found: ${input.call.name}`,
      truncated: false,
      exitCode: null,
    });
  }

  // execute tool
  return box.execute({ call: input.call }, context);
};
```

---

## 4. access layer

### 4.1 access.sdks

```
src/access/sdks/
├── anthropic/
│   ├── generateAnthropicResponse.ts
│   └── generateAnthropicResponse.integration.test.ts
│
├── qwen/
│   ├── generateQwenResponse.ts
│   └── generateQwenResponse.integration.test.ts
│
└── openai/
    ├── generateOpenaiResponse.ts
    └── generateOpenaiResponse.integration.test.ts
```

#### generateAnthropicResponse

```ts
// src/access/sdks/anthropic/generateAnthropicResponse.ts
import Anthropic from '@anthropic-ai/sdk';

/**
 * .what = generate llm response via anthropic api
 * .why = encapsulates anthropic-specific api integration
 */
export const generateAnthropicResponse = async (
  input: {
    model: string;
    messages: BhrainSessionMessage[];
    toolDefinitions: BhrainToolDefinition[];
  },
  context: BhrainContext,
): Promise<{
  message: BhrainSessionMessage;
  tokenUsage: BhrainMemoryTokenUsage;
}> => {
  const creds = context.creds.anthropic;
  const client = new Anthropic({ apiKey: creds.apiKey, baseURL: creds.url ?? undefined });

  const response = await client.messages.create({
    model: input.model,
    messages: input.messages.map(castToBhrainAnthropicMessage),
    tools: input.toolDefinitions.map(castToBhrainAnthropicTool),
    max_tokens: 4096,
  });

  return {
    message: castFromBhrainAnthropicResponse(response),
    tokenUsage: new BhrainMemoryTokenUsage({
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens,
      totalTokens: response.usage.input_tokens + response.usage.output_tokens,
    }),
  };
};
```

---

### 4.2 access.daos

no persistent storage required for mvp — session state lives in memory during execution.

future extensions may add:

```
src/access/daos/
├── bhrainSession/
│   └── (if session persistence needed)
└── bhrainMemoryExternal/
    └── (if externalized memory storage needed)
```

---

## 5. builtin plugins

### 5.1 memory managers

```
src/plugins/memoryManagers/
├── summarizeOnLimit.ts       # default: llm summarization when context fills
├── truncate.ts               # drop oldest messages
└── index.ts
```

### 5.2 permission guards

```
src/plugins/permissionGuards/
├── allowAll.ts               # development: permit everything
├── promptForWrites.ts        # default: prompt for write operations
├── denyDangerous.ts          # production: block dangerous patterns
└── index.ts
```

### 5.3 toolboxes

```
src/plugins/toolBoxes/
├── files/
│   ├── index.ts
│   ├── read.ts
│   ├── write.ts
│   ├── edit.ts
│   ├── glob.ts
│   └── grep.ts
│
├── bash/
│   ├── index.ts
│   └── execute.ts
│
└── websearch/
    ├── index.ts
    └── search.ts
```

---

## 6. summary

### domain.objects (16)

| category | objects |
|----------|---------|
| entities | BhrainConfig, BhrainSession, BhrainSessionSubagent |
| literals | BhrainAtom, BhrainContext, BhrainSessionMessage, BhrainLoopIteration, BhrainLoopResult, BhrainToolDefinition, BhrainToolCall, BhrainToolResult, BhrainToolBox, BhrainMemoryTokenUsage, BhrainMemoryCompactionResult, BhrainMemoryManager, BhrainPermissionDecision, BhrainPermissionGuard |
| events | BhrainLoopIterationCompletedEvent, BhrainToolExecutionCompletedEvent, BhrainMemoryCompactedEvent |

### domain.operations (8)

| subdomain | operations |
|-----------|------------|
| bhrain | invokeBhrain |
| bhrainLoop | runBhrainLoop, iterateBhrainLoop |
| bhrainTool | executeBhrainToolCall, mergeBhrainToolBoxes |
| bhrainMemory | compactBhrainMemory, summarizeBhrainMessages, truncateBhrainMessages |
| bhrainPermission | checkBhrainPermission, promptBhrainPermissionApproval |
| bhrainSubagent | spawnBhrainSubagent |

### access.sdks (3)

| provider | operations |
|----------|------------|
| anthropic | generateAnthropicResponse |
| qwen | generateQwenResponse |
| openai | generateOpenaiResponse |
