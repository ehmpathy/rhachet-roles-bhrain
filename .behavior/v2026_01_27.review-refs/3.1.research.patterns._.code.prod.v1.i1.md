# research: production codepath patterns

## overview

this document enumerates the production codepath patterns relevant to the `--refs` feature for the review skill.

---

## pattern.1 = cli argument schema [EXTEND]

### what
zod schema defines the named arguments accepted by the review cli.

### relation to wish
must add `refs` field to accept the new `--refs` argument.

### citations

[1] `src/contract/cli/review.ts:15-33`
```typescript
const schemaOfArgs = z.object({
  named: z.object({
    // skill-specific args
    rules: z.string().optional(),
    diffs: z.string().optional(),
    paths: z.string().optional(),
    output: z.string().optional(),
    mode: z.enum(['pull', 'push']).optional(),
    goal: z.enum(['exhaustive', 'representative']),
    brain: z.string().optional(),
    rapid: z.string().optional(),
    // rhachet passthrough args (optional, ignored)
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});
```

---

## pattern.2 = cli argument parser [EXTEND]

### what
parser handles `--key=value` and `--key value` formats for named arguments.

### relation to wish
current parser stores only last value per key. must extend to support repeated flags (multiple `--refs` arguments accumulate into array).

### citations

[2] `src/infra/cli/getCliArgs.ts:35-50`
```typescript
if (eqIndex !== -1) {
  const key = arg.slice(2, eqIndex);
  const value = arg.slice(eqIndex + 1);
  named[key] = value;
}
// ...
const key = arg.slice(2);
const nextArg = argv[i + 1];
if (nextArg && !nextArg.startsWith('-')) {
  named[key] = nextArg;
  i++;
} else {
  named[key] = 'true';
}
```

---

## pattern.3 = glob resolution via fast-glob [REUSE]

### what
`enumFilesFromGlob` resolves glob patterns to file paths. already supports array input and negative patterns.

### relation to wish
can reuse directly to resolve `--refs` globs to file paths.

### citations

[3] `src/domain.operations/review/enumFilesFromGlob.ts:1-30`
```typescript
import fg from 'fast-glob';

export const enumFilesFromGlob = async (input: {
  glob: string | string[];
  cwd?: string;
}): Promise<string[]> => {
  // normalize to array
  const patterns = Array.isArray(input.glob) ? input.glob : [input.glob];

  // separate positive and negative patterns
  const positivePatterns = patterns.filter((p) => !p.startsWith('!'));
  const negativePatterns = patterns
    .filter((p) => p.startsWith('!'))
    .map((p) => p.slice(1)); // remove ! prefix for ignore

  // enumerate files
  const files = await fg(positivePatterns, {
    cwd: input.cwd,
    ignore: negativePatterns,
    onlyFiles: true,
    dot: true, // include dotfiles
  });

  // return sorted, deduplicated paths
  return [...new Set(files)].sort();
};
```

---

## pattern.4 = stepReview input shape [EXTEND]

### what
`stepReview` accepts input object with `rules`, `paths`, `diffs`, etc.

### relation to wish
must add `refs` field to input shape.

### citations

[4] `src/contract/cli/review.ts:63-75`
```typescript
await stepReview({
  rules: named.rules ?? '.agent/**/rules/**/*.md',
  diffs: named.diffs as 'since-main' | 'since-commit' | 'since-staged' | undefined,
  paths: named.paths,
  output: outputPath,
  mode: named.mode ?? 'pull',
  goal: named.goal,
  brain: named.brain,
});
```

---

## pattern.5 = file enumeration in stepReview [EXTEND]

### what
stepReview enumerates rule files and target files from globs.

### relation to wish
must add parallel enumeration for ref files.

### citations

[5] `src/domain.operations/review/stepReview.ts:194-227`
```typescript
// enumerate rule files
const ruleGlobs = Array.isArray(input.rules)
  ? input.rules
  : [input.rules].filter(Boolean);
const ruleFiles = await enumFilesFromGlob({ glob: ruleGlobs, cwd });

// enumerate target files from paths
const pathGlobs = input.paths
  ? Array.isArray(input.paths)
    ? input.paths
    : [input.paths]
  : [];
const positivePathGlobs = pathGlobs.filter((p) => !p.startsWith('!'));
const negativePathGlobs = pathGlobs
  .filter((p) => p.startsWith('!'))
  .map((p) => p.slice(1));
const targetFilesFromPaths = await enumFilesFromGlob({
  glob: positivePathGlobs,
  cwd,
});
```

---

## pattern.6 = prompt compilation structure [EXTEND]

### what
`compileReviewPrompt` builds prompt with `<rules>` and `<target>` sections.

### relation to wish
must add `<refs>` section to inject referenced context into prompt.

### citations

[6] `src/domain.operations/review/compileReviewPrompt.ts:58-92`
```typescript
const prompt = `# review task

you are a reviewer. apply the rules below to the target files.

## CRITICAL INSTRUCTIONS â€” READ CAREFULLY

1. ONLY review content in the <target> section
2. NEVER flag content from the <rules> section â€” rules contain examples of bad patterns for illustration only
3. if you see "bad: X" or "good: Y" in a rule, those are examples to learn from, NOT content to flag
4. the "locations" array must ONLY contain paths from <target>, never from <rules>
5. if you cannot find the violation in <target>, do not report it

${goalInstructions}

## rules (FOR REFERENCE ONLY â€” DO NOT FLAG CONTENT FROM THIS SECTION)

<rules>
${rulesSection}
</rules>

## target (REVIEW THIS SECTION ONLY)

<target>
${targetSection}
</target>
```

[7] `src/domain.operations/review/compileReviewPrompt.ts:26-28`
```typescript
const rulesSection = input.rules
  .map((rule) => `### ${rule.path}\n\n${rule.content}`)
  .join('\n\n---\n\n');
```

---

## pattern.7 = metrics display (pre-invocation) [EXTEND]

### what
console output shows file counts for rules and targets before brain invocation.

### relation to wish
must add refs count to the files tree.

### citations

[8] `src/domain.operations/review/stepReview.ts:381-398`
```typescript
console.log(
  `
ðŸ”­ metrics.expected
   â”œâ”€ files
   â”‚  â”œâ”€ rules: ${ruleFiles.length}
   â”‚  â””â”€ targets: ${targetFiles.length}
   â”œâ”€ tokens
   â”‚  â”œâ”€ estimate: ${promptResult.tokenEstimate}
   â”‚  â””â”€ context: ${promptResult.contextWindowPercent.toFixed(1)}%
   â””â”€ cost
      â””â”€ estimate: $${promptResult.costEstimate.toFixed(4)}

ðŸªµ logs
   â”œâ”€ scope: ${logDirRelative}/input.scope.json
   â”œâ”€ metrics: ${logDirRelative}/metrics.expected.json
   â””â”€ tokens: ${logDirRelative}/tokens.expected.md
`.trim(),
);
```

---

## pattern.8 = output summary display [EXTEND]

### what
console output shows review path and logs after brain invocation.

### relation to wish
must add summary branch with blocker/nitpick counts per vision.

### citations

[9] `src/domain.operations/review/stepReview.ts:473-491`
```typescript
console.log(
  `
âœ¨ metrics.realized
   â”œâ”€ tokens
   â”‚  â”œâ”€ input: ${realizedTokens.input.toLocaleString()}
   â”‚  â”œâ”€ cache.set: ${realizedTokens.inputCacheCreation.toLocaleString()}
   â”‚  â”œâ”€ cache.get: ${realizedTokens.inputCacheRead.toLocaleString()}
   â”‚  â”œâ”€ output: ${realizedTokens.output.toLocaleString()}
   â”‚  â””â”€ total: ${totalTokens.toLocaleString()}
   â”œâ”€ cost
   â”‚  â””â”€ total: ${asIsoPriceHuman(realizedCosts.total)}
   â””â”€ time
      â””â”€ total: ${metrics.cost.time}

ðŸŒŠ output
   â”œâ”€ logs: ${path.relative(cwd, logDir)}
   â””â”€ review: ${path.relative(cwd, outputAbsolute).startsWith('..') ? outputAbsolute : path.relative(cwd, outputAbsolute)}
`.trim(),
);
```

---

## pattern.9 = compileReviewPrompt input shape [EXTEND]

### what
`compileReviewPrompt` accepts rules and targets arrays with path and content.

### relation to wish
must add refs array with same shape.

### citations

[10] `src/domain.operations/review/compileReviewPrompt.ts:9-20` (inferred from usage)
```typescript
export const compileReviewPrompt = (input: {
  rules: Array<{ path: string; content: string }>;
  targets: Array<{ path: string; content: string }>;
  focus: 'pull' | 'push';
  goal: 'exhaustive' | 'representative';
  contextWindow: number;
}): {
  prompt: string;
  tokenEstimate: number;
  // ...
}
```

---

## pattern.10 = error messages for invalid paths [REUSE]

### what
`BadRequestError` used for validation failures with helpful context.

### relation to wish
can reuse pattern for ref path validation errors.

### citations

[11] `src/domain.operations/review/compileReviewPrompt.ts:121-128`
```typescript
if (contextWindowPercent > 75) {
  throw new BadRequestError(
    `prompt exceeds 75% of context window (${contextWindowPercent.toFixed(1)}% of ${contextWindow} tokens). ` +
      `reduce scope or use --pull mode to avoid quality degradation.`,
    { tokenEstimate, contextWindowPercent, contextWindow },
  );
}
```

---

## pattern.11 = input artifacts persistence [EXTEND]

### what
`input.scope.json` stores enumerated file lists.

### relation to wish
must include ref files in the scope artifact.

### citations

[12] `src/domain.operations/review/stepReview.ts:262` (inferred structure)
```typescript
const logDir = path.join(cwd, '.log', 'bhrain', 'review', genLogTimestamp());
await fs.mkdir(logDir, { recursive: true });
// writes input.scope.json with rule and target file lists
```

---

## pattern.12 = review output format [EXTEND]

### what
formatted output includes rule path in each issue.

### relation to wish
should include ref path when issue cites a ref.

### citations

[13] `src/domain.operations/review/formatReviewOutput.ts:36-44`
```typescript
const formatIssue = (
  issue: ReviewIssue,
  type: 'blocker' | 'nitpick',
  index: number,
): string => {
  const header = `# ${type}.${index + 1}: ${issue.title}`;
  const rule = `\n\n**rule**: ${issue.rule}`;
  const locations =
    issue.locations.length > 0
      ? `\n\n**locations**:\n${issue.locations.map((loc) => `- ${loc}`).join('\n')}`
      : '';
  return `${header}${rule}${locations}\n\n${issue.description}`;
};
```

---

## summary

| pattern | action | reason |
|---------|--------|--------|
| pattern.1 cli argument schema | EXTEND | add `refs` field |
| pattern.2 cli argument parser | EXTEND | support repeated flags |
| pattern.3 glob resolution | REUSE | already supports arrays |
| pattern.4 stepReview input | EXTEND | add `refs` field |
| pattern.5 file enumeration | EXTEND | add ref file enumeration |
| pattern.6 prompt structure | EXTEND | add `<refs>` section |
| pattern.7 metrics display (pre) | EXTEND | add refs count |
| pattern.8 output summary | EXTEND | add blocker/nitpick counts |
| pattern.9 compileReviewPrompt input | EXTEND | add refs array |
| pattern.10 error messages | REUSE | same pattern for ref errors |
| pattern.11 input artifacts | EXTEND | include refs in scope |
| pattern.12 review output format | EXTEND | support ref citations |
