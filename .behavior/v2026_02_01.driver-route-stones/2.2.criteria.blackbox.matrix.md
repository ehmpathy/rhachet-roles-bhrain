# blackbox criteria matrix: driver-route-stones

## matrix.1 = route.stone.get

| ind: query | ind: route state | ind: --say | dep: result |
|------------|------------------|------------|-------------|
| @next-one | has incomplete stones | false | returns first incomplete stone by alphanumeric order |
| @next-one | has incomplete stones | true | returns first incomplete stone + echoes content to stdout |
| @next-one | all stones complete | false | returns "all stones passed" |
| @next-one | all stones complete | true | returns "all stones passed" |
| @next-one | route not found | false | error: "route not found" |
| @next-one | route not found | true | error: "route not found" |
| @next-all | has incomplete stones | false | returns all incomplete stones with same numeric prefix |
| @next-all | has incomplete stones | true | returns all incomplete stones + echoes content to stdout |
| @next-all | all stones complete | false | returns "all stones passed" |
| @next-all | all stones complete | true | returns "all stones passed" |
| @next-all | route not found | false | error: "route not found" |
| @next-all | route not found | true | error: "route not found" |

**gaps**: none detected

---

## matrix.2 = route.stone.set (guardless)

| ind: artifact exists (via *.md glob) | dep: result |
|-------------------------------------|-------------|
| yes | marks stone as complete |
| no | error: "artifact not found; run route.stone.get --stone $stone --say to see instructions" |

**note**: artifact detection uses `$stone*.md` glob to support versioned artifacts (e.g., `1.vision.v1.i1.md`)

**gaps**: none detected

---

## matrix.3 = route.stone.set (guarded)

| ind: artifact exists | ind: prior files for same hash | ind: all judges pass | dep: result |
|---------------------|-------------------------------|---------------------|-------------|
| no | - | - | error: "artifact not found; run route.stone.get --stone $stone --say to see instructions" |
| yes | no | yes | runs reviews + judges, marks stone complete |
| yes | no | no | runs reviews + judges, returns rejection with feedback + file paths |
| yes | yes | yes | reuses prior files, marks stone complete |
| yes | yes | no | reuses prior files, returns rejection with feedback + file paths |

**note**: review and judge files are stored under `$route/.route/` since they're driver artifacts, not route artifacts

**gaps**: none detected

---

## matrix.4 = route.stone.set (hash change)

| ind: artifact changed since prior run | dep: review/judge behavior |
|--------------------------------------|---------------------------|
| no (same hash) | reuses prior review/judge files from `$route/.route/` |
| yes (new hash) | runs fresh reviews/judges with incremented iteration under `$route/.route/` |

**gaps**: none detected

---

## matrix.5 = route.stone.del

| ind: artifact exists | ind: glob matches multiple | dep: result |
|---------------------|---------------------------|-------------|
| no | no | removes .stone file and .guard file if present |
| no | yes | removes all matched stones without artifacts |
| yes | no | error: "cannot del; artifact exists" |
| yes | yes | skips stones with artifacts (emits notice), deletes rest |

**gaps**: none detected

---

## matrix.6 = route.stone.set --as approved

| dep: result |
|-------------|
| creates `$route/.route/$stone.approved` marker |

**note**: approval markers are driver artifacts stored under `.route/`. robot restriction is enforced by permission control, not code detection.

**gaps**: none detected

---

## matrix.7 = approved? judge

| ind: .approved marker present under .route/ | dep: result |
|--------------------------------------------|-------------|
| no | rejection: "wait for human approval" |
| yes | judge passes |

**gaps**: none detected

---

## matrix.8 = reviewed? judge

| ind: blockers | ind: nitpicks vs threshold | dep: result |
|---------------|---------------------------|-------------|
| 0 | within threshold | judge passes |
| 0 | exceeds threshold | rejection: "nitpicks exceed threshold" |
| >0 | within threshold | rejection: feedback from review |
| >0 | exceeds threshold | rejection: feedback from review |

**gaps**: none detected

---

## matrix.9 = parallel stone execution

| ind: query | ind: parallel tier state | dep: result |
|------------|-------------------------|-------------|
| @next-one | none complete | returns first stone in tier |
| @next-one | partial complete | returns first incomplete stone in tier |
| @next-one | all complete | returns first stone in next tier |
| @next-all | none complete | returns all stones in tier |
| @next-all | partial complete | returns incomplete stones left in tier |
| @next-all | all complete | returns all stones in next tier |

**gaps**: none detected

---

## matrix.10 = composed judges (AND logic)

| ind: reviewed? passes | ind: approved? passes | dep: result |
|----------------------|----------------------|-------------|
| no | no | rejection: feedback from review |
| no | yes | rejection: feedback from review |
| yes | no | rejection: "wait for human approval" |
| yes | yes | stone marked complete |

**gaps**: none detected

---

## decomposition analysis

**dimension count per matrix**:
- matrix.1: 3 dimensions ✓
- matrix.2: 1 dimension ✓
- matrix.3: 3 dimensions ✓
- matrix.4: 1 dimension ✓
- matrix.5: 2 dimensions ✓
- matrix.6: 0 dimensions (single outcome) ✓
- matrix.7: 1 dimension ✓
- matrix.8: 2 dimensions ✓
- matrix.9: 2 dimensions ✓
- matrix.10: 2 dimensions ✓

**decomposition opportunities**: none — all matrices have ≤3 independent dimensions. behavioral boundaries are well-scoped.
