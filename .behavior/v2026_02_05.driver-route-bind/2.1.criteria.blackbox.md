# blackbox criteria: route.bind

## usecase.1 = bind a route to the current branch

```
given('a route directory with stones')
  when('route.bind --route <path> is called')
    then('a bind flag file is created inside <path>/.route/')
      sothat('subsequent route commands can auto-resolve the route')
    then('stdout confirms the bound route path')
    then('exit code is 0')

  when('route.bind --route <path> is called a second time with the same path')
    then('the bind is idempotent — same flag file, no error')
    then('exit code is 0')
      sothat('retries and duplicate calls are safe')

  when('route.bind --route <path> is called but this branch already has a bind to a different route')
    then('error: "already bound to <other-path>. use route.bind --del first"')
    then('exit code is nonzero')
      sothat('accidental overwrite of a bind is prevented')

  when('route.bind --route <path> is called but <path> does not exist')
    then('error: "route directory does not exist: <path>"')
    then('exit code is nonzero')
      sothat('typos and stale paths are caught immediately')

  when('route.bind --route <path> is called on a protected branch (main, master)')
    then('error: "cannot bind route on protected branch"')
    then('exit code is nonzero')
      sothat('shared branches are not polluted with binds')
```

## usecase.2 = query the bound route

```
given('a branch with a route bound')
  when('route.bind --get is called')
    then('stdout shows: "bound to: <path>"')
    then('exit code is 0')

given('a branch with no route bound')
  when('route.bind --get is called')
    then('stdout shows: "not bound"')
    then('exit code is 0')
```

## usecase.3 = unbind a route

```
given('a branch with a route bound')
  when('route.bind --del is called')
    then('the bind flag file is removed')
    then('stdout confirms the unbind')
    then('exit code is 0')

  when('route.bind --del is called a second time')
    then('idempotent — no error even though already unbound')
    then('exit code is 0')

given('a branch with no route bound')
  when('route.bind --del is called')
    then('idempotent — no error')
    then('exit code is 0')
```

## usecase.4 = auto-resolve --route from bind on route.stone.get

```
given('a branch with a route bound to a directory that has stones')
  when('route.stone.get --stone @next-one is called WITHOUT --route')
    then('the route is resolved from the bind')
    then('the next stone is returned')
    then('exit code is 0')
      sothat('--route is no longer required after bind')

  when('route.stone.get --stone @next-one --route <explicit-path> is called WITH --route')
    then('the explicit --route wins over the bind')
    then('the stone is returned from the explicit route, not the bound one')
      sothat('the bind is a fallback, not a constraint')

given('a branch with no route bound')
  when('route.stone.get --stone @next-one is called WITHOUT --route')
    then('error: "no route bound to this branch. use --route or route.bind"')
    then('exit code is nonzero')
      sothat('the user knows exactly what to do')
```

## usecase.5 = auto-resolve --route from bind on route.stone.set

```
given('a branch with a route bound to a directory that has stones')
  when('route.stone.set --stone <name> --as passed is called WITHOUT --route')
    then('the route is resolved from the bind')
    then('the stone passage is recorded in the bound route')
    then('exit code is 0')

  when('route.stone.set --stone <name> --as passed --route <explicit-path> is called WITH --route')
    then('the explicit --route wins over the bind')
      sothat('the bind is a fallback, not a constraint')
```

## usecase.6 = auto-resolve --route from bind on route.stone.del

```
given('a branch with a route bound to a directory that has stones')
  when('route.stone.del --stone <glob> is called WITHOUT --route')
    then('the route is resolved from the bind')
    then('stones are deleted from the bound route')
    then('exit code is 0')

  when('route.stone.del --stone <glob> --route <explicit-path> is called WITH --route')
    then('the explicit --route wins over the bind')
```

## usecase.7 = multiple routes bound to same branch (ambiguity)

```
given('a branch with bind flags in two different route directories')
  when('route.stone.get --stone @next-one is called WITHOUT --route')
    then('error: "multiple routes bound to this branch. use --route to disambiguate"')
    then('exit code is nonzero')
      sothat('silent wrong-route is prevented')
```

## usecase.8 = full episode: bind → work → unbind

```
given('a fresh branch with a route directory that has 3 stones')
  when('route.bind --route <path> is called')
    then('bind succeeds')

  when('route.stone.get --stone @next-one is called (no --route)')
    then('returns stone 1')

  when('route.stone.set --stone <stone1> --as passed is called (no --route)')
    then('stone 1 is marked as passed in the bound route')

  when('route.stone.get --stone @next-one is called again (no --route)')
    then('returns stone 2 (stone 1 already passed)')
      sothat('the full workflow operates without --route after bind')

  when('route.bind --del is called')
    then('unbind succeeds')

  when('route.stone.get --stone @next-one is called (no --route)')
    then('error: "no route bound to this branch"')
      sothat('unbind truly removes the auto-resolve')
```
