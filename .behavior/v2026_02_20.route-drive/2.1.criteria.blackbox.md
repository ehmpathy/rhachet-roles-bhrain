# blackbox criteria: route.drive

## episode.1 = clone follows route with self-reviews

```
given(a route is bound with stones that have reviews.self defined)
  when(clone session ends and onStop hook fires rhx route.drive)
    then(output shows current stone name and path)
    then(output shows stone content in full)
    then(output shows command to mark stone as passed)
      sothat(clone knows what to do next)

  when(clone session starts and onBoot hook fires rhx route.drive)
    then(output shows current stone name and path)
    then(output shows stone content in full)
    then(output shows command to mark stone as passed)
      sothat(clone resumes where prior clone left off)

  when(clone runs rhx route.stone.set --stone $stone --as passed)
    then(passage = blocked with note "self-review required")
    then(output shows check yo'self section)
    then(output shows first unpromised review.self with slug)
    then(output shows "question everything, especially yourself")
    then(output shows guide content from say field)
    then(output shows command to promise that slug)
      sothat(clone must self-review before claim of done)

  when(clone runs rhx route.stone.set --stone $stone --as promised --that $slug)
    then(promise is recorded for $slug)

    given(more unpromised self-reviews remain)
      then(passage = progressed with note "self-review N/M promised")
      then(output shows check yo'self section for next review.self)
      then(output shows next slug and guide content)
      then(output shows command to promise next slug)
        sothat(clone proceeds through all self-reviews)

    given(this was the last unpromised self-review)
      then(proceeds to extant guard flow)
        sothat(peer reviews and judges run as normal)
```

## episode.2 = hash invalidation resets promises

```
given(clone has promised a review.self for a stone)
  when(clone edits the guarded artifact)
    then(artifact hash changes)

  when(clone runs rhx route.stone.set --stone $stone --as passed)
    then(prior promises are invalidated)
    then(output shows status = invalidated with note "source hash changed")
    then(output shows check yo'self section for invalidated review)
    then(clone must re-promise)
      sothat(stale self-reviews do not count)
```

## episode.3 = backwards compatible flat reviews

```
given(a guard file with reviews as flat array, no self key)
  when(clone runs rhx route.stone.set --stone $stone --as passed)
    then(no self-review flow triggers)
    then(peer reviews execute directly)
    then(judges execute)
    then(output shows guard tree)
      sothat(extant guard files work unchanged)
```

## episode.4 = route complete

```
given(a route is bound and all stones are passed)
  when(onStop or onBoot hook fires rhx route.drive)
    then(output shows "route complete")
      sothat(clone knows the route is finished)
```

## episode.5 = no route bound

```
given(no route is bound to current branch)
  when(onStop or onBoot hook fires rhx route.drive)
    then(output is silent or no-op)
    then(no error is thrown)
      sothat(hook does not break unbound sessions)
```

## exchange.1 = route.drive output

```
given(a route is bound with current stone)
  when(rhx route.drive is called)
    then(returns header "ðŸ¦‰ where were we?")
    then(returns tree with route path and stone name)
    then(returns stone content block)
    then(returns command to mark as passed)
```

## exchange.2 = route.stone.set --as passed with self-reviews

```
given(stone has reviews.self defined with N items)
  given(0 of N are promised)
    when(rhx route.stone.set --stone $stone --as passed)
      then(returns passage = blocked, note = self-review required)
      then(returns check yo'self section with review 1/N)

  given(K of N are promised, K < N)
    when(rhx route.stone.set --stone $stone --as passed)
      then(returns passage = blocked, note = self-review required)
      then(returns check yo'self section with review K+1/N)

  given(N of N are promised)
    when(rhx route.stone.set --stone $stone --as passed)
      then(peer reviews execute)
      then(judges execute)
      then(returns guard tree with results)
```

## exchange.3 = route.stone.set --as promised --that $slug

```
given(stone has reviews.self with slug $slug)
  when(rhx route.stone.set --stone $stone --as promised --that $slug)
    then(promise is recorded for $slug)
    then(returns passage = progressed)

  given($slug is not a valid review.self slug)
    when(rhx route.stone.set --stone $stone --as promised --that $slug)
      then(returns error with valid slug options)
        sothat(clone knows which slugs are available)
```

## exchange.4 = guard file parse

```
given(guard file with reviews as flat array)
  when(guard is parsed)
    then(reviews.peer = the array)
    then(reviews.self = empty)

given(guard file with reviews.self and reviews.peer keys)
  when(guard is parsed)
    then(reviews.self = array of {slug, say} objects)
    then(reviews.peer = array of shell commands)

given(reviews.self item with say as @path/to/brief.md)
  when(guide content is resolved)
    then(content is read from referenced file)
    then(content is echoed in check yo'self section)

given(reviews.self item with say as @path/to/absent.md)
  when(guide content is resolved)
    then(error includes the absent path)
      sothat(clone sees which brief is absent)
```

## exchange.5 = promise persistence

```
given(clone promises review.self slug)
  when(promise is recorded)
    then(promise artifact is written to .route/ directory)
    then(promise artifact includes source hash)

given(promise artifact exists for hash A)
  given(current artifact hash is A)
    when(promises are checked)
      then(promise is valid)

  given(current artifact hash is B)
    when(promises are checked)
      then(promise is invalidated)
```
