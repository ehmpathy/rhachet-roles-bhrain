# domain distillation: replic brain documentation system

## clarification

the wish is NOT to build a replic brain.

the wish is to BUILD A DOCUMENTATION SYSTEM (briefs) that documents replic brains.

therefore, the domain objects are about **knowledge artifacts**, not agentic loop components.

---

## purpose of this document

this document does NOT define code to be implemented.

this document defines the **conceptual operations** an agent will perform **manually** to fulfill the wish.

by naming the operations, we:
- clarify what steps need to happen
- give shared vocabulary for discussing progress
- make the execution plan explicit

the agent will execute these operations by:
- using web search to gather sources
- using file writes to create briefs
- using reasoning to distill concepts and blueprints

the "declastruct pattern" framing helps us think clearly about:
- what are the domain objects (briefs, concepts, blueprints)
- what are the idempotent operations (get, set)
- what is the unique key for each object (path, name, brainName)

---

## usecases → contracts

### usecase.1: create architect role

```ts
// contract
const createArchitectRole = async (
  input: { roleName: string; purpose: string },
  context: { fs: FileSystem }
): Promise<{ role: Role }> => { ... }

// usage
await createArchitectRole({
  roleName: 'architect',
  purpose: 'brain architecture expertise'
}, context)
```

### usecase.2: conduct literature search

```ts
// contract
const conductLiteratureSearch = async (
  input: {
    queries: string[];
    dateRange: { from: string; to: string };
  },
  context: { webSearch: WebSearchClient }
): Promise<{ sources: Source[] }> => { ... }

// usage
const { sources } = await conductLiteratureSearch({
  queries: ['ReAct agent', 'claude-code architecture', ...],
  dateRange: { from: '2024-01-01', to: '2025-12-31' }
}, context)
```

### usecase.3: create research catalog brief

```ts
// contract
const setBrief = async (
  input: PickOne<{ findsert: Brief; upsert: Brief }>,
  context: { fs: FileSystem }
): Promise<HasMetadata<Brief>> => { ... }

// usage
await setBrief({
  upsert: {
    path: 'src/roles/architect/briefs/brains.replic/arc000.sources.[catalog].md',
    archetype: 'catalog',
    title: 'research sources catalog',
    content: '...',
    sources: sources,
  }
}, context)
```

### usecase.4: define atomic concept

```ts
// contract
const defineConcept = async (
  input: {
    concept: Concept;
    sources: Source[];
  },
  context: { fs: FileSystem }
): Promise<{ brief: Brief }> => { ... }

// usage
await defineConcept({
  concept: {
    name: 'agentic-loop',
    definition: 'the core while(tool_call) → execute → repeat pattern',
    dependsOn: ['tool-call', 'context-window'],
  },
  sources: [source1, source2]
}, context)
```

### usecase.5: create treestruct brief

```ts
// contract
const createTreestructBrief = async (
  input: {
    concepts: Concept[];
    rootConcept: string;
  },
  context: { fs: FileSystem }
): Promise<{ brief: Brief }> => { ... }
```

### usecase.6: distill blueprint

```ts
// contract
const distillBlueprint = async (
  input: {
    brainName: string;
    concepts: Concept[];
    sources: Source[];
  },
  context: { fs: FileSystem }
): Promise<{ brief: Brief }> => { ... }

// usage
await distillBlueprint({
  brainName: 'claude-code',
  concepts: [agenticLoop, toolCall, contextWindow, ...],
  sources: claudeCodeSources,
}, context)
```

### usecase.7: create comparison catalog

```ts
// contract
const createComparisonCatalog = async (
  input: {
    blueprints: Blueprint[];
  },
  context: { fs: FileSystem }
): Promise<{ brief: Brief }> => { ... }
```

---

## domain.objects

### entities

#### Role
the owner of a collection of briefs

```ts
interface Role {
  id?: string;
  name: string;           // e.g., 'architect'
  purpose: string;        // e.g., 'brain architecture expertise'
  briefsPath: string;     // e.g., 'src/roles/architect/briefs'
}

class Role extends DomainEntity<Role> implements Role {
  public static primary = ['id'] as const;
  public static unique = ['name'] as const;
}
```

#### Brief
a knowledge document following the campus course pattern

```ts
interface Brief {
  id?: string;
  path: string;                          // filesystem path (unique)
  archetype: 'article' | 'catalog' | 'demo' | 'lesson';
  title: string;
  content: string;                       // markdown content
  sources: Source[];                     // collocated citations
  conceptRefs: string[];                 // concepts this brief references
  createdAt?: string;
  updatedAt?: string;
}

class Brief extends DomainEntity<Brief> implements Brief {
  public static primary = ['id'] as const;
  public static unique = ['path'] as const;
  public static updatable = ['title', 'content', 'sources', 'conceptRefs'] as const;
  public static nested = {
    sources: Source,
  };
}
```

#### Concept
an atomic idea with clear definition

```ts
interface Concept {
  id?: string;
  name: string;                          // e.g., 'agentic-loop'
  definition: string;                    // clear, singular meaning
  dependsOn: string[];                   // concept names this depends on
  briefPath: string;                     // the [article] brief that defines this
}

class Concept extends DomainEntity<Concept> implements Concept {
  public static primary = ['id'] as const;
  public static unique = ['name'] as const;
  public static updatable = ['definition', 'dependsOn', 'briefPath'] as const;
}
```

#### Blueprint
an architecture documentation for a specific replic brain

```ts
interface Blueprint {
  id?: string;
  brainName: string;                     // e.g., 'claude-code', 'devin', 'codex'
  pseudocode: string;                    // the core loop pseudocode
  contextStrategy: string;               // how context is managed
  toolInterface: string;                 // how tools are defined/called
  subagentPattern: string | null;        // how subagents work, if any
  briefPath: string;                     // the [article] brief containing this
  sources: Source[];
}

class Blueprint extends DomainEntity<Blueprint> implements Blueprint {
  public static primary = ['id'] as const;
  public static unique = ['brainName'] as const;
  public static updatable = ['pseudocode', 'contextStrategy', 'toolInterface', 'subagentPattern', 'briefPath', 'sources'] as const;
  public static nested = {
    sources: Source,
  };
}
```

---

### literals

#### Source
an immutable citation to external research

```ts
interface Source {
  title: string;
  authors: string | null;
  url: string;
  dateAccessed: string;
  relevance: string;                     // brief note on why this is cited
}

class Source extends DomainLiteral<Source> implements Source {}
```

#### BriefArchetype
the type of document treatment

```ts
type BriefArchetype = 'article' | 'catalog' | 'demo' | 'lesson';

// article = defines what a concept is
// catalog = organizes how concepts/instances relate
// demo = shows how an instance exemplifies a concept
// lesson = teaches how a concept is learned/practiced
```

#### ConceptRef
a reference to a concept by name

```ts
interface ConceptRef {
  conceptName: string;
  briefPath: string;                     // where the concept is defined
}

class ConceptRef extends DomainLiteral<ConceptRef> implements ConceptRef {}
```

---

### events

#### LiteratureSearchCompleted
```ts
interface LiteratureSearchCompleted {
  queries: string[];
  sourcesFound: number;
  dateRange: { from: string; to: string };
  occurredAt: string;
}
```

#### BriefCreated
```ts
interface BriefCreated {
  briefPath: string;
  archetype: BriefArchetype;
  occurredAt: string;
}
```

#### ConceptDefined
```ts
interface ConceptDefined {
  conceptName: string;
  briefPath: string;
  occurredAt: string;
}
```

#### BlueprintDistilled
```ts
interface BlueprintDistilled {
  brainName: string;
  briefPath: string;
  occurredAt: string;
}
```

---

## domain.operations

### brief operations (declastruct pattern)

#### getBrief
```ts
/**
 * .what = retrieves a brief from the filesystem
 * .why = enables reading existing documentation
 */
export const getBrief = async (
  input: {
    by: PickOne<{
      primary: RefByPrimary<typeof Brief>;
      unique: RefByUnique<typeof Brief>;  // { path }
      ref: Ref<typeof Brief>;
    }>;
  },
  context: { fs: FileSystem }
): Promise<HasMetadata<Brief> | null> => { ... }
```

#### setBrief
```ts
/**
 * .what = creates or updates a brief on the filesystem
 * .why = enables idempotent documentation authoring
 */
export const setBrief = async (
  input: PickOne<{
    findsert: Brief;
    upsert: Brief;
  }>,
  context: { fs: FileSystem }
): Promise<HasMetadata<Brief>> => { ... }
```

#### getAllBriefs
```ts
/**
 * .what = retrieves all briefs under a role's path
 * .why = enables listing and indexing documentation
 */
export const getAllBriefs = async (
  input: { rolePath: string; archetype?: BriefArchetype },
  context: { fs: FileSystem }
): Promise<HasMetadata<Brief>[]> => { ... }
```

### concept operations

#### getConcept
```ts
export const getConcept = async (
  input: { by: PickOne<{ name: string; briefPath: string }> },
  context: { fs: FileSystem }
): Promise<Concept | null> => { ... }
```

#### setConcept
```ts
/**
 * .what = defines a concept by creating its [article] brief
 * .why = ensures every concept has explicit documentation
 */
export const setConcept = async (
  input: PickOne<{ findsert: Concept; upsert: Concept }>,
  context: { fs: FileSystem }
): Promise<HasMetadata<Concept>> => { ... }
```

### blueprint operations

#### getBlueprint
```ts
export const getBlueprint = async (
  input: { by: { brainName: string } },
  context: { fs: FileSystem }
): Promise<Blueprint | null> => { ... }
```

#### setBlueprint
```ts
/**
 * .what = creates or updates a blueprint brief
 * .why = enables idempotent architecture documentation
 */
export const setBlueprint = async (
  input: PickOne<{ findsert: Blueprint; upsert: Blueprint }>,
  context: { fs: FileSystem }
): Promise<HasMetadata<Blueprint>> => { ... }
```

### research operations

#### searchLiterature
```ts
/**
 * .what = conducts web search for academic and technical sources
 * .why = gathers raw material for distillation into briefs
 */
export const searchLiterature = async (
  input: { queries: string[]; dateRange: { from: string; to: string } },
  context: { webSearch: WebSearchClient }
): Promise<{ sources: Source[] }> => { ... }
```

### treestruct operations

#### buildConceptTreestruct
```ts
/**
 * .what = computes dependency graph from concept.dependsOn relations
 * .why = enables visualization of how concepts compose
 */
export const buildConceptTreestruct = async (
  input: { concepts: Concept[] },
  context: {}
): Promise<{ treestruct: TreestructNode }> => { ... }

interface TreestructNode {
  conceptName: string;
  children: TreestructNode[];
}
```

### comparison operations

#### compareBlueprints
```ts
/**
 * .what = analyzes similarities and differences across blueprints
 * .why = contextualizes architectures within broader landscape
 */
export const compareBlueprints = async (
  input: { blueprints: Blueprint[] },
  context: {}
): Promise<{ comparison: BlueprintComparison }> => { ... }

interface BlueprintComparison {
  dimensions: string[];                  // e.g., 'loop-type', 'context-mgmt', 'tool-interface'
  matrix: Record<string, Record<string, string>>;  // brainName → dimension → value
  sharedPatterns: string[];
  divergentApproaches: string[];
}
```

---

## access.daos

### daoBrief
```ts
export const daoBrief = {
  getOne: getBrief,
  getAll: getAllBriefs,
  set: setBrief,
};
```

### daoConcept
```ts
export const daoConcept = {
  getOne: getConcept,
  getAll: getAllConcepts,
  set: setConcept,
};
```

### daoBlueprint
```ts
export const daoBlueprint = {
  getOne: getBlueprint,
  getAll: getAllBlueprints,
  set: setBlueprint,
};
```

### daoSource
```ts
// sources are literals embedded in briefs, not stored separately
// no dao needed - they are managed via daoBrief
```

---

## relationships

### treestruct of composition

```
Role (architect)
└── briefs/
    └── brains.replic/
        ├── Brief [catalog] - sources catalog
        │   └── Source[] (embedded)
        ├── Brief [article] - concept definitions
        │   ├── Concept (defined)
        │   └── Source[] (embedded)
        ├── Brief [article] - treestruct
        │   └── ConceptRef[] (links)
        ├── Brief [article] - blueprint (claude-code)
        │   ├── Blueprint (defined)
        │   └── Source[] (embedded)
        ├── Brief [article] - blueprint (alternative)
        │   ├── Blueprint (defined)
        │   └── Source[] (embedded)
        └── Brief [catalog] - comparison
            └── BlueprintComparison
```

### dependency order (execution flow)

```
1. createArchitectRole
   ↓
2. searchLiterature
   ↓
3. setBrief [catalog] sources
   ↓
4. setConcept × N (distilled from research)
   ↓
5. buildConceptTreestruct
   ↓
6. setBrief [article] treestruct
   ↓
7. setBlueprint × 2+ (claude-code, alternative)
   ↓
8. compareBlueprints
   ↓
9. setBrief [catalog] comparison
```

---

## filesystem mapping

the "remote resource" is the filesystem. briefs map to paths:

```
src/roles/architect/
├── readme.md                                    # Role
└── briefs/
    └── brains.replic/
        ├── arc000.sources.[catalog].md          # research catalog
        ├── arc101.concept.agentic-loop.[article].md
        ├── arc102.concept.tool-call.[article].md
        ├── arc103.concept.context-window.[article].md
        ├── arc150.concepts.treestruct.[article].md
        ├── arc201.blueprint.claude-code.[article].md
        ├── arc202.blueprint.codex.[article].md
        └── arc300.blueprints.comparison.[catalog].md
```

unique key for briefs = `path`
primary key for briefs = `id` (generated, optional for filesystem-only)
