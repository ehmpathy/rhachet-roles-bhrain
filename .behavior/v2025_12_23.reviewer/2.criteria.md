# usecase.1 = input: rules glob

given('a --rules glob is specified')
  when('the glob matches files')
    then('all matched rule files are enumerated')
      sothat('the reviewer knows which rules to apply')
  when('the glob includes a negative pattern with ! prefix')
    then('files matching the negative pattern are excluded')
      sothat('caller can filter out unwanted rules')
  when('the glob matches zero files')
    then('the skill fails fast with a clear error')
      sothat('caller knows their glob was ineffective')

---

# usecase.2 = input: diffs range

given('a --diffs range is specified')
  when('--diffs uptil-main')
    then('files changed between HEAD and main are enumerated')
      sothat('reviewer sees all uncommitted-to-main changes')
  when('--diffs uptil-commit')
    then('files changed since last commit are enumerated')
      sothat('reviewer sees staged + unstaged changes')
  when('--diffs uptil-staged')
    then('only staged files are enumerated')
      sothat('reviewer sees exactly what will be committed')
  when('multiple --diffs args are provided')
    then('the skill fails fast with a clear error')
      sothat('caller knows only one --diffs is allowed')

---

# usecase.3 = input: paths glob

given('a --paths glob is specified')
  when('the glob matches files')
    then('all matched files are enumerated')
      sothat('reviewer includes those paths in scope')
  when('multiple --paths args are provided')
    then('all globs are unioned together')
      sothat('caller can specify multiple path patterns')
  when('--paths is combined with --diffs')
    then('both diffs and paths are included in scope')
      sothat('caller can review diffs plus supplementary files')
  when('the glob includes a negative pattern with ! prefix')
    then('files matching the negative pattern are excluded')
      sothat('caller can filter out unwanted paths')

---

# usecase.4 = input: output path

given('an --output path is specified')
  when('the review completes successfully')
    then('the review markdown is written to the output path')
      sothat('caller receives the review at the expected location')
  when('the output path parent directory does not exist')
    then('the skill fails fast with a clear error')
      sothat('caller knows the path is invalid')

---

# usecase.5 = mode: soft

given('--soft mode is specified')
  when('the prompt is built')
    then('only file paths are included in the prompt')
    then('the prompt requests the brain to open the files')
      sothat('the brain can selectively load what it needs')
  when('the brain is invoked')
    then('the brain can explore and open files as needed')
      sothat('context is loaded on demand')

---

# usecase.6 = mode: hard

given('--hard mode is specified')
  when('the prompt is built')
    then('file contents are injected directly into the prompt')
      sothat('the brain has all context pre-loaded')
  when('total tokens exceed 75% of context window')
    then('the skill fails fast before invoking the brain')
    then('a clear error message states the token count vs limit')
    then('the error recommends reducing scope or switching to soft mode')
      sothat('caller avoids degraded review quality from context rot')
  when('total tokens exceed 60% of context window')
    then('a warning is emitted about potential quality degradation')
    then('the skill continues execution despite the warning')
      sothat('caller is informed but not blocked for moderate usage')
  when('the prompt is built successfully')
    then('an estimate of token count is emitted')
    then('an estimate of context window percentage is emitted')
    then('an estimate of approximate cost is emitted')
      sothat('caller understands the resource usage at all levels')

---

# usecase.7 = logging: input artifacts

given('the skill is invoked')
  when('file enumeration completes')
    then('input.args.json is written to .log/bhrain/review/$timestamp/')
    then('input.args.json contains the original input arguments')
    then('input.args.json contains all evaluated paths for --rules, --paths, --diffs')
    then('input.args.json contains stats on total tokens')
      sothat('the invocation is fully auditable')
  when('the prompt is compiled')
    then('input.prompt.md is written to .log/bhrain/review/$timestamp/')
    then('input.prompt.md contains the exact prompt sent to the brain')
      sothat('the prompt can be reviewed and reproduced')

---

# usecase.8 = logging: output artifacts

given('the brain returns a response')
  when('the response is received')
    then('output.response.json is written to .log/bhrain/review/$timestamp/')
    then('output.response.json contains the exact brain response')
      sothat('the raw output is preserved for debugging')
  when('the review markdown is formatted')
    then('output.review.md is written to .log/bhrain/review/$timestamp/')
    then('output.review.md follows the feedback template format')
      sothat('the formatted output is also logged')

---

# usecase.9 = output: review format

given('the review completes successfully')
  when('the output is formatted')
    then('the output follows the template in .ref.[feedback].v1.[given].by_human.md')
    then('the output is written to the --output path')
      sothat('the review is consistent and machine-parseable')

---

# usecase.10 = brain: claude-code invocation

given('the prompt is ready for invocation')
  when('the brain is replic:anthropic:claude-code')
    then('the prompt is invoked via the claude-code cli')
    then('the response is captured as structured output')
      sothat('the review is executed by the specified brain')

---

# usecase.11 = boundary: no inputs

given('no --rules, --diffs, or --paths are specified')
  when('the skill is invoked')
    then('the skill fails fast with a clear error')
      sothat('caller knows they must specify a review scope')

---

# usecase.12 = boundary: empty scope

given('--rules, --diffs, or --paths are specified')
  when('the combined scope resolves to zero files')
    then('the skill fails fast with a clear error')
      sothat('caller knows the scope was empty')

