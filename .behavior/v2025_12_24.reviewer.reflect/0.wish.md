wish =

we had a `role=reviewer` `skill=reflect` skill

with a contract of

- input
  - --source $sourceDirToFindFeedbackToReflectUponIn
  - --target $targetDirToGiveProposalsOfRulesInto

- output
  - emits rule proposals into the --output dir

- mechanism
  - drafts a skill for use against `brain.repl=claude-code`
  - should support --hard and --pull mode, just like src/roles/reviewer/skills/review/review.ts
    - all common code should be lifted into domain.operations
  - should support metrics.estimated + metrics.realized and the log files as well
  - should support --interactive mode too
  - should all be covered by tests as usual

---

the objective is to extract rules based on the feedback that users have given agents, at known [feedback].*.?[given] paths

for example in this dir;
- https://github.com/ehmpathy/declastruct-aws/tree/main/.behavior/v2025_12_05.aws-account-provision
  - https://github.com/ehmpathy/declastruct-aws/blob/main/.behavior/v2025_12_05.aws-account-provision/5.1.execution.phase0_to_phaseN.v1.i1.md.%5Bfeedback%5D.v1.%5Bgiven%5D.by_human.md
  - https://github.com/ehmpathy/declastruct-aws/blob/main/.behavior/v2025_12_05.aws-account-provision/5.1.execution.phase0_to_phaseN.v1.i1.md.%5Bfeedback%5D.v2.%5Bgiven%5D.by_human.md
  - https://github.com/ehmpathy/declastruct-aws/blob/main/.behavior/v2025_12_05.aws-account-provision/5.1.execution.phase0_to_phaseN.v1.i1.md.%5Bfeedback%5D.v3.%5Bgiven%5D.by_human.md
  - ...

theres up to v9 feedbacks in that behavior alone

we want to generalize out the rules per practice from those feedbacks

---

that way, we curate rules based on real life needs, rather than imagined needs

---

as part of this, we'll also need to declare role/reviewer/briefs about what rules are and how to write them. to declare a standard that folks can follow consistently.

the closest we have to a standard today is exemplified in this repo:
- https://github.com/ehmpathy/rhachet-roles-ehmpathy/blob/2d023fcd9f318748e51ebc9bfc04fd09510e60c2/src/domain.roles/mechanic/briefs/practices
- i.e.,
  - housed in `practices`
  - each practice in there specifies the surdomain + subdomain[] that qualifies the domain of the practice
    - groups them by concept cluster
  - each practice's leaf dirs has
    - rule files, with file name pattern `rule.$directive.$topic.md`
      - directive = forbid | avoid | prefer | require
        - forbid + require = blocker level
        - avoid + prefer = nitpick level
    - other files, like lessons, references, etc
      - these are other non-rule briefs that live collocated with rules
      - these non-rule briefs are loaded at role bootup time, to load the agent with the knowledge they'll need for their role

its critical that we establish clear guildelines on what the rules will look like

here's an example of a feedback file that will be emitted based on the rules, for context

.behavior/v2025_12_24.reviewer.reflect/.ref.[feedback].v1.[given].by_human.md


see src/roles/thinker/briefs/knowledge for how to write breifs

emit the briefs into `src/role/reviewer/briefs`


---

the skill should be a multistep operation

1. = propose drafts of rules into the `$DRAFT_DIR=$targetDir/.draft/v$timestamp/`
   1. these should not look at any of the rules taht are already in the targetDir
   2. they should just propose drafts that that they inferred
   3. in that $DRAFT_DIR, we should see
      1. 1. an md file which identifies the full set of citations of feedback.
         1. i.e., `$DRAFT_DIR/citations.md`
      2. 2. a directory which has the proposed rules
         1. `DRAFT_DIR/pure/`
            1. the pure dir should inside it should just propose the rules it can generalize from the citations
               1. should not look at the rules already in the $targetDir
               2. it should be a pure unique perspective from the generalized rules
               3. we dont want the current rules to taint what netnew rules could be discovered with a unique perspective
            2. each rule hsould be proposed as
               1. `rule.$directive.$topic.md`
               2. each rule should also collocate the exact citation + quote of evidence for where it generalized that rule from, so we can track its origin
               3. they should be valid remote github urls to the feedback files that it extracted the citation to, so that forever we can goback and reference the original context that the rule came from

2. = blend drafts of proposals within that DRAFT_DIR
   1. after the eproposals have been emitted, spawn a separate `brain.repl:claude-code` invocation which...
      1. gets fed the set of filepaths of the current rules in the $targetDir
      2. writes a manifest.json of where it plans to move each file from the `$DRAFT_DIR/pure` into `$DRAFT_DIR/sync` & in what mode
         1. this $DRAFT_DIR/sync will be a new directory which cp's the files from pure into sync
         2. the $sync directory will rename and reorg the rules from pure to match the structure already in the $targetDir
            1. => blends the pure perspective with the current target perspective
         3. for rules that are dupes, it can plan to [OMIT] them
         4. for rules that are new, it can plan to [SET_CREATE] them
         5. for rules that should be blended into the current documents, it can plan to [SET_UPDATE] them (update the rule)
         6. for rules that should be added as supported documents next to the current doc, it can plan to [SET_APPEND] them (append an extra doc)
            1. e.g., `rule.forbid.failhide.md` + append `rule.forbid.failhide.[demo].example_1.md`
      3. then writes the files to the sync path as asked


---

note, ideally the `brain.repl=claude.code` would be granted the privs to actually do the file writes

if not, we can parse the manifest.json's from each step and have the skill .sh harness do that for the brain instead

---

