# implementation blueprint: bhrain.struct.v1

---

## 0. overview

this blueprint defines the implementation strategy for `bhrain.struct.v1` - a replicable brain structure that mirrors claude-code's agentic loop pattern.

### 0.1 goal

produce a brain structure which:
1. can leverage anthropic's claude apis directly to replicate claude-code behaviors
2. can leverage opensource llms like `qwen` with the same structure
3. is testable at atomic and integration levels

### 0.2 invocation

```sh
npx rhachet run --repo bhrain --skill act \
  --arch bhrain.struct.v1 \
  --atom qwen \
  --input "report a treestruct of the files in this repo"
```

---

## 1. file structure

```
src/
â”œâ”€â”€ domain.objects/
â”‚   â”œâ”€â”€ Bhrain/
â”‚   â”‚   â”œâ”€â”€ BhrainConfig.ts
â”‚   â”‚   â”œâ”€â”€ BhrainAtom.ts
â”‚   â”‚   â””â”€â”€ BhrainContext.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ BhrainSession/
â”‚   â”‚   â”œâ”€â”€ BhrainSession.ts
â”‚   â”‚   â”œâ”€â”€ BhrainSessionMessage.ts
â”‚   â”‚   â””â”€â”€ BhrainSessionSubagent.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ BhrainLoop/
â”‚   â”‚   â”œâ”€â”€ BhrainLoopIteration.ts
â”‚   â”‚   â”œâ”€â”€ BhrainLoopResult.ts
â”‚   â”‚   â””â”€â”€ BhrainLoopIterationCompletedEvent.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ BhrainTool/
â”‚   â”‚   â”œâ”€â”€ BhrainToolDefinition.ts
â”‚   â”‚   â”œâ”€â”€ BhrainToolCall.ts
â”‚   â”‚   â”œâ”€â”€ BhrainToolResult.ts
â”‚   â”‚   â”œâ”€â”€ BhrainToolBox.ts
â”‚   â”‚   â””â”€â”€ BhrainToolExecutionCompletedEvent.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ BhrainMemory/
â”‚   â”‚   â”œâ”€â”€ BhrainMemoryManager.ts
â”‚   â”‚   â”œâ”€â”€ BhrainMemoryTokenUsage.ts
â”‚   â”‚   â”œâ”€â”€ BhrainMemoryCompactionResult.ts
â”‚   â”‚   â””â”€â”€ BhrainMemoryCompactedEvent.ts
â”‚   â”‚
â”‚   â””â”€â”€ BhrainPermission/
â”‚       â”œâ”€â”€ BhrainPermissionGuard.ts
â”‚       â””â”€â”€ BhrainPermissionDecision.ts
â”‚
â”œâ”€â”€ domain.operations/
â”‚   â””â”€â”€ brain.replic.arch1/
â”‚       â”œâ”€â”€ readme.md
â”‚       â”œâ”€â”€ core/
â”‚       â”‚   â”œâ”€â”€ invokeBhrain.ts
â”‚       â”‚   â””â”€â”€ invokeBhrain.integration.test.ts
â”‚       â”‚
â”‚       â”œâ”€â”€ loop/
â”‚       â”‚   â”œâ”€â”€ runBhrainLoop.ts
â”‚       â”‚   â”œâ”€â”€ runBhrainLoop.integration.test.ts
â”‚       â”‚   â”œâ”€â”€ iterateBhrainLoop.ts
â”‚       â”‚   â””â”€â”€ iterateBhrainLoop.test.ts
â”‚       â”‚
â”‚       â”œâ”€â”€ tool/
â”‚       â”‚   â”œâ”€â”€ executeBhrainToolCall.ts
â”‚       â”‚   â”œâ”€â”€ executeBhrainToolCall.test.ts
â”‚       â”‚   â”œâ”€â”€ mergeBhrainToolBoxes.ts
â”‚       â”‚   â””â”€â”€ mergeBhrainToolBoxes.test.ts
â”‚       â”‚
â”‚       â”œâ”€â”€ memory/
â”‚       â”‚   â”œâ”€â”€ compactBhrainMemory.ts
â”‚       â”‚   â”œâ”€â”€ compactBhrainMemory.test.ts
â”‚       â”‚   â”œâ”€â”€ summarizeBhrainMessages.ts
â”‚       â”‚   â””â”€â”€ truncateBhrainMessages.ts
â”‚       â”‚
â”‚       â”œâ”€â”€ permission/
â”‚       â”‚   â”œâ”€â”€ checkBhrainPermission.ts
â”‚       â”‚   â””â”€â”€ checkBhrainPermission.test.ts
â”‚       â”‚
â”‚       â”œâ”€â”€ llm/
â”‚       â”‚   â”œâ”€â”€ generateBhrainLlmResponse.ts
â”‚       â”‚   â””â”€â”€ generateBhrainLlmResponse.test.ts
â”‚       â”‚
â”‚       â””â”€â”€ plugins/
â”‚           â”œâ”€â”€ memoryManagers/
â”‚           â”‚   â”œâ”€â”€ summarizeOnLimit.ts
â”‚           â”‚   â””â”€â”€ truncate.ts
â”‚           â”‚
â”‚           â”œâ”€â”€ permissionGuards/
â”‚           â”‚   â”œâ”€â”€ allowAll.ts
â”‚           â”‚   â”œâ”€â”€ promptForWrites.ts
â”‚           â”‚   â””â”€â”€ denyDangerous.ts
â”‚           â”‚
â”‚           â””â”€â”€ toolBoxes/
â”‚               â”œâ”€â”€ files/
â”‚               â”‚   â”œâ”€â”€ index.ts
â”‚               â”‚   â”œâ”€â”€ read.ts
â”‚               â”‚   â”œâ”€â”€ write.ts
â”‚               â”‚   â”œâ”€â”€ edit.ts
â”‚               â”‚   â”œâ”€â”€ glob.ts
â”‚               â”‚   â””â”€â”€ grep.ts
â”‚               â”‚
â”‚               â”œâ”€â”€ bash/
â”‚               â”‚   â”œâ”€â”€ index.ts
â”‚               â”‚   â””â”€â”€ execute.ts
â”‚               â”‚
â”‚               â””â”€â”€ websearch/
â”‚                   â”œâ”€â”€ index.ts
â”‚                   â””â”€â”€ search.ts
â”‚
â”œâ”€â”€ access/
â”‚   â””â”€â”€ sdks/
â”‚       â”œâ”€â”€ anthropic/
â”‚       â”‚   â”œâ”€â”€ sdkAnthropic.ts
â”‚       â”‚   â””â”€â”€ sdkAnthropic.integration.test.ts
â”‚       â”‚
â”‚       â”œâ”€â”€ qwen/
â”‚       â”‚   â”œâ”€â”€ sdkQwen.ts
â”‚       â”‚   â””â”€â”€ sdkQwen.integration.test.ts
â”‚       â”‚
â”‚       â””â”€â”€ openai/
â”‚           â””â”€â”€ sdkOpenAi.ts  # already exists
â”‚
â””â”€â”€ roles/
    â””â”€â”€ bhrain/
        â”œâ”€â”€ getBhrainRole.ts
        â”œâ”€â”€ briefs/
        â”‚   â””â”€â”€ (trait briefs)
        â””â”€â”€ skills/
            â””â”€â”€ act/
                â”œâ”€â”€ skillAct.ts
                â””â”€â”€ stepAct.ts
```

---

## 1.1 architecture readme

`src/domain.operations/brain.replic.arch1/readme.md`:

```md
# brain.replic.arch1

this is the first brain architecture implemented - a replication of claude-code's agentic loop pattern.

## about

arch1 implements a single-threaded agentic loop:
- generate llm response
- check for tool calls
- execute tools (with permission checks)
- append results to context
- repeat until no tool calls

## future architectures

this likely won't be the last architecture. different brain architectures may be useful for different scenarios:

- **arch1** (this): single-threaded loop, claude-code style
- **arch2** (future): multi-agent orchestration, parallel tool execution
- **arch3** (future): tree-of-thought with backtracking
- etc.

## reuse strategy

for now, we keep things WET (write everything twice).

if patterns emerge that are shared across architectures, we'll lift them later into:
- `brain.replic.all/` - shared utilities across all architectures

but premature abstraction is worse than duplication. we wait until we have concrete evidence of reuse before extracting.
```

---

## 2. implementation phases

### phase 0: foundation (domain objects)

define all domain objects using `domain-objects` library.

**deliverables:**
- [ ] `BhrainAtom` - provider + model literal
- [ ] `BhrainContext` - runtime context with provider-keyed credentials
- [ ] `BhrainConfig` - root configuration entity
- [ ] `BhrainSession` - execution lifecycle entity
- [ ] `BhrainSessionMessage` - conversation unit literal
- [ ] `BhrainToolDefinition` - tool schema literal
- [ ] `BhrainToolCall` - tool invocation literal
- [ ] `BhrainToolResult` - tool response literal
- [ ] `BhrainToolBox` - tool container with execute function
- [ ] `BhrainMemoryTokenUsage` - token tracking literal
- [ ] `BhrainLoopIteration` - iteration state literal
- [ ] `BhrainLoopResult` - final result literal
- [ ] `BhrainPermissionDecision` - permission verdict literal
- [ ] `BhrainPermissionGuard` - guard interface literal
- [ ] `BhrainMemoryManager` - memory strategy interface literal
- [ ] `BhrainMemoryCompactionResult` - compaction output literal

**pattern:** follow existing `src/_topublish/*/domain/objects/*.ts` pattern

---

### phase 1: access layer (sdks)

implement llm provider sdks following the existing `sdkOpenAi.ts` pattern.

**deliverables:**
- [ ] `src/access/sdks/anthropic/sdkAnthropic.ts`
  - generates responses via anthropic sdk
  - handles tool_use content blocks
  - casts to BhrainSessionMessage
- [ ] `src/access/sdks/qwen/sdkQwen.ts`
  - generates responses via openai-compatible api
  - points to qwen endpoint via context.creds
- [ ] update `src/access/sdk/sdkOpenAi.ts`
  - add tool calling support
  - add streaming support (optional)

**pattern:**
```ts
// src/access/sdks/anthropic/sdkAnthropic.ts
import Anthropic from '@anthropic-ai/sdk';

export interface ContextAnthropic {
  anthropic: {
    auth: { key: string; url?: string };
    llm: { model: string };
  };
}

const generate = async (
  input: {
    messages: BhrainSessionMessage[];
    tools: BhrainToolDefinition[];
  },
  context: ContextAnthropic & ContextLogTrail,
): Promise<{
  message: BhrainSessionMessage;
  tokenUsage: BhrainMemoryTokenUsage;
}> => {
  // implementation
};

export const sdkAnthropic = { generate };
```

---

### phase 2: core operations

implement the agentic loop operations.

**deliverables:**

#### 2.1 generateBhrainLlmResponse
- [ ] `src/domain.operations/bhrainLlm/generateBhrainLlmResponse.ts`
- routes to appropriate sdk based on `BhrainAtom.provider`
- merges tool definitions from all toolboxes
- returns `BhrainSessionMessage` + `BhrainMemoryTokenUsage`

```ts
/**
 * .what = generate llm response, routing to appropriate provider sdk
 * .why = unified interface for all llm atoms
 */
export const generateBhrainLlmResponse = async (
  input: {
    atom: BhrainAtom;
    messages: BhrainSessionMessage[];
    tools: BhrainToolDefinition[];
  },
  context: BhrainContext,
): Promise<{
  message: BhrainSessionMessage;
  tokenUsage: BhrainMemoryTokenUsage;
}> => {
  // route by provider
  if (input.atom.provider === 'anthropic')
    return sdkAnthropic.generate({ ... }, context);
  if (input.atom.provider === 'qwen')
    return sdkQwen.generate({ ... }, context);
  if (input.atom.provider === 'openai')
    return sdkOpenAi.generate({ ... }, context);

  throw new UnexpectedCodePathError('unknown provider', { atom: input.atom });
};
```

#### 2.2 executeBhrainToolCall
- [ ] `src/domain.operations/bhrainTool/executeBhrainToolCall.ts`
- checks permission guard first
- finds tool in toolboxes
- executes and returns result

#### 2.3 iterateBhrainLoop
- [ ] `src/domain.operations/bhrainLoop/iterateBhrainLoop.ts`
- one cycle: generate -> execute tools -> collect results
- returns new messages + iteration metadata

#### 2.4 runBhrainLoop
- [ ] `src/domain.operations/bhrainLoop/runBhrainLoop.ts`
- orchestrates iterations until completion
- checks max iterations
- invokes memory manager between iterations
- returns `BhrainLoopResult`

#### 2.5 invokeBhrain
- [ ] `src/domain.operations/brain.replic.arch1/core/invokeBhrain.ts`
- creates session
- builds initial messages
- calls runBhrainLoop

---

### phase 3: plugins

implement default plugins.

#### 3.1 toolboxes

**files toolbox:**
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/files/read.ts` - read file contents
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/files/write.ts` - write file contents
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/files/edit.ts` - replace text in file
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/files/glob.ts` - find files by pattern
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/files/grep.ts` - search file contents
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/files/index.ts` - exports BhrainToolBox

**bash toolbox:**
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/bash/execute.ts` - execute shell command
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/bash/index.ts` - exports BhrainToolBox

**websearch toolbox:**
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/websearch/search.ts` - search web
- [ ] `src/domain.operations/brain.replic.arch1/plugins/toolBoxes/websearch/index.ts` - exports BhrainToolBox

**pattern:**
```ts
// src/domain.operations/brain.replic.arch1/plugins/toolBoxes/files/index.ts
import { BhrainToolBox, BhrainToolDefinition, BhrainToolCall, BhrainToolResult } from '@/domain.objects';

const definitions: BhrainToolDefinition[] = [
  new BhrainToolDefinition({
    name: 'read',
    description: 'read file contents from disk',
    inputSchema: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'absolute file path' },
      },
      required: ['path'],
    },
    strict: false,
  }),
  // ... other tool definitions
];

const execute = async (
  input: { call: BhrainToolCall },
  context: BhrainContext,
): Promise<BhrainToolResult> => {
  // route to appropriate handler
};

export const toolBoxFiles = new BhrainToolBox({
  name: 'files',
  definitions,
  execute,
});
```

#### 3.2 memory managers

- [ ] `src/domain.operations/brain.replic.arch1/plugins/memoryManagers/summarizeOnLimit.ts`
  - summarizes when context approaches limit
  - uses llm for summarization
- [ ] `src/domain.operations/brain.replic.arch1/plugins/memoryManagers/truncate.ts`
  - drops oldest messages
  - no llm call, fast compaction

#### 3.3 permission guards

- [ ] `src/domain.operations/brain.replic.arch1/plugins/permissionGuards/allowAll.ts` - permits everything (dev)
- [ ] `src/domain.operations/brain.replic.arch1/plugins/permissionGuards/promptForWrites.ts` - prompts for write ops
- [ ] `src/domain.operations/brain.replic.arch1/plugins/permissionGuards/denyDangerous.ts` - blocks dangerous patterns

---

### phase 4: rhachet integration

integrate with rhachet's role/skill system.

**deliverables:**

#### 4.1 role definition
- [ ] `src/roles/bhrain/getBhrainRole.ts`

```ts
import { Role, RoleTrait } from 'rhachet';
import { SKILL_ACT } from './skills/act/skillAct';

export const ROLE_BHRAIN: Role = Role.build({
  slug: 'bhrain',
  name: 'Bhrain',
  purpose: 'agentic tool-using brain',
  readme: `
## ðŸ§  Bhrain

replicable brain structure for agentic tool-using llm workflows
  `.trim(),
  traits: [],
  skills: {
    dirs: [],
    refs: [SKILL_ACT],
  },
  briefs: {
    dirs: [{ uri: __dirname + '/briefs' }],
  },
});
```

#### 4.2 skill definition
- [ ] `src/roles/bhrain/skills/act/skillAct.ts`

```ts
import { genRoleSkill, enrollThread, genContextStitchTrail } from 'rhachet';
import { genArtifactGitFile } from 'rhachet-artifact-git';
import { stepAct } from './stepAct';

export const SKILL_ACT = genRoleSkill({
  slug: 'act',
  route: stepAct,
  threads: {
    lookup: {
      arch: {
        source: 'process.argv',
        char: 'a',
        desc: 'brain architecture (e.g., bhrain.struct.v1)',
        type: 'string',
      },
      atom: {
        source: 'process.argv',
        char: 't',
        desc: 'llm atom (e.g., claude, qwen)',
        type: 'string',
      },
      input: {
        source: 'process.argv',
        char: 'i',
        desc: 'user input/prompt',
        type: 'string',
      },
    },
    assess: (input): input is { arch: string; atom: string; input: string } =>
      typeof input.arch === 'string' &&
      typeof input.atom === 'string' &&
      typeof input.input === 'string',
    instantiate: async (input) => ({
      caller: await enrollThread({
        role: 'caller',
        stash: { ask: input.input },
      }),
      brain: await enrollThread({
        role: 'bhrain',
        stash: {
          config: {
            arch: input.arch,
            atom: input.atom,
          },
        },
      }),
    }),
  },
  context: {
    lookup: {
      anthropicApiKey: {
        source: 'process.env',
        envar: 'ANTHROPIC_API_KEY',
        desc: 'anthropic api key',
        type: '?string',
      },
      openaiApiKey: {
        source: 'process.env',
        envar: 'OPENAI_API_KEY',
        desc: 'openai api key',
        type: '?string',
      },
      qwenApiKey: {
        source: 'process.env',
        envar: 'QWEN_API_KEY',
        desc: 'qwen api key',
        type: '?string',
      },
      qwenApiUrl: {
        source: 'process.env',
        envar: 'QWEN_API_URL',
        desc: 'qwen api url',
        type: '?string',
      },
    },
    assess: (input): input is Record<string, string | undefined> => true,
    instantiate: (input) => ({
      creds: {
        anthropic: { apiKey: input.anthropicApiKey ?? '', url: null },
        openai: { apiKey: input.openaiApiKey ?? '', url: null },
        qwen: { apiKey: input.qwenApiKey ?? '', url: input.qwenApiUrl ?? null },
      },
      log: console,
    }),
  },
  readme: 'invoke bhrain to act on a prompt',
});
```

#### 4.3 step implementation
- [ ] `src/roles/bhrain/skills/act/stepAct.ts`

```ts
import { asStitcherFlat, genStitchRoute, type GStitcher } from 'rhachet';
import { invokeBhrain } from '@/domain.operations/brain.replic.arch1/core/invokeBhrain';

// the stitcher that invokes the brain
export const stepAct = asStitcherFlat<StitcherDesired>(
  genStitchRoute({
    slug: '@[bhrain]<act>',
    readme: 'invoke bhrain and run agentic loop',
    sequence: [
      {
        slug: 'invoke',
        readme: 'invoke brain',
        enweave: async ({ threads }, context) => {
          const result = await invokeBhrain(
            {
              config: buildBhrainConfig(threads.brain.context.stash.config),
              prompt: threads.caller.context.stash.ask,
            },
            context,
          );
          return {
            threads,
            output: { result },
          };
        },
      },
    ],
  }),
);
```

#### 4.4 registry integration
- [ ] update `src/roles/getRoleRegistry.ts` to export bhrain role
- [ ] update `rhachet.use.ts` to include bhrain role registry

---

## 3. testing strategy

**everything must be test covered. no exceptions.**

### 3.0 coverage requirements

| boundary type | test type | requirement |
|---------------|-----------|-------------|
| domain logic (transforms, decisions) | unit test | mandatory |
| external system (llm apis, os, filesystem) | integration test | mandatory |
| end-to-end behavior | integration test | mandatory |
| cli invocation | acceptance test | mandatory |

### 3.1 unit tests

test all domain logic in isolation (mocked dependencies):

- `mergeBhrainToolBoxes.test.ts` - tool merging logic
- `iterateBhrainLoop.test.ts` - single iteration with mocked llm
- `executeBhrainToolCall.test.ts` - tool execution with mocked toolbox
- `checkBhrainPermission.test.ts` - permission guard logic
- `compactBhrainMemory.test.ts` - memory compaction decisions
- `truncateBhrainMessages.test.ts` - message truncation logic
- `summarizeBhrainMessages.test.ts` - summarization transforms

### 3.2 integration tests

test all boundaries with external systems (real dependencies):

**llm provider boundaries:**
- `sdkAnthropic.integration.test.ts` - anthropic api calls
- `sdkQwen.integration.test.ts` - qwen api calls
- `sdkOpenAi.integration.test.ts` - openai api calls

**os/filesystem boundaries:**
- `toolBoxFiles.integration.test.ts` - file read/write/edit/glob/grep
- `toolBoxBash.integration.test.ts` - shell command execution

**network boundaries:**
- `toolBoxWebsearch.integration.test.ts` - web search api

**end-to-end behaviors:**
- `invokeBhrain.integration.test.ts` - full loop execution
- `runBhrainLoop.integration.test.ts` - loop with real tools
- `spawnBhrainSubagent.integration.test.ts` - subagent spawning

### 3.3 acceptance tests

test cli invocation (black box):
- `skillAct.acceptance.test.ts` - full end-to-end test via cli

**pattern:**
```ts
// src/domain.operations/brain.replic.arch1/core/invokeBhrain.integration.test.ts
import { given, when, then, useBeforeAll } from 'test-fns';
import { invokeBhrain } from './invokeBhrain';

describe('invokeBhrain', () => {
  given('[case1] simple prompt with no tools', () => {
    when('[t0] invoked with a greeting', () => {
      then('returns a text response', async () => {
        const result = await invokeBhrain(
          {
            config: buildTestConfig({ toolBoxes: [] }),
            prompt: 'say hello',
          },
          buildTestContext(),
        );
        expect(result.terminationReason).toEqual('NATURAL_COMPLETION');
        expect(result.finalResponse).toBeTruthy();
      });
    });
  });

  given('[case2] prompt requiring tool use', () => {
    when('[t0] invoked with a file read request', () => {
      then('executes the tool and returns result', async () => {
        const result = await invokeBhrain(
          {
            config: buildTestConfig({ toolBoxes: [toolBoxFiles] }),
            prompt: 'read the file at /tmp/test.txt',
          },
          buildTestContext(),
        );
        expect(result.session.iterationCount).toBeGreaterThan(1);
      });
    });
  });
});
```

---

## 4. dependencies

### 4.1 existing
- `domain-objects` - domain object patterns
- `rhachet` - role/skill framework
- `rhachet-artifact-git` - file artifacts
- `openai` - openai sdk (already used)
- `helpful-errors` - error handling
- `wrapper-fns` - withRetry, withTimeout

### 4.2 new
- `@anthropic-ai/sdk` - anthropic api client

### 4.3 optional
- `tavily-js` - web search api (for websearch toolbox)

---

## 5. configuration

### 5.1 environment variables

```sh
# llm provider credentials
ANTHROPIC_API_KEY=sk-ant-...
OPENAI_API_KEY=sk-...
QWEN_API_KEY=...
QWEN_API_URL=https://dashscope.aliyuncs.com/compatible-mode/v1

# optional: default llm settings
BHRAIN_DEFAULT_ATOM=claude
BHRAIN_MAX_ITERATIONS=100
```

### 5.2 default config

```ts
const DEFAULT_BHRAIN_CONFIG: Partial<BhrainConfig> = {
  maxIterations: 100,
  toolBoxes: [toolBoxFiles, toolBoxBash],
  memoryManager: summarizeOnLimit,
  permissionGuard: promptForWrites,
  systemPrompt: null,
};
```

---

## 6. milestone checklist

### mvp (minimum viable product)

- [ ] domain objects (phase 0)
- [ ] anthropic sdk (phase 1)
- [ ] core operations (phase 2)
- [ ] files toolbox (phase 3.1)
- [ ] allowAll permission guard (phase 3.3)
- [ ] basic tests

### v1.0

- [ ] all sdks (phase 1)
- [ ] all toolboxes (phase 3.1)
- [ ] memory managers (phase 3.2)
- [ ] permission guards (phase 3.3)
- [ ] rhachet integration (phase 4)
- [ ] full test coverage

### future

- [ ] streaming responses
- [ ] subagent spawning
- [ ] externalized memory (virtual context)
- [ ] mcp server support
- [ ] hooks integration

---

## 7. risks and mitigations

| risk | mitigation |
|------|------------|
| llm response format varies by provider | normalize in sdk layer, test extensively |
| tool definition compatibility | use openai-style json schema, adapt per provider |
| context window overflow | test memory manager at boundaries |
| permission prompts in ci | use allowAll guard in test context |
| qwen api compatibility | use openai-compatible endpoint, test early |

---

## 8. references

- distillation: `3.2.distill.domain._.v1.i1.md`
- research: `3.1.research.domain._.v1.i1.md`
- criteria: `2.criteria.md`
- wish: `0.wish.md`
- vision: `1.vision.md`
