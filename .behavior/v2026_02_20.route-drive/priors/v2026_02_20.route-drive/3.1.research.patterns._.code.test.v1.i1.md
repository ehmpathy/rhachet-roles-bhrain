# research: test code patterns for route.drive

## overview

this document identifies test code patterns in this repo relevant to route.drive implementation. each pattern is marked as [REUSE], [EXTEND], or [REPLACE] based on how it relates to the wish.

---

## pattern 1: given/when/then from test-fns

**[REUSE]**

tests use `given`, `when`, `then` from `test-fns` for BDD-style structure.

> src/domain.operations/behavior/bind/setBranchBehaviorBind.test.ts:1-20
> ```typescript
> import { given, then, when } from 'test-fns';
>
> describe('setBranchBehaviorBind', () => {
>   given('[case1] protected branch names', () => {
>     when('[t0] branchName is main', () => {
>       then('throws BadRequestError', async () => {
>         const error = await getError(
>           setBranchBehaviorBind({ branchName: 'main', behaviorDir: '/tmp/test' }),
>         );
>         expect(error).toBeInstanceOf(BadRequestError);
>       });
>     });
>   });
> });
> ```

**relevance to wish**: route.drive tests will follow this same BDD structure with `[caseN]` and `[tN]` labels.

---

## pattern 2: useBeforeAll for shared setup

**[REUSE]**

integration tests use `useBeforeAll` to share expensive setup across multiple `then` blocks.

> src/domain.operations/behavior/feedback/giveFeedback.integration.test.ts:15-35
> ```typescript
> given('[case1] behavior with execution artifact', () => {
>   const scene = useBeforeAll(async () => {
>     const testDir = mkdtempSync(join(tmpdir(), 'test-feedback-'));
>     const behaviorDir = join(testDir, '.behavior', 'v2026_test');
>     mkdirSync(behaviorDir, { recursive: true });
>     // ... setup git repo, behavior files
>     return { testDir, behaviorDir };
>   });
>
>   afterAll(() => {
>     rmSync(scene.testDir, { recursive: true, force: true });
>   });
>
>   when('[t0] giveFeedback invoked', () => {
>     then('feedback file is created', async () => {
>       // test assertions
>     });
>   });
> });
> ```

**relevance to wish**: route.drive integration tests will use `useBeforeAll` to set up test repos with bound routes and stones.

---

## pattern 3: temp directory with cleanup

**[REUSE]**

tests create temp directories via `mkdtempSync` and clean up via `afterAll`.

> src/domain.operations/behavior/feedback/giveFeedback.integration.test.ts:16-28
> ```typescript
> const scene = useBeforeAll(async () => {
>   const testDir = mkdtempSync(join(tmpdir(), 'test-feedback-'));
>   // ... setup
>   return { testDir, behaviorDir };
> });
>
> afterAll(() => {
>   rmSync(scene.testDir, { recursive: true, force: true });
> });
> ```

**relevance to wish**: route.drive tests need temp repos for stone enumeration, promise track, and bind detection.

---

## pattern 4: simple describe/test for unit tests

**[REUSE]**

simpler unit tests use plain `describe`/`test` without given/when/then.

> src/domain.operations/behavior/bind/getBranchBehaviorBind.test.ts:5-15
> ```typescript
> describe('getBranchBehaviorBind', () => {
>   describe('given a repo with a bound behavior', () => {
>     test('returns the behavior directory for a bound branch', () => {
>       const result = getBranchBehaviorBind(
>         { branchName: 'vlad.route-drive' },
>         { cwd: process.cwd() },
>       );
>       expect(result.behaviorDir).toContain('.behavior/v2026_02_20.route-drive');
>     });
>   });
> });
> ```

**relevance to wish**: pure functions like `parseStoneYamlFrontmatter` can use this simpler pattern.

---

## pattern 5: getError for exception tests

**[REUSE]**

tests use `getError` utility to catch and assert on thrown errors.

> src/domain.operations/behavior/bind/setBranchBehaviorBind.test.ts:12-17
> ```typescript
> then('throws BadRequestError', async () => {
>   const error = await getError(
>     setBranchBehaviorBind({ branchName: 'main', behaviorDir: '/tmp/test' }),
>   );
>   expect(error).toBeInstanceOf(BadRequestError);
>   expect(error.message).toContain('protected branch');
> });
> ```

**relevance to wish**: route.stone.set tests need to verify errors for invalid slugs, protected branches, etc.

---

## pattern 6: snapshot tests for output verification

**[REUSE]**

tests use `toMatchSnapshot()` to verify complex output artifacts.

> inferred from briefs and jest config
> ```typescript
> then('output matches snapshot', () => {
>   const result = generateOutput(input);
>   expect(result).toMatchSnapshot();
> });
> ```

**relevance to wish**: route.drive output (tree structure with owl emoji) should have snapshot tests to verify format.

---

## pattern 7: acceptance test infrastructure

**[EXTEND]**

acceptance tests use `runRhachetSkill` utility for blackbox tests.

> blackbox/.test/infra/runRhachetSkill.ts:10-25
> ```typescript
> export const runRhachetSkill = (input: {
>   repo: string;
>   role?: string;
>   skill: string;
>   args?: string;
>   repoDir: string;
> }): SkillResult => {
>   const roleFlag = input.role ? `--role ${input.role}` : '';
>   const args = input.args ?? '';
>   const result = execSync(
>     `npx rhachet run --repo ${input.repo} ${roleFlag} --skill ${input.skill} ${args}`,
>     { cwd: input.repoDir, encoding: 'utf-8' },
>   );
>   return { stdout: result };
> };
> ```

**relevance to wish**: new acceptance tests needed for `route.drive`, `route.stone.get`, `route.stone.set` skills.

---

## pattern 8: genConsumerRepo fixture

**[REUSE]**

acceptance tests use `genConsumerRepo` to create isolated test repos.

> blackbox/.test/fixtures/genConsumerRepo.ts (referenced)
> ```typescript
> export const genConsumerRepo = async (): Promise<{
>   repoDir: string;
>   cleanup: () => void;
> }> => {
>   // creates temp repo with rhachet installed
>   // returns cleanup function
> };
> ```

**relevance to wish**: route.drive acceptance tests will use this to create repos with bound routes and test the full skill flow.

---

## pattern 9: genBehaviorFixture

**[EXTEND]**

acceptance tests can use fixtures to create behavior directories with known state.

> blackbox/role=behaver/skill.bind.behavior.acceptance.test.ts:20-30 (inferred)
> ```typescript
> const genBehaviorFixture = async (repoDir: string) => {
>   const behaviorDir = join(repoDir, '.behavior', 'v2026_test');
>   mkdirSync(behaviorDir, { recursive: true });
>   writeFileSync(join(behaviorDir, '0.wish.md'), '# test wish');
>   // ... create stone files
>   return behaviorDir;
> };
> ```

**relevance to wish**: need fixtures that create:
- behavior directories with stone files
- stones with yaml frontmatter that has `guard.review.self`
- `.bind/` flag files
- `.guard/` promise artifacts

---

## pattern 10: direct bash invocation vs rhachet dispatch

**[REUSE]**

acceptance tests can invoke skills both via rhachet and directly via bash.

> blackbox/role=behaver/skill.bind.behavior.acceptance.test.ts:50-70 (inferred)
> ```typescript
> // via rhachet (consumer perspective)
> runRhachetSkill({
>   repo: 'bhuild',
>   role: 'behaver',
>   skill: 'bind.behavior',
>   args: `--behavior ${behaviorDir}`,
>   repoDir: consumerRepo.repoDir,
> });
>
> // via direct bash (integration perspective)
> execSync(`bash ${skillPath} --behavior ${behaviorDir}`, {
>   cwd: consumerRepo.repoDir,
> });
> ```

**relevance to wish**: route.drive tests should verify both invocation paths work identically.

---

## pattern 11: jest config separation

**[REUSE]**

unit and integration tests have separate jest configs.

> jest.unit.config.ts / jest.integration.config.ts
> ```typescript
> // unit tests exclude .integration.test.ts
> // integration tests include only .integration.test.ts
> ```

**relevance to wish**: new tests will follow name convention:
- `*.test.ts` for unit tests
- `*.integration.test.ts` for integration tests
- `*.acceptance.test.ts` for blackbox tests

---

## pattern 12: collocated test files

**[REUSE]**

test files are collocated with implementation files.

> ```
> src/domain.operations/behavior/bind/
>   ├─ getBranchBehaviorBind.ts
>   ├─ getBranchBehaviorBind.test.ts
>   ├─ setBranchBehaviorBind.ts
>   └─ setBranchBehaviorBind.integration.test.ts
> ```

**relevance to wish**: new operations will have collocated tests:
- `getStoneByRoute.ts` + `getStoneByRoute.test.ts`
- `setStoneStatus.ts` + `setStoneStatus.integration.test.ts`

---

## summary: pattern disposition

| pattern | action | reason |
|---------|--------|--------|
| given/when/then | [REUSE] | standard BDD structure |
| useBeforeAll | [REUSE] | shared setup for integration tests |
| temp directory cleanup | [REUSE] | isolated test environments |
| simple describe/test | [REUSE] | pure function unit tests |
| getError | [REUSE] | exception tests |
| snapshot tests | [REUSE] | output format verification |
| runRhachetSkill | [EXTEND] | add route.* skill tests |
| genConsumerRepo | [REUSE] | isolated consumer repo |
| genBehaviorFixture | [EXTEND] | add stone + guard fixtures |
| dual invocation paths | [REUSE] | verify bash + rhachet |
| jest config separation | [REUSE] | unit vs integration |
| collocated test files | [REUSE] | test proximity |

---

## key test files to create

based on pattern analysis:

### unit tests
- `src/domain.operations/route/getStoneByRoute.test.ts`
- `src/domain.operations/route/getAllStonesByRoute.test.ts`
- `src/domain.operations/route/parseStoneYamlFrontmatter.test.ts`
- `src/domain.operations/route/getStonePromises.test.ts`

### integration tests
- `src/domain.operations/route/setStoneStatus.integration.test.ts`
- `src/domain.operations/route/setStonePromise.integration.test.ts`
- `src/contract/cli/route.drive.integration.test.ts`
- `src/contract/cli/route.stone.set.integration.test.ts`

### acceptance tests
- `blackbox/role=behaver/skill.route.drive.acceptance.test.ts`
- `blackbox/role=behaver/skill.route.stone.get.acceptance.test.ts`
- `blackbox/role=behaver/skill.route.stone.set.acceptance.test.ts`

### test fixtures needed
- `genStoneFixture` — creates stone file with optional yaml frontmatter
- `genRouteFixture` — creates full route with multiple stones
- `genPromiseArtifact` — creates promise file in `.guard/` directory
- `genBoundRouteFixture` — creates route + bind + optional promises

---

## citations

1. src/domain.operations/behavior/bind/setBranchBehaviorBind.test.ts — BDD pattern with given/when/then
2. src/domain.operations/behavior/feedback/giveFeedback.integration.test.ts — useBeforeAll + temp cleanup
3. src/domain.operations/behavior/bind/getBranchBehaviorBind.test.ts — simple describe/test pattern
4. blackbox/.test/infra/runRhachetSkill.ts — acceptance test utility
5. blackbox/role=behaver/skill.bind.behavior.acceptance.test.ts — full acceptance test example
6. jest.unit.config.ts — unit test configuration
7. jest.integration.config.ts — integration test configuration
