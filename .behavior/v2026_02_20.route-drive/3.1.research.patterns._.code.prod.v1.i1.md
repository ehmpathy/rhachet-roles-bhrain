# research: production code patterns for route.drive

## pattern 1: guard file parsing

**[EXTEND]**

the current `parseStoneGuard` parses flat arrays for reviews and judges.

**citation 1** - `src/domain.operations/route/guard/parseStoneGuard.ts:31-78`
```ts
const parseSimpleYaml = (
  content: string,
): {
  artifacts?: string[];
  reviews?: string[];
  judges?: string[];
} => {
  // ...
  if (trimmed === 'reviews:') {
    currentKey = 'reviews';
    result.reviews = [];
    continue;
  }
  // ...
  if (trimmed.startsWith('- ') && currentKey) {
    const value = trimmed.slice(2).trim();
    result[currentKey]?.push(value);
  }
```

**relation to wish**: needs extension to support structured `reviews: { self: [...], peer: [...] }` format alongside flat array (backwards compatible).

---

## pattern 2: RouteStoneGuard domain object

**[EXTEND]**

the current guard object stores reviews as flat string array.

**citation 2** - `src/domain.objects/Driver/RouteStoneGuard.ts:7-31`
```ts
export interface RouteStoneGuard {
  path: string;
  artifacts: string[];
  reviews: string[];
  judges: string[];
}
```

**relation to wish**: needs extension to support `reviews.self` (array of `{slug, say}`) and `reviews.peer` (array of shell commands). flat array = reviews.peer for backwards compat.

---

## pattern 3: stepRouteStoneSet orchestration

**[EXTEND]**

current flow: find stone â†’ check artifacts â†’ run reviews â†’ run judges â†’ emit result.

**citation 3** - `src/domain.operations/route/stones/setStoneAsPassed.ts:23-50`
```ts
export const setStoneAsPassed = async (
  input: {
    stone: string;
    route: string;
  },
  context: ContextCliEmit,
): Promise<{
  passed: boolean;
  refs: { reviews: string[]; judges: string[] };
  emit: { stdout: string } | null;
}> => {
  // find the stone
  const stones = await getAllStones({ route: input.route });
  const stoneMatched = findStoneByGlob(stones, input.stone);
  // ...
```

**citation 4** - `src/domain.operations/route/stones/setStoneAsPassed.ts:144-157`
```ts
  // run reviews (reuses prior artifacts internally, only runs incomplete ones)
  const reviewArtifacts =
    stoneMatched.guard.reviews.length > 0
      ? await runStoneGuardReviews(
          {
            stone: stoneMatched,
            guard: stoneMatched.guard,
            hash,
            iteration,
            route: input.route,
          },
          collectContext,
        )
      : [];
```

**relation to wish**: needs extension to check self-review promises before proceeding to peer reviews. new flow: check promises â†’ if unpromised, emit check yo'self â†’ else proceed to peer reviews.

---

## pattern 4: stepRouteStoneSet input handling

**[EXTEND]**

current `--as` accepts `passed` or `approved`. need to add `--as promised --that $slug`.

**citation 5** - `src/domain.operations/route/stepRouteStoneSet.ts:12-53`
```ts
export const stepRouteStoneSet = async (
  input: {
    stone: string;
    route: string;
    as: 'passed' | 'approved';
  },
  context: ContextCliEmit,
): Promise<{
  passed?: boolean;
  approved?: boolean;
  refs?: { reviews: string[]; judges: string[] };
  emit: { stdout: string } | null;
}> => {
  // dispatch to appropriate operation
  if (input.as === 'approved') {
    // ...
  }
  if (input.as === 'passed') {
    // ...
  }
```

**relation to wish**: extend to handle `as: 'promised'` with `that: string` for self-review promise recording.

---

## pattern 5: formatRouteStoneEmit tree structure

**[REUSE]**

current emit formatting uses tree structure with unicode box-draw characters.

**citation 6** - `src/domain.operations/route/formatRouteStoneEmit.ts:8-11`
```ts
const HEADER_GET = 'ðŸ¦‰ and then?';
const HEADER_SET = `ðŸ¦‰ so you're saying there's a chance?`;
const HEADER_DEL = `ðŸ¦‰ hoo needs 'em`;
```

**citation 7** - `src/domain.operations/route/formatRouteStoneEmit.ts:98-128`
```ts
  if (input.operation === 'route.stone.set') {
    // delegate to formatGuardTree for full guard tree output
    if (input.action === 'passed' && input.guard) {
      const tree = formatGuardTree({
        stone: input.stone,
        passage: input.passage,
        note: input.note ?? null,
        reason: input.reason ?? null,
        guard: input.guard,
      });
      return [header, '', tree].join('\n');
    }

    lines.push(`ðŸ—¿ ${input.operation}`);
    lines.push(`   â”œâ”€ stone = ${input.stone}`);
    // ...
    const passageValue = input.note
      ? `${input.passage} (${input.note})`
      : input.passage;
```

**relation to wish**: reuse tree structure and headers. add new `check yo'self` section before guard tree.

---

## pattern 6: formatGuardTree sections

**[EXTEND]**

guard tree formats artifacts, reviews, judges sections.

**citation 8** - `src/domain.operations/route/guard/formatGuardTree.ts:62-71`
```ts
  // guard section
  const hasReviews = input.guard.reviews.length > 0;
  const hasJudges = input.guard.judges.length > 0;

  lines.push(`   â””â”€ guard`);

  // determine which sub-sections are last for correct box-draw
  const sections: Array<{ type: 'artifacts' | 'reviews' | 'judges' }> = [];
  sections.push({ type: 'artifacts' });
  if (hasReviews) sections.push({ type: 'reviews' });
  if (hasJudges) sections.push({ type: 'judges' });
```

**relation to wish**: need new `formatCheckYoself` section that shows before guard tree when self-reviews are unpromised.

---

## pattern 7: review artifact persistence

**[REUSE]**

review artifacts stored in `.route/` with naming convention that includes hash.

**citation 9** - `src/domain.objects/Driver/RouteStoneGuardReviewArtifact.ts:9-44`
```ts
export interface RouteStoneGuardReviewArtifact {
  stone: RefByUnique<typeof RouteStone>;
  hash: string;
  iteration: number;
  index: number;
  path: string;
  blockers: number;
  nitpicks: number;
}
```

**citation 10** - `src/contract/cli/route.ts:513-519`
```ts
  // find review files for this stone and hash
  const routeDir = path.join(input.route, '.route');
  const reviewGlob = `${input.stone}.guard.review.*.${hash}.*.md`;

  const reviewFiles = await enumFilesFromGlob({
    glob: reviewGlob,
    cwd: routeDir,
  });
```

**relation to wish**: reuse pattern for promise artifacts. naming: `$stone.guard.promise.$slug.$hash.md`

---

## pattern 8: hash computation for invalidation

**[REUSE]**

artifact content hash computed for cache lookup and invalidation.

**citation 11** - `src/domain.operations/route/guard/computeStoneReviewInputHash.ts:15-39`
```ts
export const computeStoneReviewInputHash = async (input: {
  stone: RouteStone;
  route: string;
}): Promise<string> => {
  // get all artifact files via the reusable operation
  const allFiles = await getAllStoneArtifacts(input);
  // ...
  // compute hash
  const concatenated = contents.join('\n');
  return crypto.createHash('sha256').update(concatenated).digest('hex');
};
```

**relation to wish**: reuse for promise hash validation. promise is valid iff current hash matches promise hash.

---

## pattern 9: route bind persistence

**[REUSE]**

route binding stored via flag file in `.route/` directory.

**citation 12** - `src/domain.operations/route/bind/setRouteBind.ts:69-80`
```ts
  // ensure .route/ directory found
  const routeStateDir = path.join(routeAbsolute, '.route');
  await fs.mkdir(routeStateDir, { recursive: true });

  // write flag file
  const flagFileName = `.bind.${branchFlat}.flag`;
  const flagPath = path.join(routeStateDir, flagFileName);
  const flagContent = `branch: ${branch}\nbound_by: route.bind skill\n`;
  await fs.writeFile(flagPath, flagContent);
```

**relation to wish**: reuse `.route/` directory for promise artifacts.

---

## pattern 10: role definition with hooks

**[EXTEND]**

current driver role has no hooks defined.

**citation 13** - `src/domain.roles/driver/getDriverRole.ts:7-20`
```ts
export const ROLE_DRIVER: Role = Role.build({
  slug: 'driver',
  name: 'Driver',
  purpose: 'navigate thought routes via stone milestones',
  readme: { uri: __dirname + '/readme.md' },
  traits: [],
  skills: {
    dirs: [{ uri: __dirname + '/skills' }],
    refs: [],
  },
  briefs: {
    dirs: [{ uri: __dirname + '/briefs' }],
  },
});
```

**citation 14** - `node_modules/rhachet/dist/domain.objects/RoleHooksOnBrain.d.ts:7-11`
```ts
export interface RoleHooksOnBrain {
    onBoot?: RoleHookOnBrain[];
    onTool?: RoleHookOnBrain[];
    onStop?: RoleHookOnBrain[];
}
```

**citation 15** - `node_modules/rhachet/dist/domain.objects/RoleHookOnBrain.d.ts:10-14`
```ts
export interface RoleHookOnBrain {
    command: string;
    timeout: IsoDuration;
    filter?: BrainHookFilter;
}
```

**relation to wish**: extend driver role with `hooks.onBrain.onStop` and `hooks.onBrain.onBoot` that fire `rhx route.drive`.

---

## pattern 11: cli entrypoint structure

**[REUSE]**

cli entrypoints follow consistent pattern: parseArgs â†’ validate â†’ dispatch â†’ emit.

**citation 16** - `src/contract/cli/route.ts:283-343`
```ts
export const routeStoneSet = async (): Promise<void> => {
  const options = parseArgs(process.argv);

  if (options.help) {
    printSetHelp();
    return;
  }

  if (!options.stone) {
    console.error('error: --stone is required');
    // ...
  }
  if (!options.route) {
    const routeFromBind = await lookupRouteFromBind();
    // ...
  }
  // ...
  try {
    const result = await stepRouteStoneSet(
      { stone: options.stone, route: options.route, as: options.as },
      progress.context,
    );
    // ...
  } catch (error) {
    // ...
  }
};
```

**relation to wish**: reuse pattern for `route.drive` cli entrypoint. add to cli.route namespace.

---

## pattern 12: shell skill entrypoint

**[REUSE]**

shell skills use package-level import for fast startup.

**citation 17** - `src/domain.roles/driver/skills/route.stone.set.sh:17-19`
```sh
set -euo pipefail

exec node -e "import('rhachet-roles-bhrain/cli').then(m => m.cli.route.stone.set())" -- "$@"
```

**relation to wish**: reuse pattern for `route.drive.sh` skill.

---

## pattern 13: lookupRouteFromBind auto-fallback

**[REUSE]**

route commands auto-lookup `--route` from bind when absent.

**citation 18** - `src/contract/cli/route.ts:224-228`
```ts
const lookupRouteFromBind = async (): Promise<string | null> => {
  const bind = await getRouteBindByBranch({ branch: null });
  if (bind) return bind.route;
  return null;
};
```

**relation to wish**: reuse for route.drive. if no bind, silent no-op (per criteria).

---

## pattern 14: stepRouteStoneGet for next stone

**[REUSE]**

extant operation fetches next stone(s) and formats output.

**citation 19** - `src/domain.operations/route/stepRouteStoneGet.ts:15-22`
```ts
export const stepRouteStoneGet = async (input: {
  stone: '@next-one' | '@next-all' | string;
  route: string;
  say?: boolean;
}): Promise<{
  stones: RouteStone[];
  emit: { stdout: string } | null;
}> => {
```

**citation 20** - `src/domain.operations/route/stepRouteStoneGet.ts:60-67`
```ts
  } else if (input.say) {
    // read stone file content(s) and emit
    const contents: string[] = [];
    for (const stone of stonesResult) {
      const content = await fs.readFile(stone.path, 'utf-8');
      contents.push(`# ${stone.name}\n\n${content}`);
    }
    emit = { stdout: contents.join('\n\n---\n\n') };
```

**relation to wish**: reuse `computeNextStones` and stone content reading for route.drive output.

---

## summary

| pattern | disposition | reason |
|---------|-------------|--------|
| parseStoneGuard | [EXTEND] | add structured reviews parsing |
| RouteStoneGuard | [EXTEND] | add reviews.self and reviews.peer |
| setStoneAsPassed | [EXTEND] | add self-review promise check |
| stepRouteStoneSet | [EXTEND] | add `--as promised --that $slug` |
| formatRouteStoneEmit | [REUSE] | tree structure, headers |
| formatGuardTree | [EXTEND] | add check yo'self section |
| review artifact persistence | [REUSE] | pattern for promise artifacts |
| computeStoneReviewInputHash | [REUSE] | hash invalidation |
| route bind persistence | [REUSE] | .route/ directory |
| driver role | [EXTEND] | add onStop/onBoot hooks |
| cli entrypoint | [REUSE] | pattern for route.drive |
| shell skill entrypoint | [REUSE] | pattern for route.drive.sh |
| lookupRouteFromBind | [REUSE] | auto-fallback |
| stepRouteStoneGet | [REUSE] | next stone logic |

---

## new components needed

1. **RouteStoneGuardPromiseArtifact** - domain object for promise persistence
2. **formatCheckYoself** - formats the check yo'self section
3. **stepRouteDrive** - orchestrates route.drive output
4. **route.drive cli entrypoint** - cli.route.drive
5. **route.drive.sh** - shell skill entrypoint
6. **setStoneAsPromised** - records promise for a slug
7. **getStonePromises** - reads promise artifacts for hash
8. **hooks registration** - onStop/onBoot for driver role
