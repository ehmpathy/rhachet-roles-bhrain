# research: test codepath patterns

patterns relevant to implement brain choice for review and reflect skills

---

## pattern.1 = bdd test structure via test-fns [REUSE]

### relation to wish
the wish requires tests for brain choice. this pattern provides the standard structure for all tests in the repo.

### citation.1
**file:** `src/domain.operations/review/compileReviewPrompt.test.ts:1-5`
```typescript
import { BadRequestError } from 'helpful-errors';
import { getError, given, then, when } from 'test-fns';

import { compileReviewPrompt } from './compileReviewPrompt';
```
**note:** imports `given`, `when`, `then` from test-fns for bdd structure.

### citation.2
**file:** `src/domain.operations/review/compileReviewPrompt.test.ts:8-30`
```typescript
given('[case1] --push mode', () => {
  when('[t0] content is within 60% of context window', () => {
    then('injects content into prompt with no warnings', () => {
      const result = compileReviewPrompt({
        rules: [
          {
            path: 'rules/rule.no-console.md',
            content: '# rule: no-console\nforbid console.log',
          },
        ],
        targets: [
          { path: 'src/valid.ts', content: 'export const valid = 1;' },
        ],
        mode: 'push',
        contextWindowSize: 200000,
      });
      expect(result.prompt).toContain('# rule: no-console');
      expect(result.prompt).toContain('export const valid');
      expect(result.tokenEstimate).toBeGreaterThan(0);
      expect(result.contextWindowPercent).toBeLessThan(60);
      expect(result.warnings).toEqual([]);
    });
  });
```
**note:** `[caseN]` tags for given blocks, `[tN]` tags for when blocks.

---

## pattern.2 = scene pattern via useBeforeAll [REUSE]

### relation to wish
the wish requires integration tests that invoke llm calls. this pattern enables efficient test setup where expensive operations run once and are shared across assertions.

### citation.3
**file:** `src/domain.operations/reflect/stepReflect.caseTypescriptQuality.integration.test.ts:21-40`
```typescript
given('[case1] typescript-quality feedback with valid target', () => {
  const scene = useBeforeAll(async () => {
    const { repoDir: sourceDir } = await setupSourceRepo('typescript-quality');
    const { targetDir } = await setupTargetDir();

    // run stepReflect once, share result across all then blocks
    const result = await stepReflect({
      source: sourceDir,
      target: targetDir,
      mode: 'pull',
      rapid: true,
    });

    return { sourceDir, targetDir, result };
  });
  afterAll(async () => {
    await fs.rm(scene.sourceDir, { recursive: true, force: true });
    await fs.rm(scene.targetDir, { recursive: true, force: true });
  });
```
**note:** `useBeforeAll` runs setup once; `afterAll` handles cleanup.

---

## pattern.3 = separate test files per model [EXTEND]

### relation to wish
the wish requires tests for multiple brain choices. current pattern uses `rapid` flag with haiku/sonnet. must extend to support arbitrary brain refs.

### citation.4
**file:** `src/domain.operations/reflect/stepReflect.casePriorRules.haiku.integration.test.ts:10-30`
```typescript
describe('stepReflect.casePriorRules.haiku', () => {
  // increase timeout for claude-code invocations (3 minutes for haiku)
  jest.setTimeout(180000);

  given('[case1] target with prior rule that matches a feedback topic (haiku/rapid)', () => {
    const scene = useBeforeAll(async () => {
      const { repoDir: sourceDir } = await setupSourceRepo('typescript-quality');
      const { targetDir } = await setupTargetDir();

      // use rapid mode (haiku) - SET_UPDATE is disabled, only SET_CREATE allowed
      const result = await stepReflect({
        source: sourceDir,
        target: targetDir,
        mode: 'pull',
        rapid: true,
      });

      return { sourceDir, targetDir, result };
    });
```
**note:** separate file for haiku model with 180000ms timeout.

### citation.5
**file:** `src/domain.operations/reflect/stepReflect.casePriorRules.sonnet.integration.test.ts:10-30`
```typescript
describe('stepReflect.casePriorRules.sonnet', () => {
  // increase timeout for claude-code invocations (5 minutes for sonnet)
  jest.setTimeout(300000);

  given('[case1] target with prior rule that matches a feedback topic (sonnet)', () => {
    const scene = useBeforeAll(async () => {
      // use sonnet (not rapid) for reliable SET_UPDATE handler
      const result = await stepReflect({
        source: sourceDir,
        target: targetDir,
        mode: 'pull',
        rapid: false,
      });
```
**note:** separate file for sonnet model with 300000ms timeout.

---

## pattern.4 = model-specific capability assertions [EXTEND]

### relation to wish
the wish requires different brains to have different capabilities. current pattern tests haiku vs sonnet capabilities. must extend to support brain-specific capability maps.

### citation.6
**file:** `src/domain.operations/reflect/stepReflect.casePriorRules.haiku.integration.test.ts:52-60`
```typescript
when('[t0] stepReflect completes in rapid mode', () => {
  then('has zero SET_UPDATE operations (haiku cannot update)', async () => {
    expect(scene.result.results.updated).toEqual(0);
  });

  then('has only SET_CREATE operations for rules', async () => {
    expect(scene.result.results.created).toBeGreaterThanOrEqual(1);
  });
});
```
**note:** haiku tests assert zero SET_UPDATE due to model limitation.

### citation.7
**file:** `src/domain.operations/reflect/stepReflect.casePriorRules.sonnet.integration.test.ts:52-60`
```typescript
when('[t0] stepReflect completes', () => {
  then('has at least one SET_UPDATE operation', async () => {
    expect(scene.result.results.updated).toBeGreaterThanOrEqual(1);
  });

  then('has at least one SET_CREATE operation', async () => {
    expect(scene.result.results.created).toBeGreaterThanOrEqual(1);
  });
});
```
**note:** sonnet tests assert SET_UPDATE capability works.

---

## pattern.5 = timeout configuration per model [EXTEND]

### relation to wish
the wish requires tests for brains with different latencies. current pattern hardcodes haiku=180s, sonnet=300s. must extend to support configurable timeouts per brain ref.

### citation.8
**file:** `src/domain.operations/reflect/stepReflect.casePriorRules.haiku.integration.test.ts:11-12`
```typescript
  // increase timeout for claude-code invocations (3 minutes for haiku)
  jest.setTimeout(180000);
```

### citation.9
**file:** `src/domain.operations/reflect/stepReflect.casePriorRules.sonnet.integration.test.ts:11-12`
```typescript
  // increase timeout for claude-code invocations (5 minutes for sonnet)
  jest.setTimeout(300000);
```

---

## pattern.6 = flaky test handler via repeatability [REUSE]

### relation to wish
the wish requires tests that invoke llm calls. llm outputs are non-deterministic. this pattern handles flaky tests via repeatability config.

### citation.10
**file:** `src/domain.operations/reflect/stepReflect.caseTypescriptQuality.integration.test.ts:11-19`
```typescript
const REPEAT_CONFIG = {
  attempts: process.env.CI ? 3 : 1,
  criteria: process.env.CI ? 'SOME' : 'EVERY',
} as const;

describe('stepReflect.caseTypescriptQuality', () => {
  // increase timeout for claude-code invocations (3 minutes per attempt)
  jest.setTimeout(180000 * REPEAT_CONFIG.attempts);
```
**note:** CI uses SOME (lenient), local uses EVERY (strict).

### citation.11
**file:** `src/domain.operations/review/stepReview.integration.test.ts:430-435`
```typescript
then.repeatably({
  criteria: process.env.CI ? 'SOME' : 'EVERY',
  attempts: 3,
})('review contains blockers for gerund violations', async () => {
```
**note:** `then.repeatably` for flaky llm-based assertions.

---

## pattern.7 = skip pattern for real cli tests [REUSE]

### relation to wish
the wish requires tests that can skip expensive llm calls by default. this pattern enables opt-in via environment variable.

### citation.12
**file:** `src/domain.operations/review/invokeClaudeCode.integration.test.ts:9-26`
```typescript
const RUN_REAL_CLI_TESTS = process.env.TEST_REAL_CLI === 'true';

describe('invokeClaudeCode', () => {
  given('[case1] a simple prompt', () => {
    when('[t0] claude-code is invoked', () => {
      (RUN_REAL_CLI_TESTS ? it : it.skip)(
        'then: returns response with review content',
        async () => {
          const result = await invokeClaudeCode({
            prompt: 'respond with exactly: "hello world"',
          });

          expect(result.response).toBeDefined();
          expect(typeof result.review).toBe('string');
          expect(result.review.length).toBeGreaterThan(0);
        },
        30000, // 30s timeout for cli invocation
      );
    });
  });
});
```
**note:** uses ternary to switch between `it` and `it.skip`.

---

## pattern.8 = test setup helper functions [REUSE]

### relation to wish
the wish requires test assets for different brain scenarios. this pattern provides reusable setup helpers.

### citation.13
**file:** `src/domain.operations/reflect/.test/setup.ts:1-20`
```typescript
import { execSync } from 'child_process';
import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';

export const GIT_ENV = {
  ...process.env,
  GIT_AUTHOR_NAME: 'Test User',
  GIT_AUTHOR_EMAIL: 'test@test.com',
  GIT_COMMITTER_NAME: 'Test User',
  GIT_COMMITTER_EMAIL: 'test@test.com',
};

export const ASSETS_REPO = path.join(__dirname, 'assets/example.repo');
export const ASSETS_TARGET = path.join(__dirname, 'assets/example.target');
```

### citation.14
**file:** `src/domain.operations/reflect/.test/setup.ts:22-45`
```typescript
export const setupSourceRepo = async (
  repoType: 'typescript-quality' | 'prose-author' | 'unclear-feedback',
): Promise<{ repoDir: string }> => {
  const repoDir = path.join(
    os.tmpdir(),
    `bhrain-reflect-source-${Date.now()}-${Math.random().toString(36).slice(2)}`,
  );

  // copy repo assets to temp directory
  await fs.cp(path.join(ASSETS_REPO, repoType), repoDir, {
    recursive: true,
  });

  // initialize git repo with remote origin
  execSync('git init', { cwd: repoDir, stdio: 'pipe' });
  execSync('git remote add origin https://github.com/test/repo.git', {
    cwd: repoDir,
    stdio: 'pipe',
  });
```
**note:** creates isolated temp directories with unique names.

---

## pattern.9 = test asset directory structure [REUSE]

### relation to wish
the wish requires test assets for brain choice scenarios. this pattern organizes assets by scenario type.

### citation.15
**file:** `src/domain.operations/reflect/.test/setup.ts:22-24`
```typescript
export const setupSourceRepo = async (
  repoType: 'typescript-quality' | 'prose-author' | 'unclear-feedback',
): Promise<{ repoDir: string }> => {
```
**note:** typed repo variants for different test scenarios.

### citation.16
**directory structure observed:**
```
src/domain.operations/reflect/.test/assets/
  example.repo/
    typescript-quality/
    prose-author/
    unclear-feedback/
  example.target/

src/domain.operations/review/.test/assets/
  example.repo/
  example.globs/
```

---

## pattern.10 = prompt unit tests without llm [REUSE]

### relation to wish
the wish requires tests for prompt compilation with brain choice. this pattern tests prompts without llm invocation.

### citation.17
**file:** `src/domain.operations/reflect/step2/compileReflectStep2Prompt.test.ts:189-205`
```typescript
describe('rapid mode', () => {
  it('should NOT include SET_UPDATE operation in rapid mode', async () => {
    await fs.writeFile(path.join(pureDir, 'rule.test.md'), 'test', 'utf-8');

    const result = await compileReflectStep2Prompt({
      targetDir,
      draftDir,
      pureDir,
      mode: 'pull',
      rapid: true,
    });

    expect(result.prompt).toContain('SET_CREATE');
    expect(result.prompt).not.toContain('SET_UPDATE');
    expect(result.prompt).toContain('OMIT');
    expect(result.prompt).toContain('SET_APPEND');
  });
```
**note:** verifies prompt varies based on `rapid` flag without llm call.

### citation.18
**file:** `src/domain.operations/reflect/step2/compileReflectStep2Prompt.test.ts:207-222`
```typescript
  it('should include SET_UPDATE operation when not rapid', async () => {
    await fs.writeFile(path.join(pureDir, 'rule.test.md'), 'test', 'utf-8');

    const result = await compileReflectStep2Prompt({
      targetDir,
      draftDir,
      pureDir,
      mode: 'pull',
      rapid: false,
    });

    expect(result.prompt).toContain('SET_CREATE');
    expect(result.prompt).toContain('SET_UPDATE');
    expect(result.prompt).toContain('OMIT');
    expect(result.prompt).toContain('SET_APPEND');
  });
```

---

## pattern.11 = metrics verification in integration tests [EXTEND]

### relation to wish
the wish requires metrics to reflect correct price rates per brain. current pattern verifies metrics structure. must extend to verify brain-specific price rates.

### citation.19
**file:** `src/domain.operations/review/stepReview.integration.test.ts:400-418`
```typescript
then('metrics.expected contains token estimates', async () => {
  const result = await stepReview({
    rules: '.agent/**/briefs/rules/*.md',
    paths: 'chapters/chapter2.fixed.md',
    output: outputPath,
    mode: 'push',
    cwd: ASSETS_PROSE,
  });

  expect(result.metrics.files.rulesCount).toBe(2);
  expect(result.metrics.files.targetsCount).toBe(1);
  expect(result.metrics.expected.tokens.estimate).toBeGreaterThan(0);
  expect(
    result.metrics.expected.tokens.contextWindowPercent,
  ).toBeGreaterThan(0);
  expect(result.metrics.expected.cost.estimate).toBeGreaterThan(0);
});
```

### citation.20
**file:** `src/domain.operations/review/stepReview.integration.test.ts:420-432`
```typescript
then('metrics.realized contains actual token usage', async () => {
  const result = await stepReview({
    rules: '.agent/**/briefs/rules/*.md',
    paths: 'chapters/chapter2.fixed.md',
    output: outputPath,
    mode: 'push',
    cwd: ASSETS_PROSE,
  });

  expect(result.metrics.realized.tokens.input).toBeGreaterThanOrEqual(0);
  expect(result.metrics.realized.tokens.output).toBeGreaterThan(0);
  expect(result.metrics.realized.cost.total).toBeGreaterThan(0);
});
```
**note:** verifies both expected and realized metrics structure.

---

## pattern.12 = mock logger for operation verification [REUSE]

### relation to wish
the wish requires tests that verify brain choice operations. this pattern provides mock logger to track operations.

### citation.21
**file:** `src/domain.operations/reflect/step2/executeManifestOperations.test.ts:16-23`
```typescript
const mockLog = { log: jest.fn() };

beforeEach(async () => {
  await fs.mkdir(pureDir, { recursive: true });
  await fs.mkdir(syncDir, { recursive: true });
  await fs.mkdir(targetDir, { recursive: true });
  mockLog.log.mockClear();
});
```

### citation.22
**file:** `src/domain.operations/reflect/step2/executeManifestOperations.test.ts:45`
```typescript
expect(mockLog.log).toHaveBeenCalledWith(expect.stringContaining('OMIT'));
```

---

## pattern.13 = getError helper for exception tests [REUSE]

### relation to wish
the wish requires error tests for invalid brain refs. this pattern provides async error capture.

### citation.23
**file:** `src/domain.operations/review/compileReviewPrompt.test.ts:47-58`
```typescript
when('[t2] content exceeds 75% of context window', () => {
  then('throws with clear error and recommendation', async () => {
    const content = 'x '.repeat(2800);
    const error = await getError(async () =>
      compileReviewPrompt({
        rules: [{ path: 'rule.md', content: '# rule' }],
        targets: [{ path: 'large.ts', content }],
        mode: 'push',
        contextWindowSize: 2000,
      }),
    );
    expect(error).toBeInstanceOf(BadRequestError);
    expect(error?.message).toContain('exceeds 75%');
    expect(error?.message).toMatch(/reduce scope|--soft/);
  });
});
```
**note:** `getError` from test-fns captures async errors for assertion.

---

## summary

| pattern | disposition | rationale |
|---------|-------------|-----------|
| pattern.1 = bdd test structure via test-fns | [REUSE] | standard test structure for all tests |
| pattern.2 = scene pattern via useBeforeAll | [REUSE] | efficient setup for llm tests |
| pattern.3 = separate test files per model | [EXTEND] | extend from rapid flag to brain ref |
| pattern.4 = model-specific capability assertions | [EXTEND] | extend to brain-specific capability maps |
| pattern.5 = timeout configuration per model | [EXTEND] | extend to configurable timeouts per brain |
| pattern.6 = flaky test handler via repeatability | [REUSE] | handles llm non-determinism |
| pattern.7 = skip pattern for real cli tests | [REUSE] | opt-in for expensive tests |
| pattern.8 = test setup helper functions | [REUSE] | reusable test infrastructure |
| pattern.9 = test asset directory structure | [REUSE] | organized test fixtures |
| pattern.10 = prompt unit tests without llm | [REUSE] | fast tests for prompt logic |
| pattern.11 = metrics verification in integration tests | [EXTEND] | extend to verify brain-specific price rates |
| pattern.12 = mock logger for operation verification | [REUSE] | tracks operations without console |
| pattern.13 = getError helper for exception tests | [REUSE] | async error assertion pattern |
