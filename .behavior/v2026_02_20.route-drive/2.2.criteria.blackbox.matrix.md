# blackbox criteria matrix: route.drive

## matrix.1 = route.drive output

| ind: route bound | ind: stones status | ind: trigger | dep: output | dep: error |
|------------------|-------------------|--------------|-------------|------------|
| no | n/a | onStop | silent / no-op | none |
| no | n/a | onBoot | silent / no-op | none |
| yes | some unpassed | onStop | stone content + command | none |
| yes | some unpassed | onBoot | stone content + command | none |
| yes | all passed | onStop | "route complete" | none |
| yes | all passed | onBoot | "route complete" | none |

## matrix.2 = route.stone.set --as passed

| ind: reviews.self | ind: promises | ind: hash | dep: passage | dep: output |
|-------------------|---------------|-----------|--------------|-------------|
| not defined | n/a | n/a | (proceeds to guards) | guard tree |
| defined (N items) | 0/N | n/a | blocked | check yo'self 1/N |
| defined (N items) | K/N (K < N) | unchanged | blocked | check yo'self K+1/N |
| defined (N items) | K/N (K < N) | changed | blocked | check yo'self 1/N (invalidated) |
| defined (N items) | N/N | unchanged | (proceeds to guards) | guard tree |
| defined (N items) | N/N | changed | blocked | check yo'self 1/N (invalidated) |

## matrix.3 = route.stone.set --as promised --that $slug

| ind: slug valid | dep: passage | dep: output |
|-----------------|--------------|-------------|
| yes | progressed | next check yo'self or guard tree |
| no | error | valid slug options |

## matrix.4 = guard file reviews format

| ind: reviews format | dep: reviews.self | dep: reviews.peer |
|---------------------|-------------------|-------------------|
| flat array | empty | the array |
| structured (self only) | array of {slug, say} | empty |
| structured (peer only) | empty | array of commands |
| structured (self + peer) | array of {slug, say} | array of commands |

## matrix.5 = reviews.self say resolution

| ind: say format | ind: file exists | dep: guide content | dep: error |
|-----------------|------------------|-------------------|------------|
| inline text | n/a | the text | none |
| @path/to/brief.md | yes | file content | none |
| @path/to/brief.md | no | n/a | path in error |

## matrix.6 = promise validity

| ind: promise exists | ind: current hash | ind: promise hash | dep: promise status |
|---------------------|-------------------|-------------------|---------------------|
| no | any | n/a | unpromised |
| yes | A | A | valid |
| yes | B | A | invalidated |

---

## gap analysis

all combinations are covered by the blackbox criteria.

## decomposition notes

- matrix.1 has 3 dimensions — acceptable, onStop and onBoot produce same output
- matrix.2 has 3 dimensions — reviews.self, promises, hash
  - hash change resets promise count to 0 (invalidation)
  - guards pass/fail is out of scope (extant behavior)
  - "(proceeds to guards)" indicates handoff to extant guard flow
- no matrices exceed 4 dimensions — no decomposition needed
