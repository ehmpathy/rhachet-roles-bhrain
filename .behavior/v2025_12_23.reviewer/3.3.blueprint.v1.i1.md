# blueprint: reviewer role

## overview

implement `src/roles/reviewer` following the patterns established by `src/roles/thinker`:
- role definition via `Role.build()`
- skill definition via `genRoleSkill()`
- shell-based entrypoint for CLI invocation

---

## file structure

```
src/roles/reviewer/
├── getReviewerRole.ts              # role definition
├── briefs/
│   └── review.tactics.md           # reviewer-specific briefs
└── skills/
    └── review/
        ├── stepReview.skill.ts     # skill definition (genRoleSkill)
        ├── stepReview.ts           # core logic
        ├── stepReview.test.ts      # unit tests
        └── stepReview.integration.test.ts
```

---

## domain operations

```
src/domain.operations/review/
├── enumFilesFromGlob.ts                      # glob -> file paths
├── enumFilesFromGlob.integration.test.ts     # hits real fs
├── enumFilesFromDiffs.ts                     # diffs range -> file paths
├── enumFilesFromDiffs.integration.test.ts    # hits real fs + git
├── compileReviewPrompt.ts                    # content -> prompt (pure)
├── compileReviewPrompt.test.ts               # unit: pre-loaded content
├── estimateTokenCount.ts                     # string -> token count (pure)
├── estimateTokenCount.test.ts                # unit: pure transform
├── invokeClaudeCode.ts                       # prompt -> response
├── invokeClaudeCode.integration.test.ts      # hits real cli
├── formatReviewOutput.ts                     # response -> markdown (pure)
└── formatReviewOutput.test.ts                # unit: pure transform
```

---

## skill definition

```ts
// src/roles/reviewer/skills/review/stepReview.skill.ts

export const SKILL_REVIEW = genRoleSkill({
  slug: 'review',
  route: loopReview,
  threads: {
    lookup: {
      rules: {
        source: 'process.argv',
        desc: 'glob pattern for rule files',
        type: 'string',
      },
      diffs: {
        source: 'process.argv',
        desc: 'diff range: since-main | since-commit | since-staged',
        type: '?string',
      },
      paths: {
        source: 'process.argv',
        desc: 'glob patterns for target files (comma-delimited)',
        type: '?string',
      },
      output: {
        source: 'process.argv',
        char: 'o',
        desc: 'output path for review markdown',
        type: 'string',
      },
      mode: {
        source: 'process.argv',
        desc: 'soft | hard (default: hard)',
        type: '?string',
      },
    },
    assess: (input): input is ReviewInput => {
      // validate: at least one of rules, diffs, paths
      // validate: only one diffs if specified
      // validate: output path parent exists
    },
    instantiate: async (input: ReviewInput) => {
      // enumerate files
      // prepare artifacts for logging
    },
  },
  context: {
    // claude-code cli context
  },
});
```

---

## core flow

```
stepReview.ts

1. parseInputArgs
   ├── validate --rules, --diffs, --paths, --output, --mode
   └── failfast if invalid

2. enumFilesScope
   ├── enumFilesFromGlob({ glob: rules })
   ├── enumFilesFromGlob({ glob: paths }) // for each --paths
   ├── enumFilesFromDiffs({ range: diffs })
   └── union all paths

3. failfast if scope is empty

4. compileReviewPrompt
   ├── if --soft: include paths only, request brain to open
   └── if --hard: inject file contents
       ├── estimateTokenCount
       ├── calculate context window percentage
       ├── if >75%: failfast with recommendation to reduce scope or use --soft
       └── if >60%: emit warning about potential quality degradation

5. writeInputArtifacts
   ├── .log/bhrain/review/$timestamp/input.args.json
   └── .log/bhrain/review/$timestamp/input.prompt.md

6. invokeClaudeCode
   ├── claude -p "$prompt" --output-format json
   └── capture response

7. writeOutputArtifacts
   ├── .log/bhrain/review/$timestamp/output.response.json
   └── .log/bhrain/review/$timestamp/output.review.md

8. formatReviewOutput
   ├── follow template from .ref.[feedback].v1.[given].by_human.md
   └── write to --output path
```

---

## key operations

### enumFilesFromGlob

```ts
/**
 * .what = enumerates files matching a glob pattern
 * .why = supports --rules and --paths inputs
 */
export const enumFilesFromGlob = async (input: {
  glob: string;
}): Promise<string[]> => {
  // handle positive globs
  // handle negative globs (! prefix)
  // return sorted, deduplicated paths
};
```

### enumFilesFromDiffs

```ts
/**
 * .what = enumerates files changed in a git diff range
 * .why = supports --diffs input
 */
export const enumFilesFromDiffs = async (input: {
  range: 'since-main' | 'since-commit' | 'since-staged';
}): Promise<string[]> => {
  // since-main: git diff main --name-only
  // since-commit: git diff HEAD --name-only
  // since-staged: git diff --staged --name-only
};
```

### compileReviewPrompt

```ts
/**
 * .what = compiles the review prompt from rules and target files
 * .why = prepares the prompt for brain invocation
 */
export const compileReviewPrompt = (input: {
  rules: Array<{ path: string; content: string }>;
  targets: Array<{ path: string; content: string }>;
  focus: 'pull' | 'hard';
  contextWindowSize?: number; // default: 200000 (claude)
}): {
  prompt: string;
  tokenEstimate: number;
  contextWindowPercent: number;
  costEstimate: number;
  warnings: string[];
} => {
  // if hard: include target contents
  // if soft: include target paths only (content ignored)
  // estimate tokens
  // calculate context window percentage
  // if >75%: throw BadRequestError with recommendation
  // if >60%: add warning to warnings[]
  // estimate cost based on token count
};
```

### invokeClaudeCode

```ts
/**
 * .what = invokes claude-code cli with the prompt
 * .why = executes the review via the specified brain
 */
export const invokeClaudeCode = async (input: {
  prompt: string;
}): Promise<{ response: object; review: string }> => {
  // claude -p "$prompt" --output-format json
  // parse response
  // extract review markdown
};
```

---

## prompt structure

```md
# review task

you are a reviewer. apply the rules below to the target files.

## rules

<rules>
[rule file contents or paths]
</rules>

## target

<target>
[target file contents or paths]
</target>

## output format

emit your review following this template:

<template>
[contents of .ref.[feedback].v1.[given].by_human.md]
</template>

emit blockers first, then nitpicks.
```

---

## logging structure

```
.log/bhrain/review/$timestamp/
├── input.args.json       # { args, scope, metrics }
├── input.prompt.md       # exact prompt sent to brain
├── output.response.json  # raw claude-code response
└── output.review.md      # formatted review markdown
```

### input.args.json schema

```ts
{
  args: {
    rules: string;
    diffs: string | null;
    paths: string[] | null;
    output: string;
    focus: 'pull' | 'hard';
  };

  scope: {
    rules: string[];       // files matched by --rules
    targets: {
      diffs: string[];     // files matched by --diffs
      paths: string[];     // files matched by --paths
      combined: string[];  // union of diffs + paths
    };
  };

  metrics: {
    tokens: number;
    context: {
      window: number;      // e.g., 200000
      percent: number;     // e.g., 42.5
    };
    cost: {
      estimate: number;    // e.g., 0.03
      currency: 'USD';
    };
    warnings: string[];
  };
}
```

---

## role registration

```ts
// src/roles/getRoleRegistry.ts

import { ROLE_REVIEWER } from './reviewer/getReviewerRole';

export const getRoleRegistry = (): RoleRegistry =>
  new RoleRegistry({
    slug: 'bhrain',
    readme: BHRAIN_REGISTRY_README,
    roles: [ROLE_THINKER, ROLE_REVIEWER],
  });
```

---

## dependencies

- `glob` or `fast-glob` for file enumeration
- `simple-git` or shell exec for git diff
- `tiktoken` or heuristic for token estimation
- `execa` or shell exec for claude-code cli

---

## test strategy

| layer       | scope               | approach                                    |
| ----------- | ------------------- | ------------------------------------------- |
| unit        | estimateTokenCount  | pure transform: string → number             |
| unit        | formatReviewOutput  | pure transform: response → markdown         |
| unit        | compileReviewPrompt | pure transform: pre-loaded content → prompt |
| integration | enumFilesFromGlob   | real fs with .test/assets                   |
| integration | enumFilesFromDiffs  | clone example.repo into tmp()               |
| integration | invokeClaudeCode    | real claude-code cli                        |
| integration | stepReview          | end-to-end with real files                  |

**unit test criteria**: no fs, no git, no network, no cli — pure transforms only

---

## test assets

```
src/domain.operations/review/.test/
└── assets/
    ├── example.repo/           # git repo template (NOT a submodule)
    │   ├── .git.template/      # renamed from .git to avoid git-in-git
    │   ├── src/
    │   │   ├── valid.ts        # clean file
    │   │   └── invalid.ts      # file with violations
    │   └── rules/
    │       ├── rule.no-console.md
    │       └── rule.no-any.md
    └── example.globs/
        ├── foo.ts
        ├── bar.ts
        ├── baz.js
        └── nested/
            ├── qux.ts
            └── quux.js
```

---

## test examples

### enumFilesFromGlob.integration.test.ts

```ts
import { given, when, then } from 'test-fns';

describe('enumFilesFromGlob', () => {
  given('[case1] a positive glob pattern', () => {
    when('[t0] glob matches multiple files', () => {
      then('returns all matched files sorted', async () => {
        const files = await enumFilesFromGlob({
          glob: 'src/domain.operations/review/.test/assets/example.globs/**/*.ts',
        });
        expect(files).toEqual([
          'src/domain.operations/review/.test/assets/example.globs/bar.ts',
          'src/domain.operations/review/.test/assets/example.globs/foo.ts',
          'src/domain.operations/review/.test/assets/example.globs/nested/qux.ts',
        ]);
      });
    });

    when('[t1] glob matches zero files', () => {
      then('returns empty array', async () => {
        const files = await enumFilesFromGlob({
          glob: 'src/domain.operations/review/.test/assets/example.globs/**/*.xyz',
        });
        expect(files).toEqual([]);
      });
    });
  });

  given('[case2] a negative glob pattern with ! prefix', () => {
    when('[t0] negative pattern excludes files', () => {
      then('returns files minus excluded', async () => {
        const files = await enumFilesFromGlob({
          glob: 'src/domain.operations/review/.test/assets/example.globs/**/*.ts',
          exclude: '!**/nested/**',
        });
        expect(files).toEqual([
          'src/domain.operations/review/.test/assets/example.globs/bar.ts',
          'src/domain.operations/review/.test/assets/example.globs/foo.ts',
        ]);
      });
    });
  });

  given('[case3] multiple glob patterns', () => {
    when('[t0] patterns are unioned', () => {
      then('returns deduplicated union', async () => {
        const files = await enumFilesFromGlob({
          globs: [
            'src/domain.operations/review/.test/assets/example.globs/*.ts',
            'src/domain.operations/review/.test/assets/example.globs/*.js',
          ],
        });
        expect(files).toEqual([
          'src/domain.operations/review/.test/assets/example.globs/bar.ts',
          'src/domain.operations/review/.test/assets/example.globs/baz.js',
          'src/domain.operations/review/.test/assets/example.globs/foo.ts',
        ]);
      });
    });
  });
});
```

---

### enumFilesFromDiffs.integration.test.ts

```ts
import { given, when, then, useBeforeAll } from 'test-fns';
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';

/**
 * .what = creates an isolated git repo in tmp for testing
 * .why = avoids git-in-git issues when testing diff operations
 */
const setupTestRepo = async (): Promise<{ repoPath: string; cleanup: () => void }> => {
  // create tmp directory
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'review-test-'));
  const repoPath = path.join(tmpDir, 'repo');

  // copy example.repo contents (excluding .git.template for now)
  const assetPath = 'src/domain.operations/review/.test/assets/example.repo';
  fs.cpSync(assetPath, repoPath, { recursive: true });

  // rename .git.template to .git to activate the repo
  const gitTemplatePath = path.join(repoPath, '.git.template');
  const gitPath = path.join(repoPath, '.git');
  if (fs.existsSync(gitTemplatePath)) {
    fs.renameSync(gitTemplatePath, gitPath);
  } else {
    // initialize fresh git repo if no template
    execSync('git init', { cwd: repoPath });
    execSync('git add .', { cwd: repoPath });
    execSync('git commit -m "initial"', { cwd: repoPath });
  }

  return {
    repoPath,
    cleanup: () => fs.rmSync(tmpDir, { recursive: true, force: true }),
  };
};

describe('enumFilesFromDiffs', () => {
  given('[case1] --diffs since-main', () => {
    const scene = useBeforeAll(async () => {
      const { repoPath, cleanup } = await setupTestRepo();

      // create a branch and make changes
      execSync('git checkout -b feature', { cwd: repoPath });
      fs.writeFileSync(path.join(repoPath, 'src/new-file.ts'), 'export const x = 1;');
      fs.appendFileSync(path.join(repoPath, 'src/valid.ts'), '\n// modified');
      execSync('git add .', { cwd: repoPath });
      execSync('git commit -m "feature changes"', { cwd: repoPath });

      return { repoPath, cleanup };
    });

    afterAll(() => scene.cleanup());

    when('[t0] changes exist between HEAD and main', () => {
      then('returns changed files', async () => {
        const files = await enumFilesFromDiffs({
          range: 'since-main',
          cwd: scene.repoPath,
        });
        expect(files).toContain('src/new-file.ts');
        expect(files).toContain('src/valid.ts');
      });
    });
  });

  given('[case2] --diffs since-commit', () => {
    const scene = useBeforeAll(async () => {
      const { repoPath, cleanup } = await setupTestRepo();
      return { repoPath, cleanup };
    });

    afterAll(() => scene.cleanup());

    when('[t0] unstaged changes exist', () => {
      then('returns unstaged files', async () => {
        // make unstaged change
        fs.appendFileSync(path.join(scene.repoPath, 'src/valid.ts'), '\n// unstaged');

        const files = await enumFilesFromDiffs({
          range: 'since-commit',
          cwd: scene.repoPath,
        });
        expect(files).toContain('src/valid.ts');
      });
    });

    when('[t1] staged changes exist', () => {
      then('returns staged files', async () => {
        // make staged change
        fs.writeFileSync(path.join(scene.repoPath, 'src/staged.ts'), 'export const y = 2;');
        execSync('git add src/staged.ts', { cwd: scene.repoPath });

        const files = await enumFilesFromDiffs({
          range: 'since-commit',
          cwd: scene.repoPath,
        });
        expect(files).toContain('src/staged.ts');
      });
    });
  });

  given('[case3] --diffs since-staged', () => {
    const scene = useBeforeAll(async () => {
      const { repoPath, cleanup } = await setupTestRepo();
      return { repoPath, cleanup };
    });

    afterAll(() => scene.cleanup());

    when('[t0] only staged changes', () => {
      then('returns only staged files', async () => {
        // make unstaged change (should NOT appear)
        fs.appendFileSync(path.join(scene.repoPath, 'src/valid.ts'), '\n// unstaged');

        // make staged change (should appear)
        fs.writeFileSync(path.join(scene.repoPath, 'src/staged-only.ts'), 'export const z = 3;');
        execSync('git add src/staged-only.ts', { cwd: scene.repoPath });

        const files = await enumFilesFromDiffs({
          range: 'since-staged',
          cwd: scene.repoPath,
        });
        expect(files).toContain('src/staged-only.ts');
        expect(files).not.toContain('src/valid.ts');
      });
    });
  });

  given('[case4] no changes', () => {
    const scene = useBeforeAll(async () => {
      const { repoPath, cleanup } = await setupTestRepo();
      return { repoPath, cleanup };
    });

    afterAll(() => scene.cleanup());

    when('[t0] repo is clean', () => {
      then('returns empty array', async () => {
        const files = await enumFilesFromDiffs({
          range: 'since-commit',
          cwd: scene.repoPath,
        });
        expect(files).toEqual([]);
      });
    });
  });
});
```

---

### estimateTokenCount.test.ts (unit)

```ts
import { given, when, then } from 'test-fns';

/**
 * unit test: pure transform string → number
 */
describe('estimateTokenCount', () => {
  given('[case1] content strings', () => {
    when('[t0] empty string', () => {
      then('returns 0', () => {
        expect(estimateTokenCount({ content: '' })).toEqual(0);
      });
    });

    when('[t1] simple text', () => {
      then('estimates tokens proportional to length', () => {
        const short = estimateTokenCount({ content: 'hello world' });
        const long = estimateTokenCount({ content: 'hello world '.repeat(100) });
        expect(long).toBeGreaterThan(short);
      });
    });

    when('[t2] code with special characters', () => {
      then('accounts for tokenization of symbols', () => {
        const code = 'const x = () => { return { a: 1, b: 2 }; };';
        const estimate = estimateTokenCount({ content: code });
        expect(estimate).toBeGreaterThan(0);
        expect(estimate).toBeLessThan(code.length); // tokens < chars for code
      });
    });
  });
});
```

---

### compileReviewPrompt.test.ts (unit)

```ts
import { given, when, then } from 'test-fns';

/**
 * unit test: takes pre-loaded content, no fs access
 */
describe('compileReviewPrompt', () => {
  given('[case1] --push mode', () => {
    when('[t0] content is within 60% of context window', () => {
      then('injects content into prompt with no warnings', () => {
        const result = compileReviewPrompt({
          rules: [
            { path: 'rules/rule.no-console.md', content: '# rule: no-console\nforbid console.log' },
          ],
          targets: [
            { path: 'src/valid.ts', content: 'export const valid = 1;' },
          ],
          focus: 'push',
          contextWindowSize: 200000,
        });
        expect(result.prompt).toContain('# rule: no-console');
        expect(result.prompt).toContain('export const valid');
        expect(result.tokenEstimate).toBeGreaterThan(0);
        expect(result.contextWindowPercent).toBeLessThan(60);
        expect(result.warnings).toEqual([]);
      });
    });

    when('[t1] content exceeds 60% but under 75% of context window', () => {
      then('emits warning but continues', () => {
        // ~65% of 1000 token window
        const content = 'x '.repeat(325);
        const result = compileReviewPrompt({
          rules: [{ path: 'rule.md', content: '# rule' }],
          targets: [{ path: 'file.ts', content }],
          focus: 'push',
          contextWindowSize: 1000,
        });
        expect(result.contextWindowPercent).toBeGreaterThanOrEqual(60);
        expect(result.contextWindowPercent).toBeLessThan(75);
        expect(result.warnings).toContain('potential quality degradation');
      });
    });

    when('[t2] content exceeds 75% of context window', () => {
      then('throws with clear error and recommendation', () => {
        // ~80% of 1000 token window
        const content = 'x '.repeat(400);
        const error = getErrorSync(() =>
          compileReviewPrompt({
            rules: [{ path: 'rule.md', content: '# rule' }],
            targets: [{ path: 'large.ts', content }],
            focus: 'push',
            contextWindowSize: 1000,
          }),
        );
        expect(error).toBeInstanceOf(BadRequestError);
        expect(error.message).toContain('exceeds 75%');
        expect(error.message).toMatch(/reduce scope|--soft/);
      });
    });
  });

  given('[case2] --pull mode', () => {
    when('[t0] prompt is compiled', () => {
      then('includes only file paths, not contents', () => {
        const result = compileReviewPrompt({
          rules: [
            { path: 'rules/rule.no-console.md', content: '# rule: no-console' },
          ],
          targets: [
            { path: 'src/valid.ts', content: 'export const valid = 1;' },
            { path: 'src/invalid.ts', content: 'console.log("bad");' },
          ],
          focus: 'pull',
        });
        expect(result.prompt).toContain('src/valid.ts');
        expect(result.prompt).toContain('src/invalid.ts');
        expect(result.prompt).not.toContain('export const valid');
        expect(result.prompt).not.toContain('console.log');
      });

      then('instructs brain to open files', () => {
        const result = compileReviewPrompt({
          rules: [{ path: 'rule.md', content: '# rule' }],
          targets: [{ path: 'src/valid.ts', content: '...' }],
          focus: 'pull',
        });
        expect(result.prompt).toMatch(/open|read|load/i);
      });
    });
  });

  given('[case3] multiple rules', () => {
    when('[t0] rules are provided', () => {
      then('all rules are included in prompt', () => {
        const result = compileReviewPrompt({
          rules: [
            { path: 'rule.no-console.md', content: '# no-console' },
            { path: 'rule.no-any.md', content: '# no-any' },
          ],
          targets: [{ path: 'src/valid.ts', content: '...' }],
          focus: 'push',
        });
        expect(result.prompt).toContain('no-console');
        expect(result.prompt).toContain('no-any');
      });
    });
  });

  given('[case4] output stats', () => {
    when('[t0] prompt is compiled', () => {
      then('includes context window percentage', () => {
        const result = compileReviewPrompt({
          rules: [{ path: 'rule.md', content: '# rule' }],
          targets: [{ path: 'file.ts', content: 'code' }],
          focus: 'push',
          contextWindowSize: 200000,
        });
        expect(result.contextWindowPercent).toBeDefined();
        expect(typeof result.contextWindowPercent).toBe('number');
      });

      then('includes cost estimate', () => {
        const result = compileReviewPrompt({
          rules: [{ path: 'rule.md', content: '# rule' }],
          targets: [{ path: 'file.ts', content: 'code' }],
          focus: 'push',
        });
        expect(result.costEstimate).toBeDefined();
        expect(typeof result.costEstimate).toBe('number');
      });
    });
  });
});
```

---

### formatReviewOutput.test.ts (unit)

```ts
import { given, when, then } from 'test-fns';

/**
 * unit test: pure transform, no fs/network
 */
describe('formatReviewOutput', () => {
  given('[case1] brain response with findings', () => {
    when('[t0] response contains blockers and nitpicks', () => {
      then('formats according to template', () => {
        const output = formatReviewOutput({
          response: {
            findings: [
              { type: 'blocker', message: 'console.log found', file: 'src/invalid.ts', line: 5 },
              { type: 'nitpick', message: 'prefer const', file: 'src/invalid.ts', line: 10 },
            ],
          },
        });
        expect(output).toContain('# blocker.1');
        expect(output).toContain('console.log found');
        expect(output).toContain('# nitpick.1');
        expect(output).toContain('prefer const');
      });

      then('blockers appear before nitpicks', () => {
        const output = formatReviewOutput({
          response: {
            findings: [
              { type: 'nitpick', message: 'nitpick first in input' },
              { type: 'blocker', message: 'blocker second in input' },
            ],
          },
        });
        const blockerIndex = output.indexOf('blocker');
        const nitpickIndex = output.indexOf('nitpick');
        expect(blockerIndex).toBeLessThan(nitpickIndex);
      });
    });
  });

  given('[case2] brain response with no findings', () => {
    when('[t0] response is clean', () => {
      then('outputs success message', () => {
        const output = formatReviewOutput({
          response: { findings: [] },
        });
        expect(output).toContain('no issues found');
      });
    });
  });
});
```

---

### stepReview.integration.test.ts

```ts
import { given, when, then, useBeforeAll } from 'test-fns';
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';

describe('stepReview', () => {
  given('[case1] valid inputs with --push mode', () => {
    const scene = useBeforeAll(async () => {
      const { repoPath, cleanup } = await setupTestRepo();
      const outputPath = path.join(repoPath, 'review-output.md');
      return { repoPath, outputPath, cleanup };
    });

    afterAll(() => scene.cleanup());

    when('[t0] review is executed', () => {
      then('writes review to output path', async () => {
        await stepReview({
          rules: path.join(scene.repoPath, 'rules/*.md'),
          paths: path.join(scene.repoPath, 'src/*.ts'),
          output: scene.outputPath,
          focus: 'push',
        });
        expect(fs.existsSync(scene.outputPath)).toBe(true);
      });

      then('creates log artifacts', async () => {
        await stepReview({
          rules: path.join(scene.repoPath, 'rules/*.md'),
          paths: path.join(scene.repoPath, 'src/*.ts'),
          output: scene.outputPath,
          focus: 'push',
        });
        const logDirs = fs.readdirSync('.log/bhrain/review');
        expect(logDirs.length).toBeGreaterThan(0);

        const latestLog = path.join('.log/bhrain/review', logDirs.sort().pop()!);
        expect(fs.existsSync(path.join(latestLog, 'input.args.json'))).toBe(true);
        expect(fs.existsSync(path.join(latestLog, 'input.prompt.md'))).toBe(true);
      });
    });
  });

  given('[case2] --diffs since-main with real changes', () => {
    const scene = useBeforeAll(async () => {
      const { repoPath, cleanup } = await setupTestRepo();

      // create branch with changes
      execSync('git checkout -b feature', { cwd: repoPath });
      fs.writeFileSync(
        path.join(repoPath, 'src/new-feature.ts'),
        'console.log("violation");',
      );
      execSync('git add .', { cwd: repoPath });
      execSync('git commit -m "add feature"', { cwd: repoPath });

      const outputPath = path.join(repoPath, 'review-output.md');
      return { repoPath, outputPath, cleanup };
    });

    afterAll(() => scene.cleanup());

    when('[t0] review targets diffs', () => {
      then('reviews only changed files', async () => {
        const result = await stepReview({
          rules: path.join(scene.repoPath, 'rules/*.md'),
          diffs: 'since-main',
          output: scene.outputPath,
          focus: 'push',
          cwd: scene.repoPath,
        });

        // check log to see which files were reviewed
        const logDirs = fs.readdirSync('.log/bhrain/review');
        const latestLog = path.join('.log/bhrain/review', logDirs.sort().pop()!);
        const logged = JSON.parse(fs.readFileSync(path.join(latestLog, 'input.args.json'), 'utf-8'));

        expect(logged.scope.targets.diffs).toContain('src/new-feature.ts');
        expect(logged.scope.targets.diffs).not.toContain('src/valid.ts');
      });
    });
  });

  given('[case3] empty scope', () => {
    when('[t0] no files match', () => {
      then('fails fast with clear error', async () => {
        const error = await getError(
          stepReview({
            rules: 'nonexistent/*.md',
            paths: 'nonexistent/*.ts',
            output: '/tmp/output.md',
            focus: 'push',
          }),
        );
        expect(error).toBeInstanceOf(BadRequestError);
        expect(error.message).toContain('empty scope');
      });
    });
  });

  given('[case4] multiple --diffs args', () => {
    when('[t0] two diffs ranges specified', () => {
      then('fails fast with clear error', async () => {
        const error = await getError(
          stepReview({
            rules: 'rules/*.md',
            diffs: ['since-main', 'since-staged'], // invalid: multiple
            output: '/tmp/output.md',
            focus: 'push',
          }),
        );
        expect(error).toBeInstanceOf(BadRequestError);
        expect(error.message).toContain('only one --diffs');
      });
    });
  });

  given('[case5] output path parent does not exist', () => {
    when('[t0] parent directory is missing', () => {
      then('fails fast with clear error', async () => {
        const error = await getError(
          stepReview({
            rules: 'rules/*.md',
            paths: 'src/*.ts',
            output: '/nonexistent/parent/dir/output.md',
            focus: 'push',
          }),
        );
        expect(error).toBeInstanceOf(BadRequestError);
        expect(error.message).toContain('parent directory');
      });
    });
  });

  given('[case6] no inputs specified', () => {
    when('[t0] no --rules, --diffs, or --paths', () => {
      then('fails fast with clear error', async () => {
        const error = await getError(
          stepReview({
            output: '/tmp/output.md',
            focus: 'push',
          }),
        );
        expect(error).toBeInstanceOf(BadRequestError);
        expect(error.message).toContain('must specify');
      });
    });
  });

  given('[case7] multiple --paths args', () => {
    const scene = useBeforeAll(async () => {
      const { repoPath, cleanup } = await setupTestRepo();
      const outputPath = path.join(repoPath, 'review-output.md');
      return { repoPath, outputPath, cleanup };
    });

    afterAll(() => scene.cleanup());

    when('[t0] multiple path globs provided', () => {
      then('unions all matched files', async () => {
        await stepReview({
          rules: path.join(scene.repoPath, 'rules/*.md'),
          paths: [
            path.join(scene.repoPath, 'src/valid.ts'),
            path.join(scene.repoPath, 'src/invalid.ts'),
          ],
          output: scene.outputPath,
          focus: 'push',
        });

        const logDirs = fs.readdirSync('.log/bhrain/review');
        const latestLog = path.join('.log/bhrain/review', logDirs.sort().pop()!);
        const logged = JSON.parse(fs.readFileSync(path.join(latestLog, 'input.args.json'), 'utf-8'));

        expect(logged.scope.targets.combined).toContain('src/valid.ts');
        expect(logged.scope.targets.combined).toContain('src/invalid.ts');
      });
    });
  });

  given('[case8] --paths combined with --diffs', () => {
    const scene = useBeforeAll(async () => {
      const { repoPath, cleanup } = await setupTestRepo();

      // create branch with one change
      execSync('git checkout -b feature', { cwd: repoPath });
      fs.writeFileSync(path.join(repoPath, 'src/new.ts'), 'export const n = 1;');
      execSync('git add .', { cwd: repoPath });
      execSync('git commit -m "new file"', { cwd: repoPath });

      const outputPath = path.join(repoPath, 'review-output.md');
      return { repoPath, outputPath, cleanup };
    });

    afterAll(() => scene.cleanup());

    when('[t0] both --paths and --diffs specified', () => {
      then('includes union of diffs and paths', async () => {
        await stepReview({
          rules: path.join(scene.repoPath, 'rules/*.md'),
          diffs: 'since-main',
          paths: path.join(scene.repoPath, 'src/valid.ts'), // not in diffs
          output: scene.outputPath,
          focus: 'push',
          cwd: scene.repoPath,
        });

        const logDirs = fs.readdirSync('.log/bhrain/review');
        const latestLog = path.join('.log/bhrain/review', logDirs.sort().pop()!);
        const logged = JSON.parse(fs.readFileSync(path.join(latestLog, 'input.args.json'), 'utf-8'));

        expect(logged.scope.targets.diffs).toContain('src/new.ts');
        expect(logged.scope.targets.paths).toContain('src/valid.ts');
        expect(logged.scope.targets.combined).toContain('src/new.ts');
        expect(logged.scope.targets.combined).toContain('src/valid.ts');
      });
    });
  });
});
```

---

## phases

1. **phase 0**: domain operations (enum, compile, invoke, format)
2. **phase 1**: skill definition + role registration
3. **phase 2**: logging artifacts
4. **phase 3**: integration tests
