# blueprint: driver-route-stones v1

## overview

implement the `driver` role with `route.stone.*` skills that enable robots to autonomously navigate thought routes. the implementation follows patterns from the `reviewer` role and `stepReview` operation.

**key design decisions**:
- domain objects in `src/domain.objects/Driver/` per `domain-objects` library patterns
- domain operations in `src/domain.operations/route/` for reusable logic
- cli entrypoints in `src/contract/cli/route.ts` for shell invocation
- driver role in `src/domain.roles/driver/` with skill shell wrappers
- all operations are deterministic (no brain invocation) except reviews/judges which invoke external shell commands

---

## treestruct: filediffs

```
src/
├── domain.objects/
│   └── Driver/
│       ├── [+] RouteStone.ts
│       ├── [+] RouteStoneDriveArtifacts.ts
│       ├── [+] RouteStoneGuard.ts
│       ├── [+] RouteStoneGuardReviewArtifact.ts
│       ├── [+] RouteStoneGuardJudgeArtifact.ts
│       └── [+] RouteStoneGuardApproveArtifact.ts
│
├── domain.operations/
│   └── route/
│       ├── [+] getAllStones.ts
│       ├── [+] getAllStones.test.ts
│       ├── [+] getAllStoneDriveArtifacts.ts
│       ├── [+] getAllStoneDriveArtifacts.test.ts
│       ├── [+] computeStoneOrderPrefix.ts
│       ├── [+] computeStoneOrderPrefix.test.ts
│       ├── [+] computeNextStones.ts
│       ├── [+] computeNextStones.test.ts
│       ├── [+] getAllStoneArtifacts.ts
│       ├── [+] getAllStoneArtifacts.test.ts
│       ├── [+] setStonePassage.ts
│       ├── [+] setStonePassage.test.ts
│       ├── [+] setStoneAsPassed.ts
│       ├── [+] setStoneAsPassed.test.ts
│       ├── [+] setStoneAsPassed.integration.test.ts
│       ├── [+] setStoneAsApproved.ts
│       ├── [+] setStoneAsApproved.test.ts
│       ├── [+] delStone.ts
│       ├── [+] delStone.test.ts
│       ├── [+] stepRouteStoneGet.ts
│       ├── [+] stepRouteStoneGet.test.ts
│       ├── [+] stepRouteStoneGet.integration.test.ts
│       ├── [+] stepRouteStoneSet.ts
│       ├── [+] stepRouteStoneSet.test.ts
│       ├── [+] stepRouteStoneSet.integration.test.ts
│       ├── [+] stepRouteStoneDel.ts
│       ├── [+] stepRouteStoneDel.test.ts
│       ├── [+] stepRouteStoneDel.integration.test.ts
│       ├── guard/
│       │   ├── [+] parseStoneGuard.ts
│       │   ├── [+] parseStoneGuard.test.ts
│       │   ├── [+] computeStoneReviewInputHash.ts
│       │   ├── [+] computeStoneReviewInputHash.test.ts
│       │   ├── [+] runStoneGuardReviews.ts
│       │   ├── [+] runStoneGuardReviews.integration.test.ts
│       │   ├── [+] runStoneGuardJudges.ts
│       │   ├── [+] runStoneGuardJudges.integration.test.ts
│       │   ├── [+] getAllStoneGuardArtifactsByHash.ts
│       │   ├── [+] getAllStoneGuardArtifactsByHash.test.ts
│       │   ├── [+] getOneStoneGuardApproval.ts
│       │   ├── [+] getOneStoneGuardApproval.test.ts
│       │   ├── [+] setStoneGuardApproval.ts
│       │   └── [+] setStoneGuardApproval.test.ts
│       └── .test/
│           ├── [+] assets/
│           │   ├── [+] route.simple/          # no guards, linear stones
│           │   ├── [+] route.guarded/         # has guards with reviews/judges
│           │   ├── [+] route.parallel/        # 3.1.a, 3.1.b, 3.1.c stones
│           │   ├── [+] route.approved/        # has approved? judge
│           │   ├── [+] route.reviewed/        # has reviewed? judge with review skill
│           │   └── [+] route.alternate/          # uses .src and .src.stone extensions
│           └── [+] setup.ts
│
├── contract/
│   └── cli/
│       ├── [+] route.ts                       # cli entrypoints
│       └── [~] index.ts                       # add route exports
│
├── domain.roles/
│   ├── [+] driver/
│   │   ├── [+] getDriverRole.ts
│   │   ├── [+] readme.md
│   │   ├── [+] briefs/                        # (empty for now)
│   │   └── [+] skills/
│   │       ├── [+] route.stone.get.sh
│   │       ├── [+] route.stone.set.sh
│   │       ├── [+] route.stone.del.sh
│   │       └── [+] route.stone.judge.sh       # --mechanism approved? | reviewed?
│   └── [~] getRoleRegistry.ts                 # add ROLE_DRIVER
│
└── [~] index.ts                               # export new cli.route

blackbox/
├── .test/
│   └── [+] invokeRouteSkill.ts
├── [+] driver.route.get.acceptance.test.ts
├── [+] driver.route.set.acceptance.test.ts
└── [+] driver.route.del.acceptance.test.ts
```

---

## treestruct: codepaths

### domain.objects

```
RouteStone
├── [+] interface RouteStone
│       ├── name: string
│       ├── path: FilePath
│       └── guard: RouteStoneGuard | null
├── [+] class RouteStone extends DomainEntity<RouteStone>
│       └── unique = ['path']
└── [←] pattern: src/domain.objects/Reviewer/ReviewIssue.ts

RouteStoneDriveArtifacts
├── [+] interface RouteStoneDriveArtifacts
│       ├── stone: RefByUnique<typeof RouteStone>
│       ├── outputs: FilePath[]
│       └── passage: FilePath | null
└── [+] class RouteStoneDriveArtifacts extends DomainLiteral<RouteStoneDriveArtifacts>

RouteStoneGuard
├── [+] interface RouteStoneGuard
│       ├── path: FilePath
│       ├── artifacts: FileGlob[]
│       ├── reviews: string[]
│       └── judges: string[]
└── [+] class RouteStoneGuard extends DomainLiteral<RouteStoneGuard>

RouteStoneGuardReviewArtifact
├── [+] interface RouteStoneGuardReviewArtifact
│       ├── stone: RefByUnique<typeof RouteStone>
│       ├── hash: Hash
│       ├── iteration: number
│       ├── index: number
│       ├── path: FilePath
│       ├── blockers: number
│       └── nitpicks: number
├── [+] class RouteStoneGuardReviewArtifact extends DomainEntity<...>
│       ├── primary = ['path']
│       └── unique = ['stone', 'hash', 'index']
└── [←] pattern: src/domain.objects/Reviewer/ReviewOutput.ts

RouteStoneGuardJudgeArtifact
├── [+] interface RouteStoneGuardJudgeArtifact
│       ├── stone: RefByUnique<typeof RouteStone>
│       ├── hash: Hash
│       ├── iteration: number
│       ├── index: number
│       ├── path: FilePath
│       ├── passed: boolean
│       └── reason: string | null
└── [+] class RouteStoneGuardJudgeArtifact extends DomainEntity<...>
        ├── primary = ['path']
        └── unique = ['stone', 'hash', 'index']

RouteStoneGuardApproveArtifact
├── [+] interface RouteStoneGuardApproveArtifact
│       ├── stone: RefByUnique<typeof RouteStone>
│       └── path: FilePath
└── [+] class RouteStoneGuardApproveArtifact extends DomainEntity<...>
        ├── primary = ['path']
        └── unique = ['stone']
```

### domain.operations

```
getAllStones
├── [+] input: { route: DirPath }
├── [+] output: RouteStone[]
├── [+] logic:
│       ├── glob for stone files: *.stone, *.src.stone, *.src
│       ├── extract stone.name = path without extension
│       │   ├── .stone → "1.vision.stone" → "1.vision"
│       │   ├── .src.stone → "1.vision.src.stone" → "1.vision"
│       │   └── .src → "1.vision.src" → "1.vision"
│       ├── for each: check for guard files: .guard, .src.guard, .stone.guard
│       │   ├── $name.guard (e.g., 1.vision.guard)
│       │   ├── $name.src.guard (e.g., 1.vision.src.guard)
│       │   └── $name.stone.guard (e.g., 1.vision.stone.guard)
│       ├── parse guard if present
│       └── return RouteStone[] sorted alphanumerically by name
└── [←] reuse: enumFilesFromGlob pattern

getAllStoneDriveArtifacts
├── [+] input: { route: DirPath }
├── [+] output: RouteStoneDriveArtifacts[]
├── [+] logic:
│       ├── getAllStones
│       ├── for each stone: glob for $stone*.md outputs
│       ├── for each stone: check for .route/$stone.passed
│       └── return RouteStoneDriveArtifacts[]
└── [←] reuse: enumFilesFromGlob pattern

computeStoneOrderPrefix
├── [+] input: { stone: RouteStone }
├── [+] output: string
├── [+] logic:
│       ├── extract numeric prefix from stone.name
│       ├── e.g., "3.1.research.domain" → "3.1"
│       └── regex: /^(\d+(?:\.\d+)*)/
└── [+] pure function, no deps

computeNextStones
├── [+] input: { artifacts: RouteStoneDriveArtifacts[], query: '@next-one' | '@next-all' }
├── [+] output: RouteStone[]
├── [+] logic:
│       ├── filter artifacts where passage is null (incomplete)
│       ├── sort by stone.name alphanumerically
│       ├── if @next-one: return first incomplete
│       ├── if @next-all: return all with same order prefix as first
│       └── if none incomplete: return empty (all passed)
└── [+] pure function, no deps

getAllStoneArtifacts
├── [+] input: { stone: RouteStone, route: DirPath }
├── [+] output: FilePath[]
├── [+] logic:
│       ├── if stone.guard?.artifacts: use guard.artifacts globs
│       ├── else: default glob = $stone.name*.md (e.g., 1.vision*.md)
│       ├── return all matches (empty array if none)
│       └── supports versioned: 1.vision.v1.i1.md, 1.vision.v2.i1.md, etc.
└── [←] reuse: enumFilesFromGlob pattern

computeStoneReviewInputHash
├── [+] input: { stone: RouteStone, route: DirPath }
├── [+] output: Hash
├── [+] logic:
│       ├── reviews hash on their inputs (artifacts)
│       ├── if stone.guard?.artifacts: use guard.artifacts globs
│       ├── else: default glob = $stone.name*.md
│       ├── enumerate matched files, sort deterministically
│       ├── read content, concatenate
│       ├── compute sha256 of concatenated content
│       └── return hash
└── [←] reuse: crypto.createHash

computeStoneJudgeInputHash
├── [+] input: { stone: RouteStone, reviewInputHash: Hash, route: DirPath }
├── [+] output: Hash
├── [+] logic:
│       ├── judges hash on their inputs (reviews + approvals)
│       ├── find all review files for reviewInputHash under .route/
│       ├── read review content, sort deterministically
│       ├── check approval marker presence
│       ├── concatenate: reviewInputHash + review contents + approval state
│       ├── compute sha256 of concatenated content
│       └── return hash
├── [+] cache invalidation:
│       ├── if reviews change (re-run after fix) → hash changes
│       └── if approval granted → hash changes
└── [←] reuse: crypto.createHash

parseStoneGuard
├── [+] input: { path: FilePath }
├── [+] output: RouteStoneGuard
├── [+] logic:
│       ├── read file content
│       ├── parse yaml
│       ├── validate schema (artifacts, reviews, judges)
│       └── return RouteStoneGuard
└── [←] reuse: yaml library, zod validation

runStoneGuardReviews
├── [+] input: { guard: RouteStoneGuard, hash: Hash, iteration: number, route: DirPath }
├── [+] output: RouteStoneGuardReviewArtifact[]
├── [+] logic:
│       ├── for each review command in guard.reviews
│       ├── substitute $stone, $route, $hash vars
│       ├── exec shell command
│       ├── write output to .route/$stone.guard.review.i$iter.$hash.r$n.md
│       ├── parse blockers/nitpicks from output
│       └── return artifacts
└── [←] reuse: child_process.exec pattern

runStoneGuardJudges
├── [+] input: { guard: RouteStoneGuard, hash: Hash, iteration: number, reviews: RouteStoneGuardReviewArtifact[], route: DirPath }
├── [+] output: RouteStoneGuardJudgeArtifact[]
├── [+] logic:
│       ├── for each judge command in guard.judges
│       ├── substitute $stone, $route, $hash vars
│       ├── exec shell command
│       ├── write output to .route/$stone.guard.judge.i$iter.$hash.j$n.md
│       ├── parse passed/reason from output
│       └── return artifacts
└── [←] reuse: child_process.exec pattern

getAllStoneGuardArtifactsByHash
├── [+] input: { stone: RouteStone, hash: Hash, route: DirPath }
├── [+] output: { reviews: RouteStoneGuardReviewArtifact[], judges: RouteStoneGuardJudgeArtifact[] }
├── [+] logic:
│       ├── glob .route/$stone.guard.review.*.$hash.*.md
│       ├── glob .route/$stone.guard.judge.*.$hash.*.md
│       ├── parse each file into artifact
│       └── return grouped
└── [←] reuse: enumFilesFromGlob pattern

setStonePassage
├── [+] input: { stone: RouteStone, route: DirPath }
├── [+] output: void
├── [+] logic:
│       ├── ensure .route/ dir found or created
│       ├── write empty file to .route/$stone.name.passed
│       └── return
└── [+] simple fs.writeFile

getOneStoneGuardApproval
├── [+] input: { stone: RouteStone, route: DirPath }
├── [+] output: RouteStoneGuardApproveArtifact | null
├── [+] logic:
│       ├── check for .route/$stone.name.approved
│       ├── return artifact if found, null otherwise
│       └── (no content parse needed)
└── [+] simple fs.access

setStoneGuardApproval
├── [+] input: { stone: RouteStone, route: DirPath }
├── [+] output: RouteStoneGuardApproveArtifact
├── [+] logic:
│       ├── ensure .route/ dir found or created
│       ├── write empty file to .route/$stone.name.approved
│       └── return artifact
└── [+] simple fs.writeFile

delStone
├── [+] input: { stone: RouteStone }
├── [+] output: void
├── [+] logic:
│       ├── fs.rm stone.path
│       ├── if stone.guard: fs.rm stone.guard.path
│       └── return
└── [+] simple fs.rm
```

### step operations (skill orchestrators)

```
stepRouteStoneGet
├── [+] input: { stone: '@next-one' | '@next-all' | FileGlob, route: DirPath, say?: boolean }
├── [+] output: { stones: RouteStone[], emit: { stdout: string } | null }
├── [+] logic:
│       ├── validate route found (BadRequestError if not)
│       ├── getAllStones
│       ├── getAllStoneDriveArtifacts
│       ├── if @next-one or @next-all: computeNextStones
│       ├── else: filter by glob
│       ├── if say: read stone file content, emit to stdout
│       ├── if no stones: emit "all stones passed"
│       └── return
└── [←] pattern: stepReview orchestration

stepRouteStoneSet
├── [+] input: { stone: FileGlob, route: DirPath, as: 'passed' | 'approved' }
├── [+] output: { passed: boolean, refs: { reviews: FilePath[], judges: FilePath[] }, emit: { stdout: string } | null }
├── [+] logic:
│       ├── if as === 'approved': return setStoneAsApproved({ stone, route })
│       ├── if as === 'passed': return setStoneAsPassed({ stone, route })
│       └── else: UnexpectedCodePathError('unsupported --as')
└── [+] thin dispatcher to symmetric operations

setStoneAsPassed
├── [+] input: { stone: FileGlob, route: DirPath }
├── [+] output: { passed: boolean, refs: { reviews: FilePath[], judges: FilePath[] }, emit: { stdout: string } | null }
├── [+] logic:
│       ├── getAllStones, find matched stone
│       ├── getAllStoneArtifacts (BadRequestError if empty)
│       ├── if no guard: setStonePassage, return passed=true
│       ├── if guard but no reviews and no judges: setStonePassage, return passed=true
│       │   └── (guard with only artifacts: customizes detection pattern, auto-pass on presence)
│       ├── if guard.reviews but no guard.judges: BadRequestError('guard has reviews but no judges')
│       ├── computeStoneReviewInputHash
│       ├── getAllStoneGuardArtifactsByHash
│       ├── if prior found for hash: reuse reviews/judges
│       ├── else: runStoneGuardReviews, runStoneGuardJudges
│       ├── if all judges pass: setStonePassage, return passed=true
│       └── else: return passed=false with feedback
└── [←] pattern: stepReview orchestration

setStoneAsApproved
├── [+] input: { stone: FileGlob, route: DirPath }
├── [+] output: { approved: boolean, emit: { stdout: string } | null }
├── [+] logic:
│       ├── getAllStones, find matched stone
│       ├── setStoneGuardApproval
│       └── return approved=true
└── [+] simple wrapper around setStoneGuardApproval

stepRouteStoneDel
├── [+] input: { stone: FileGlob, route: DirPath }
├── [+] output: { deleted: FilePath[], skipped: FilePath[], emit: { stdout: string } | null }
├── [+] logic:
│       ├── getAllStones, filter by glob
│       ├── for each: getOneStoneArtifact
│       ├── if artifact found: skip, add to skipped[]
│       ├── if no artifact: delStone, add to deleted[]
│       ├── emit summary
│       └── return
└── [←] pattern: stepReview orchestration
```

### cli entrypoints

```
src/contract/cli/route.ts
├── [+] routeStoneGet()
│       ├── parseArgs: --stone, --route, --say
│       ├── validate required args
│       ├── invoke stepRouteStoneGet
│       └── format and print output
├── [+] routeStoneSet()
│       ├── parseArgs: --stone, --route, --as
│       ├── validate required args
│       ├── invoke stepRouteStoneSet
│       └── format and print output
├── [+] routeStoneDel()
│       ├── parseArgs: --stone, --route
│       ├── validate required args
│       ├── invoke stepRouteStoneDel
│       └── format and print output
├── [+] routeStoneJudge()
│       ├── parseArgs: --mechanism, --stone, --route, --allow-blockers, --allow-nitpicks
│       ├── validate required args
│       ├── if mechanism === 'approved?': check for .approved marker
│       ├── if mechanism === 'reviewed?': parse review files, check thresholds
│       └── emit pass/fail with reason
└── [←] pattern: src/contract/cli/review.ts

src/contract/cli/index.ts
├── [○] export cli.review
├── [○] export cli.reflect
└── [+] export cli.route.stone.get, cli.route.stone.set, cli.route.stone.del, cli.route.stone.judge
```

### role definition

```
src/domain.roles/driver/getDriverRole.ts
├── [+] ROLE_DRIVER: Role
│       ├── slug: 'driver'
│       ├── name: 'Driver'
│       ├── purpose: 'navigate thought routes via stone milestones'
│       ├── skills: { dirs: [__dirname + '/skills'] }
│       └── briefs: { dirs: [__dirname + '/briefs'] }
└── [←] pattern: src/domain.roles/reviewer/getReviewerRole.ts

src/domain.roles/driver/skills/*.sh
├── [+] route.stone.get.sh
│       └── exec node -e "import('rhachet-roles-bhrain/cli').then(m => m.cli.route.stone.get())"
├── [+] route.stone.set.sh
│       └── exec node -e "import('rhachet-roles-bhrain/cli').then(m => m.cli.route.stone.set())"
├── [+] route.stone.del.sh
│       └── exec node -e "import('rhachet-roles-bhrain/cli').then(m => m.cli.route.stone.del())"
└── [+] route.stone.judge.sh
        ├── exec node -e "import('rhachet-roles-bhrain/cli').then(m => m.cli.route.stone.judge())"
        ├── --mechanism approved? → checks for .approved marker under .route/
        └── --mechanism reviewed? → checks blockers/nitpicks against thresholds
```

---

## contracts

### route.stone.get

```ts
// cli
route.stone.get --stone @next-one --route $route [--say]
route.stone.get --stone @next-all --route $route [--say]
route.stone.get --stone "*.research.*" --route $route [--say]

// programmatic
stepRouteStoneGet({
  stone: '@next-one' | '@next-all' | FileGlob,
  route: DirPath,
  say?: boolean,
}) => {
  stones: RouteStone[];
  emit: null | { stdout: string; stderr?: string; code?: number };
}
```

### route.stone.set

```ts
// cli
route.stone.set --stone 1.vision --route $route --as passed
route.stone.set --stone 1.vision --route $route --as approved

// programmatic
stepRouteStoneSet({
  stone: FileGlob,
  route: DirPath,
  as: 'passed' | 'approved',
}) => {
  passed: boolean;
  refs: {
    reviews: FilePath[];
    judges: FilePath[];
  };
  emit: null | { stdout: string; stderr?: string; code?: number };
}
```

### route.stone.del

```ts
// cli
route.stone.del --stone "*.research.*" --route $route

// programmatic
stepRouteStoneDel({
  stone: FileGlob,
  route: DirPath,
}) => {
  deleted: FilePath[];
  skipped: FilePath[];
  emit: null | { stdout: string; stderr?: string; code?: number };
}
```

### guard file format

```yaml
# $route/1.vision.guard
artifacts:
  - 1.vision*.md

judges:
  - rhx route.stone.judge --mechanism approved? --stone 1.vision --route $route
```

```yaml
# $route/5.implement.guard
artifacts:
  - src/**/*.ts

reviews:
  - rhx review --rules .agent/**/rules/*.md --paths src/**/*.ts --output $route/.route/$stone.guard.review.i$iter.$hash.r1.md

judges:
  - rhx route.stone.judge --mechanism reviewed? --stone 5.implement --route $route --allow-blockers 0 --allow-nitpicks 2
  - rhx route.stone.judge --mechanism approved? --stone 5.implement --route $route
```

---

## test coverage

### unit tests

| file | tests |
|------|-------|
| `computeStoneOrderPrefix.test.ts` | extracts numeric prefix from stone names |
| `computeNextStones.test.ts` | @next-one, @next-all logic with parallel stones |
| `parseStoneGuard.test.ts` | yaml parse, schema validation |
| `getAllStones.test.ts` | .stone and .src discovery, guard detection |
| `getAllStoneDriveArtifacts.test.ts` | artifact and passage detection |
| `getAllStoneArtifacts.test.ts` | glob match with version suffixes, returns all matches |
| `computeStoneReviewInputHash.test.ts` | deterministic hash computation |
| `getAllStoneGuardArtifactsByHash.test.ts` | review/judge file discovery |

### integration tests

| file | tests |
|------|-------|
| `stepRouteStoneGet.integration.test.ts` | full get flow with real filesystem |
| `stepRouteStoneSet.integration.test.ts` | full set flow (dispatches to setStoneAsPassed/AsApproved) |
| `stepRouteStoneDel.integration.test.ts` | full del flow with artifact protection |
| `setStoneAsPassed.integration.test.ts` | guard execution with reviews/judges |
| `guard/runStoneGuardReviews.integration.test.ts` | shell command execution |
| `guard/runStoneGuardJudges.integration.test.ts` | shell command execution |

### acceptance tests

| file | tests |
|------|-------|
| `driver.route.get.acceptance.test.ts` | blackbox cli invocation for get |
| `driver.route.set.acceptance.test.ts` | blackbox cli invocation for set |
| `driver.route.del.acceptance.test.ts` | blackbox cli invocation for del |

### test fixtures

```
src/domain.operations/route/.test/assets/
├── route.simple/
│   ├── 1.vision.stone
│   ├── 2.criteria.stone
│   └── 3.plan.stone
├── route.guarded/
│   ├── 1.vision.stone
│   ├── 1.vision.guard           # approved? judge
│   ├── 5.implement.stone
│   └── 5.implement.guard        # reviewed? + approved? judges
├── route.parallel/
│   ├── 2.criteria.stone
│   ├── 3.1.research.domain.stone
│   ├── 3.1.research.template.stone
│   ├── 3.1.research.prior.stone
│   └── 3.2.plan.stone
├── route.approved/
│   ├── 1.vision.stone
│   ├── 1.vision.guard
│   ├── 1.vision.md              # artifact found
│   └── .route/
│       └── 1.vision.approved    # approval marker found
├── route.reviewed/
│   ├── .agent/
│   │   └── rules/
│   │       └── no-todos.md      # rule: forbid TODO comments
│   ├── 1.implement.stone
│   ├── 1.implement.guard        # reviewed? judge with review skill
│   ├── src/
│   │   ├── clean.ts             # passes review (no TODOs)
│   │   └── dirty.ts             # fails review (has TODO)
│   └── .route/                  # (populated by tests)
└── route.alternate/
    ├── 1.vision.src.stone       # .src.stone extension
    ├── 1.vision.src.guard       # .src.guard extension
    ├── 2.criteria.src           # .src extension
    ├── 2.criteria.stone.guard   # .stone.guard extension
    └── 1.vision.md              # artifact matches stone name
```

**route.reviewed/ guard file** (`1.implement.guard`):
```yaml
artifacts:
  - src/**/*.ts

reviews:
  - rhx review --rules .agent/**/rules/*.md --paths src/**/*.ts

judges:
  - rhx route.stone.judge --mechanism reviewed? --stone 1.implement --route $route --allow-blockers 0 --allow-nitpicks 0
```

---

## implementation order

1. **domain objects** — define RouteStone, RouteStoneGuard, etc.
2. **leaf operations** — getAllStones, computeStoneOrderPrefix, guard/* operations, etc.
3. **step orchestrators** — stepRouteStoneGet, stepRouteStoneSet, stepRouteStoneDel
4. **cli entrypoints** — route.ts with parseArgs and invocation (get, set, del, judge)
5. **skill shells** — route.stone.get.sh, route.stone.set.sh, route.stone.del.sh, route.stone.judge.sh
6. **role definition** — getDriverRole.ts, registry update
7. **acceptance tests** — blackbox cli tests

---

## dependencies

### found (reuse)

- `fast-glob` — file enumeration
- `yaml` — guard file parse
- `zod` — schema validation
- `hash-fns` — content hash
- `helpful-errors` — BadRequestError, UnexpectedCodePathError
- `domain-objects` — DomainEntity, DomainLiteral, RefByUnique
- `test-fns` — given, when, then, useBeforeAll

### new (none required)

all functionality can be implemented with found dependencies.
