# blueprint: route.drive

## overview

this blueprint declares the implementation plan for route.drive â€” a GPS-like system that guides clones through routes with self-review checkpoints.

### architectural approach

the implementation extends extant patterns:
1. **thin shell dispatchers** â€” shell files delegate to TypeScript via `node -e "import('rhachet-roles-bhrain/cli').then(m => m.cli.route.xxx())"`
2. **domain operations** â€” extend extant route operations for promise management
3. **domain objects** â€” extend RouteStoneGuard for structured reviews, add RouteStoneGuardReviewSelfArtifact
4. **cli entry points** â€” extend route.ts with drive and promise support

### key flows

```
onStop/onBoot hook fires
    â””â”€â–º route.drive CLI (via hook)
        â”œâ”€â–º getRouteBindByBranch() â†’ routeDir | null
        â”œâ”€â–º if !routeDir â†’ exit 0 (silent)
        â”œâ”€â–º computeNextStones({ route }) â†’ stones | []
        â”œâ”€â–º if !stones.length â†’ exit 0 (silent, route complete)
        â””â”€â–º echo stone content + pass command

direct CLI invocation
    â””â”€â–º route.drive CLI (direct)
        â”œâ”€â–º getRouteBindByBranch() â†’ routeDir | null
        â”œâ”€â–º if !routeDir â†’ exit 0 (silent)
        â”œâ”€â–º computeNextStones({ route }) â†’ stones | []
        â”œâ”€â–º if !stones.length â†’ echo "route complete!"
        â””â”€â–º echo stone content + pass command

route.stone.set --as passed (with reviews.self)
    â””â”€â–º stepRouteStoneSet
        â”œâ”€â–º parseStoneGuard({ stone }) â†’ guard config
        â”œâ”€â–º if guard.reviews.self defined
        â”‚   â”œâ”€â–º getStonePromises({ stone, hash }) â†’ promises
        â”‚   â”œâ”€â–º find first unpromised review.self
        â”‚   â”œâ”€â–º if unpromised â†’ block + formatCheckYoself + show promise cmd
        â”‚   â””â”€â–º if all promised â†’ proceed to peer reviews (extant)
        â””â”€â–º else â†’ proceed to peer reviews (extant, backwards compat)

route.stone.set --as promised --that $slug
    â””â”€â–º stepRouteStoneSet
        â”œâ”€â–º validateSlug({ slug, stone }) â†’ valid | invalid
        â”œâ”€â–º if invalid â†’ error + echo valid options
        â”œâ”€â–º setStoneAsPromised({ stone, slug, hash }) â†’ promise artifact
        â””â”€â–º echo acknowledgment + next step
```

---

## filediffs treestruct

**legend:**
- `[+]` create â€” file to create
- `[~]` update â€” file to update
- `[-]` delete â€” file to delete

```
src/
â”œâ”€ contract/
â”‚  â””â”€ cli/
â”‚     â””â”€ [~] route.ts                         # add drive, extend set for --as promised
â”‚
â”œâ”€ domain.objects/
â”‚  â””â”€ Driver/
â”‚     â”œâ”€ [~] RouteStoneGuard.ts               # add reviews.self and reviews.peer
â”‚     â”œâ”€ [~] RouteStoneGuardReviewArtifact.ts â†’ RouteStoneGuardReviewPeerArtifact.ts  # rename
â”‚     â”œâ”€ [+] RouteStoneGuardReviewSelfArtifact.ts # self-review artifact persistence
â”‚     â””â”€ [~] index.ts                         # export renamed + new objects
â”‚
â”œâ”€ domain.operations/
â”‚  â””â”€ route/
â”‚     â”œâ”€ [+] stepRouteDrive.ts                # orchestrate route.drive output
â”‚     â”œâ”€ [+] stepRouteDrive.test.ts
â”‚     â”œâ”€ [+] stepRouteDrive.integration.test.ts
â”‚     â”‚
â”‚     â”œâ”€ guard/
â”‚     â”‚  â”œâ”€ [~] parseStoneGuard.ts            # support structured reviews
â”‚     â”‚  â”œâ”€ [~] parseStoneGuard.test.ts       # add structured reviews tests
â”‚     â”‚  â”œâ”€ [+] formatCheckYoself.ts          # format check yo'self section
â”‚     â”‚  â””â”€ [+] formatCheckYoself.test.ts
â”‚     â”‚
â”‚     â”œâ”€ promise/
â”‚     â”‚  â”œâ”€ [+] getStonePromises.ts           # read valid promise artifacts
â”‚     â”‚  â”œâ”€ [+] getStonePromises.test.ts
â”‚     â”‚  â”œâ”€ [+] setStoneAsPromised.ts         # record promise artifact
â”‚     â”‚  â”œâ”€ [+] setStoneAsPromised.test.ts
â”‚     â”‚  â””â”€ [+] setStoneAsPromised.integration.test.ts
â”‚     â”‚
â”‚     â”œâ”€ stones/
â”‚     â”‚  â”œâ”€ [~] setStoneAsPassed.ts           # check promises before peer reviews
â”‚     â”‚  â””â”€ [~] setStoneAsPassed.integration.test.ts
â”‚     â”‚
â”‚     â”œâ”€ [~] stepRouteStoneSet.ts             # add --as promised --that support
â”‚     â”œâ”€ [~] stepRouteStoneSet.test.ts
â”‚     â”œâ”€ [~] stepRouteStoneSet.integration.test.ts
â”‚     â”‚
â”‚     â””â”€ [~] formatRouteStoneEmit.ts          # add check yo'self section
â”‚
â”œâ”€ domain.roles/
â”‚  â””â”€ driver/
â”‚     â”œâ”€ [~] getDriverRole.ts                 # add hooks.onBrain.onStop/onBoot
â”‚     â””â”€ skills/
â”‚        â””â”€ [+] route.drive.sh                # route drive skill
â”‚
â””â”€ [~] index.ts                               # add cli.route.drive export

blackbox/
â”œâ”€ .test/
â”‚  â”œâ”€ assets/
â”‚  â”‚  â””â”€ [+] route-drive/                     # fixture with reviews.self
â”‚  â””â”€ [~] invokeRouteSkill.ts                 # add route.drive to union
â”‚
â”œâ”€ [+] driver.route.drive.acceptance.test.ts  # route.drive skill tests
â””â”€ [~] driver.route.journey.acceptance.test.ts # add self-review phase
```

---

## codepaths treestruct

**legend:**
- `[+]` create â€” codepath to create
- `[~]` update â€” codepath to update
- `[â—‹]` retain â€” codepath to retain
- `[-]` delete â€” codepath to delete
- `[â†]` reuse â€” codepath to reuse from elsewhere
- `[â†’]` eject â€” codepath to decompose for reuse

### domain.objects/Driver

```
RouteStoneGuard
â”œâ”€ [â—‹] interface RouteStoneGuard
â”‚  â”œâ”€ [â—‹] path: string
â”‚  â”œâ”€ [â—‹] artifacts: string[]
â”‚  â”œâ”€ [~] reviews: RouteStoneGuardReviewPeer[] | { self: RouteStoneGuardReviewSelf[]; peer: RouteStoneGuardReviewPeer[] }
â”‚  â””â”€ [â—‹] judges: string[]
â”œâ”€ [+] interface RouteStoneGuardReviewSelf
â”‚  â”œâ”€ slug: string                            # identifier for promise
â”‚  â””â”€ say: string                             # guide content (inline or @path)
â”œâ”€ [+] type RouteStoneGuardReviewPeer = string  # shell command
â””â”€ [â—‹] export { RouteStoneGuard }

RouteStoneGuardReviewPeerArtifact
â”œâ”€ [~] rename from RouteStoneGuardReviewArtifact
â”œâ”€ [â—‹] interface RouteStoneGuardReviewPeerArtifact
â”‚  â”œâ”€ stone: RefByUnique<typeof RouteStone>
â”‚  â”œâ”€ hash: string
â”‚  â”œâ”€ iteration: number
â”‚  â”œâ”€ index: number
â”‚  â”œâ”€ path: string
â”‚  â”œâ”€ blockers: number
â”‚  â””â”€ nitpicks: number
â””â”€ [â—‹] export { RouteStoneGuardReviewPeerArtifact }

RouteStoneGuardReviewSelfArtifact
â”œâ”€ [+] interface RouteStoneGuardReviewSelfArtifact
â”‚  â”œâ”€ stone: RefByUnique<typeof RouteStone>   # stone this artifact applies to
â”‚  â”œâ”€ hash: string                            # hash of source artifacts at promise time
â”‚  â”œâ”€ slug: string                            # review.self slug
â”‚  â””â”€ path: string                            # full path to artifact
â”œâ”€ [+] class RouteStoneGuardReviewSelfArtifact extends DomainLiteral
â”‚  â””â”€ unique = ['stone', 'slug', 'hash']
â””â”€ [+] export { RouteStoneGuardReviewSelfArtifact }
```

### domain.operations/route/guard

```
parseStoneGuard
â”œâ”€ [â—‹] (input: { stone: RouteStone }, context?: { cwd?: string })
â”‚  â””â”€ â†’ RouteStoneGuard | null
â”œâ”€ [â—‹] read guard file
â”œâ”€ [~] parseSimpleYaml â€” extend to detect structured reviews
â”‚  â”œâ”€ [â—‹] if reviews: is a flat array â†’ reviews.peer
â”‚  â””â”€ [+] if reviews: has self:/peer: keys â†’ parse structured
â”œâ”€ [+] if reviews.self item has say prefixed with @ â†’ read file
â””â”€ [â—‹] return parsed guard

formatCheckYoself
â”œâ”€ [+] (input: { stone: RouteStone; reviewSelf: RouteStoneGuardReviewSelf; index: number; total: number; invalidated?: boolean })
â”‚  â””â”€ â†’ string
â”œâ”€ [+] format header: "ğŸ” check yo'self"
â”œâ”€ [+] format review.self N/M with slug
â”œâ”€ [+] format "question all, especially yourself"
â”œâ”€ [+] format promise command
â”œâ”€ [+] format guide content block
â””â”€ [+] return formatted tree string
```

### domain.operations/route/promise

```
getStonePromises
â”œâ”€ [+] (input: { stone: RouteStone; hash: string; route: string })
â”‚  â””â”€ â†’ RouteStoneGuardReviewSelfArtifact[]
â”œâ”€ [+] glob .route/$stone.guard.promise.*.${hash}.md
â”œâ”€ [+] parse each into RouteStoneGuardReviewSelfArtifact
â””â”€ [+] return array of valid promises

setStoneAsPromised
â”œâ”€ [+] (input: { stone: RouteStone; slug: string; hash: string; route: string })
â”‚  â””â”€ â†’ { success: boolean; promise: RouteStoneGuardReviewSelfArtifact }
â”œâ”€ [+] validate slug exists in stone.guard.reviews.self
â”œâ”€ [+] compute promise artifact path: .route/$stone.guard.promise.$slug.$hash.md
â”œâ”€ [+] write promise content (timestamp, slug, hash)
â””â”€ [+] return success + promise artifact
```

### domain.operations/route/stones

```
setStoneAsPassed
â”œâ”€ [â—‹] (input: { stone: string; route: string }, context: ContextCliEmit)
â”‚  â””â”€ â†’ { passed: boolean; refs: {...}; emit: {...} }
â”œâ”€ [â—‹] find stone, check artifacts
â”œâ”€ [â†] computeStoneReviewInputHash                   # reuse for promise hash
â”œâ”€ [+] if guard.reviews.self defined
â”‚  â”œâ”€ [+] getStonePromises({ stone, hash, route })
â”‚  â”œâ”€ [+] compute unpromised = reviews.self - promises
â”‚  â”œâ”€ [+] if unpromised.length > 0
â”‚  â”‚  â”œâ”€ return { passed: false, blocked: 'self-review' }
â”‚  â”‚  â””â”€ nextReview = first unpromised
â”‚  â””â”€ [+] else â†’ proceed to peer reviews
â”œâ”€ [â—‹] if guard.reviews flat array â†’ proceed as extant
â”œâ”€ [â—‹] runStoneGuardReviews
â”œâ”€ [â—‹] runStoneGuardJudges
â””â”€ [â—‹] return result
```

### domain.operations/route

```
stepRouteDrive
â”œâ”€ [+] (input: { route?: string; mode?: 'hook' })
â”‚  â””â”€ â†’ { emit: { stdout: string } | null }
â”œâ”€ [+] if !route â†’ getRouteBindByBranch() â†’ route
â”œâ”€ [+] if !route â†’ return { emit: null } (silent)
â”œâ”€ [â†] computeNextStones({ route })                  # reuse from stepRouteStoneGet
â”œâ”€ [+] if stones.length === 0
â”‚  â”œâ”€ if mode === 'hook' â†’ return { emit: null } (silent)
â”‚  â””â”€ else â†’ return "route complete!"
â”œâ”€ [+] take first stone
â”œâ”€ [+] read stone content
â”œâ”€ [+] format output tree
â”‚  â”œâ”€ ğŸ¦‰ where were we?
â”‚  â”œâ”€ ğŸ—¿ route.drive
â”‚  â”‚  â”œâ”€ where do we go (route + stone)
â”‚  â”‚  â”œâ”€ are we there yet? (pass command)
â”‚  â”‚  â”œâ”€ here's the stone (content block)
â”‚  â”‚  â””â”€ are we there yet? (pass command, repeated)
â””â”€ [+] return { emit: { stdout } }

stepRouteStoneSet
â”œâ”€ [â—‹] (input: { stone: string; route: string; as: 'passed' | 'approved' | 'promised'; that?: string }, context)
â”‚  â””â”€ â†’ { passed?: boolean; approved?: boolean; promised?: boolean; ... }
â”œâ”€ [â—‹] if as === 'approved' â†’ setStoneAsApproved
â”œâ”€ [~] if as === 'passed' â†’ setStoneAsPassed (now with self-review check)
â”œâ”€ [+] if as === 'promised'
â”‚  â”œâ”€ [+] validate that param exists
â”‚  â”œâ”€ [+] setStoneAsPromised({ stone, slug: that, hash, route })
â”‚  â””â”€ [+] return { promised: true, ... }
â””â”€ [â—‹] return result

formatRouteStoneEmit
â”œâ”€ [â—‹] (input: { operation: string; stone: string; ... })
â”‚  â””â”€ â†’ string
â”œâ”€ [â—‹] format header based on operation
â”œâ”€ [~] if blocked by self-review
â”‚  â””â”€ [+] prepend formatCheckYoself section before guard tree
â”œâ”€ [â—‹] format tree structure
â””â”€ [â—‹] return formatted string
```

### contract/cli/route

```
routeDrive
â”œâ”€ [+] export const routeDrive = async (): Promise<void>
â”œâ”€ [+] parseArgs for --route (optional), --mode (optional: 'hook')
â”œâ”€ [+] call stepRouteDrive({ route, mode })
â”œâ”€ [+] if emit â†’ console.log(emit.stdout)
â””â”€ [+] exit 0

routeStoneSet
â”œâ”€ [â—‹] parseArgs for --stone, --as, --route
â”œâ”€ [+] add --that to parseArgs (for --as promised)
â”œâ”€ [~] validate: if as === 'promised' â†’ require --that
â”œâ”€ [â—‹] call stepRouteStoneSet with extended input
â””â”€ [â—‹] output result
```

### domain.roles/driver

```
getDriverRole
â”œâ”€ [â—‹] slug, name, purpose
â”œâ”€ [â—‹] readme, traits, skills, briefs
â”œâ”€ [+] hooks: {
â”‚  â””â”€ onBrain: {
â”‚     â”œâ”€ [+] onBoot: [{ command: './node_modules/.bin/rhx route.drive --mode hook', timeout: 'PT5S' }]
â”‚     â””â”€ [+] onStop: [{ command: './node_modules/.bin/rhx route.drive --mode hook', timeout: 'PT5S' }]
â”‚  }
â””â”€ [â—‹] export ROLE_DRIVER

route.drive.sh
â”œâ”€ [+] #!/usr/bin/env bash
â”œâ”€ [+] # .what = shell entrypoint for route.drive skill
â”œâ”€ [+] # .why = echo current stone and pass command
â”œâ”€ [+] set -euo pipefail
â””â”€ [+] exec node -e "import('rhachet-roles-bhrain/cli').then(m => m.cli.route.drive())" -- "$@"
```

### index.ts exports

```
cli
â”œâ”€ [â—‹] route.bind
â”œâ”€ [â—‹] route.stone.get
â”œâ”€ [â—‹] route.stone.set
â”œâ”€ [â—‹] route.stone.del
â”œâ”€ [â—‹] route.stone.judge
â””â”€ [+] route.drive
```

---

## artifact storage

### promise artifact structure

promises stored in `.route/` per extant review artifact pattern:

```
{routeDir}/
â””â”€ .route/
   â”œâ”€ $stone.guard.review.r1.$hash.$iteration.md     # extant review artifact
   â”œâ”€ $stone.guard.judge.j1.$hash.$iteration.md      # extant judge artifact
   â””â”€ $stone.guard.promise.$slug.$hash.md            # new promise artifact
```

name pattern: `{stone}.guard.promise.{slug}.{hash}.md`

example: `3.blueprint.v1.guard.promise.all-done.abc123.md`

### promise artifact content

```markdown
# promise: all-done

- stone: 3.blueprint.v1
- hash: abc123...
- timestamp: 2026-02-20T12:34:56.789Z

---

i promise i have completed the self-review for "all-done".
```

---

## guard file format

### flat array (backwards compatible)

```yaml
# $stone.guard
artifacts:
  - $stone*.md

reviews:
  - rhx review --rules .agent/**/rules/*.md --paths $stone*.md

judges:
  - rhx route.stone.judge --mechanism reviewed? --stone $stone --route $route
```

â†’ `reviews.peer = [...]`, `reviews.self = []`

### structured object (with self-reviews)

```yaml
# $stone.guard
artifacts:
  - $stone*.md

reviews:
  self:
    - slug: all-done
      say: |
        did you complete all that was requested in this stone?
        have you re-read the stone goal and verified each requirement?

    - slug: tests-pass
      say: "@briefs/self-review.tests-pass.md"

  peer:
    - rhx review --rules .agent/**/rules/*.md --paths $stone*.md

judges:
  - rhx route.stone.judge --mechanism reviewed? --stone $stone --route $route
```

â†’ `reviews.self = [{slug, say}, ...]`, `reviews.peer = [...]`

---

## test coverage

### unit tests

| file | covers |
|------|--------|
| `parseStoneGuard.test.ts` | [~] add structured reviews parse, @path expand |
| `formatCheckYoself.test.ts` | [+] check yo'self output format |
| `getStonePromises.test.ts` | [+] promise read, hash filter |
| `setStoneAsPromised.test.ts` | [+] promise write, slug validation |
| `stepRouteDrive.test.ts` | [+] drive output, route complete, silent no-op |
| `stepRouteStoneSet.test.ts` | [~] add --as promised support |

### integration tests

| file | covers |
|------|--------|
| `setStoneAsPromised.integration.test.ts` | [+] promise write to filesystem |
| `setStoneAsPassed.integration.test.ts` | [~] self-review block flow |
| `stepRouteDrive.integration.test.ts` | [+] drive with bound route |
| `stepRouteStoneSet.integration.test.ts` | [~] promise flow with filesystem |

### acceptance tests

| file | covers |
|------|--------|
| `driver.route.drive.acceptance.test.ts` | [+] route.drive skill via shell |
| `driver.route.self-review.acceptance.test.ts` | [+] self-review journey with snapshot verification |

### key test scenarios with snapshot verification

all acceptance tests use `.toMatchSnapshot()` on sanitized stdout to verify exact output format matches the vision.

```
driver.route.drive.acceptance.test.ts
â”œâ”€ [case1] route bound, stones remain
â”‚  â”œâ”€ [t0] echoes current stone content + pass command
â”‚  â””â”€ [t0.snap] stdout matches vision "route.drive (stone remains)"
â”œâ”€ [case2] route bound, all stones passed, via hook (--mode hook)
â”‚  â”œâ”€ [t0] exits silently (no output, no error)
â”‚  â””â”€ [t0.snap] stdout === '' (empty)
â”œâ”€ [case3] route bound, all stones passed, direct invocation
â”‚  â”œâ”€ [t0] echoes "route complete!"
â”‚  â””â”€ [t0.snap] stdout matches vision "route.drive (route complete)"
â””â”€ [case4] no route bound
   â”œâ”€ [t0] exits silently (no output, no error)
   â””â”€ [t0.snap] stdout === '' (empty)

driver.route.self-review.acceptance.test.ts
â”œâ”€ [case1] self-review journey with 3 reviews
â”‚  â”œâ”€ [t0] --as passed with 0/3 promised
â”‚  â”‚  â””â”€ [t0.snap] stdout matches vision "check yo'self 1/3"
â”‚  â”œâ”€ [t1] --as promised --that all-done
â”‚  â”‚  â””â”€ [t1.snap] stdout matches vision "progressed 1/3, shows 2/3"
â”‚  â”œâ”€ [t2] --as promised --that tests-pass
â”‚  â”‚  â””â”€ [t2.snap] stdout matches vision "progressed 2/3, shows 3/3"
â”‚  â”œâ”€ [t3] --as promised --that no-dead-code
â”‚  â”‚  â””â”€ [t3.snap] stdout shows guard tree (all promised, proceeds to guards)
â”‚  â””â”€ [t4] --as passed (all promised, guards pass)
â”‚     â””â”€ [t4.snap] stdout matches vision "passage = passed"
â”‚
â”œâ”€ [case2] hash invalidation resets promises
â”‚  â”œâ”€ [t0] promise all-done
â”‚  â”œâ”€ [t1] edit artifact (hash changes)
â”‚  â”œâ”€ [t2] --as passed again
â”‚  â”‚  â””â”€ [t2.snap] stdout matches vision "status = invalidated"
â”‚  â””â”€ [t3] must re-promise from 1/N
â”‚
â”œâ”€ [case3] flat reviews array (backwards compat)
â”‚  â”œâ”€ [t0] --as passed with flat reviews
â”‚  â””â”€ [t0.snap] stdout shows guard tree directly (no self-review)
â”‚
â””â”€ [case4] invalid slug error
   â”œâ”€ [t0] --as promised --that invalid-slug
   â””â”€ [t0.snap] stdout shows error + valid slug options
```

### snapshot sanitization

use `sanitizeForSnapshot()` to replace dynamic values:
- timestamps â†’ `[TIMESTAMP]`
- hashes â†’ `[HASH]`
- durations â†’ `[TIME]`
- absolute paths â†’ relative paths

this ensures snapshots are stable across runs while exact output structure is verified.

---

## output format examples

### route.drive (stone remains)

```
ğŸ¦‰ where were we?

ğŸ—¿ route.drive
   â”œâ”€ where do we go?
   â”‚  â”œâ”€ route = .behavior/v2026_02_20.my-feature
   â”‚  â””â”€ stone = 3.3.blueprint.v1
   â”‚
   â”œâ”€ are we there yet? if so, run
   â”‚  â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed
   â”‚
   â”œâ”€ here's the stone
   â”‚  â”œâ”€
   â”‚  â”‚
   â”‚  â”‚  ... stone content ...
   â”‚  â”‚
   â”‚  â””â”€
   â”‚
   â””â”€ are we there yet? if so, run
      â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed
```

### route.drive (route complete, direct invocation only)

```
ğŸ¦‰ where were we?

ğŸ—¿ route.drive
   â””â”€ route complete! ğŸ‰
```

note: when invoked via hook (onStop/onBoot) and route is complete, output is silent.

### route.stone.set --as passed (blocked by self-review)

```
ğŸ¦‰ so you're sayin' there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 3.blueprint.v1
   â””â”€ passage = blocked (self-review required)

ğŸ” check yo'self
   â”œâ”€ review.self 1/3
   â”‚  â”œâ”€ slug = all-done
   â”‚  â”œâ”€ question all, especially yourself
   â”‚  â””â”€ see the guide below
   â”‚
   â”œâ”€ promise its done? if so, run
   â”‚  â””â”€ rhx route.stone.set --stone 3.blueprint.v1 --as promised --that all-done
   â”‚
   â”œâ”€ here's the guide
   â”‚  â”œâ”€
   â”‚  â”‚
   â”‚  â”‚  did you complete all that was requested in this stone?
   â”‚  â”‚  have you re-read the stone goal and verified each requirement?
   â”‚  â”‚
   â”‚  â””â”€
   â”‚
   â””â”€ promise its done? if so, run
      â””â”€ rhx route.stone.set --stone 3.blueprint.v1 --as promised --that all-done
```

### route.stone.set --as promised (success)

```
ğŸ¦‰ so you're sayin' there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 3.blueprint.v1
   â””â”€ passage = progressed (self-review 1/3 promised)

ğŸ” check yo'self
   â”œâ”€ review.self 2/3
   â”‚  â”œâ”€ slug = tests-pass
   â”‚  â”œâ”€ question all, especially yourself
   â”‚  â””â”€ see the guide below
   â”‚
   ...
```

### route.stone.set --as passed (all promised, proceeds to guards)

```
ğŸ¦‰ so you're sayin' there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 3.blueprint.v1
   â”œâ”€ passage = passed âœ“
   â””â”€ guard
      â”œâ”€ artifacts
      â”‚  â””â”€ 3.blueprint.v1.i1.md
      â”œâ”€ reviews
      â”‚  â””â”€ r1: rhx review --rules ... --paths ...
      â”‚     â”œâ”€ finished 12.3s âœ“
      â”‚     â”œâ”€ review: .route/3.blueprint.v1.guard.review.r1.md
      â”‚     â””â”€ 0 blockers âœ“
      â””â”€ judges
         â””â”€ j1: rhx route.stone.judge --mechanism reviewed? ...
            â”œâ”€ finished 0.1s âœ“
            â””â”€ passed âœ“
```

---

## implementation order

1. **domain.objects** â€” extend RouteStoneGuard, add RouteStoneGuardReviewSelfArtifact
2. **domain.operations/route/guard** â€” extend parseStoneGuard for structured reviews
3. **domain.operations/route/guard** â€” add formatCheckYoself
4. **domain.operations/route/promise** â€” add getStonePromises, setStoneAsPromised
5. **domain.operations/route/stones** â€” extend setStoneAsPassed with promise check
6. **domain.operations/route** â€” extend stepRouteStoneSet for --as promised
7. **domain.operations/route** â€” add stepRouteDrive
8. **contract/cli/route** â€” add routeDrive, extend routeStoneSet
9. **domain.roles/driver** â€” add hooks, add route.drive.sh skill
10. **index.ts** â€” export cli.route.drive
11. **blackbox** â€” add fixtures, extend invokeRouteSkill, add tests
12. **tests** â€” unit â†’ integration â†’ acceptance

---

## dependencies

### extant npm packages (no new deps required)

- `domain-objects` â€” DomainLiteral base class
- `hash-fns` â€” for sourceHash computation (already used by computeStoneReviewInputHash)
- `rhachet` â€” Role hooks interface

### extant operations to reuse

- `computeStoneReviewInputHash` â€” hash artifacts for promise validation
- `computeNextStones` â€” determine current stone for route.drive
- `getRouteBindByBranch` â€” lookup bound route
- `getAllStones` â€” enumerate stones
- `formatGuardTree` â€” format guard results

---

## citations

1. `src/domain.operations/route/guard/parseStoneGuard.ts` â€” guard parse pattern to extend
2. `src/domain.objects/Driver/RouteStoneGuard.ts` â€” guard domain object to extend
3. `src/domain.operations/route/stones/setStoneAsPassed.ts` â€” pass flow to extend
4. `src/domain.operations/route/stepRouteStoneSet.ts` â€” set dispatch to extend
5. `src/domain.operations/route/formatRouteStoneEmit.ts` â€” output format pattern
6. `src/domain.operations/route/guard/formatGuardTree.ts` â€” tree format pattern
7. `src/domain.operations/route/guard/computeStoneReviewInputHash.ts` â€” hash pattern to reuse
8. `src/domain.roles/driver/getDriverRole.ts` â€” role definition to extend
9. `blackbox/.test/invokeRouteSkill.ts` â€” test utility to extend
10. `.behavior/v2026_02_20.route-drive/1.vision.md` â€” output format specification
11. `.behavior/v2026_02_20.route-drive/2.1.criteria.blackbox.md` â€” behavioral requirements
12. `.behavior/v2026_02_20.route-drive/3.1.research.patterns._.code.prod.v1.i1.md` â€” production patterns
13. `.behavior/v2026_02_20.route-drive/3.1.research.patterns._.code.test.v1.i1.md` â€” test patterns
