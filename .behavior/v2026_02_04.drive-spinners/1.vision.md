# vision: drive-spinners

## the outcome world

### before

when a robot navigates a guarded stone, the terminal goes silent. seconds pass. maybe 10, maybe 30, maybe 60. the human stares at a frozen cursor and wonders:

- is it stuck?
- which review is active?
- did the judge fail or is it still at work?
- should i cancel and retry?

the silence breeds uncertainty. the human reaches for ctrl+c more often than they should.

### after

the terminal comes alive while a stone is passed. progress unfolds in two phases.

**phase 1: the plan tree** â€” stderr emits the full guard tree structure as a static snapshot. the human sees the full scope of work ahead:

```
ðŸ—¿ route.stone.set
   â”œâ”€ stone = 3.1.research.domain
   â””â”€ guard
      â”œâ”€ artifacts
      â”‚  â””â”€ 3.1.research.domain._.v1.md
      â”œâ”€ reviews
      â”‚  â”œâ”€ r1: reviewer/reflect
      â”‚  â”‚  â””â”€ Â· queued
      â”‚  â””â”€ r2: reviewer/review
      â”‚     â””â”€ Â· cached
      â””â”€ judges
         â”œâ”€ j1: reviewed?
         â”‚  â””â”€ Â· queued
         â””â”€ j2: approved?
            â””â”€ Â· queued
```

**phase 2: the active line** â€” as each review or judge starts, stderr prints its result line and overwrites only the last line with a spinner. no multi-line overwrite, no cursor-up â€” just `\r` on the final line. this avoids terminal overwrite hazards (resize, line wrap, scrollback).

while r1 runs, the last line shows:

```
      â”‚  â”‚  â””â”€ inflight 4.2s â ¹
```

when r1 finishes, the spinner is replaced with a checkmark on the same line via `\r`, then result details print below:

```
      â”‚  â”‚  â”œâ”€ finished 12.3s âœ“
      â”‚  â”‚  â”œâ”€ 2 blockers ðŸ”´
      â”‚  â”‚  â””â”€ 1 nitpick ðŸŸ 
```

then the next item starts its spinner on a new last line. the tree grows downward, line by line. the human always sees the full plan above and the active progress at the bottom.

the colored circles draw the eye to issues. the cached indicator signals efficiency.

### the "aha" moment

the human watches a guard with 3 reviews and 2 judges. they see:

1. r1 runs fresh (new artifact) â†’ 8.2s â†’ 0 blockers
2. r2 hits cache (same artifact as before) â†’ instant
3. r3 runs fresh â†’ 15.1s â†’ 1 blocker ðŸ”´
4. j1 runs â†’ 2.1s â†’ passed
5. j2 runs â†’ 0.3s â†’ failed (blockers > threshold)

the tree shows exactly why passage was blocked. no mystery. no need to dig through `.route/` files. the answer is right there.

---

## user experience

### usecases

| goal | what they see |
|------|---------------|
| monitor progress | spinner with elapsed time, which command is active |
| understand delays | see which review/judge is slow, not just "work is in progress" |
| verify cache hits | `Â· cached` indicator confirms prior work is reused |
| diagnose failures | issue counts with colored indicators (ðŸ”´ blockers, ðŸŸ  nitpicks) |
| estimate completion | know how many reviews/judges remain |

### contract inputs & outputs

**stderr phase 1 (plan tree, emitted once):**
```
ðŸ—¿ route.stone.set
   â”œâ”€ stone = 1.vision
   â””â”€ guard
      â”œâ”€ artifacts
      â”‚  â””â”€ 1.vision.v1.md
      â”œâ”€ reviews
      â”‚  â””â”€ r1: reviewer/reflect
      â”‚     â””â”€ Â· queued
      â””â”€ judges
         â””â”€ j1: reviewed?
            â””â”€ Â· queued
```

**stderr phase 2 (active line, overwrites via `\r`):**

while r1 runs:
```
      â”‚     â””â”€ inflight 2.1s â ¹
```

when r1 finishes, the spinner is replaced with a checkmark on the same line via `\r`, then result details print below:
```
      â”‚     â”œâ”€ finished 12.4s âœ“
      â”‚     â”œâ”€ 3 blockers ðŸ”´
      â”‚     â””â”€ 1 nitpick ðŸŸ 
```

then the next item starts on a new last line. only the last line is ever overwritten â€” no cursor-up, no multi-line rewrite. safe on resize, line wrap, and non-tty.

**stdout (final emit):**
```
ðŸ—¿ route.stone.set
   â”œâ”€ stone = 1.vision
   â”œâ”€ passage = blocked
   â””â”€ guard
      â”œâ”€ artifacts
      â”‚  â””â”€ 1.vision.v1.md
      â”œâ”€ reviews
      â”‚  â””â”€ r1: reviewer/reflect
      â”‚     â”œâ”€ finished 12.4s âœ“
      â”‚     â”œâ”€ review: .route/1.vision.guard.review.i1.abc123.r1.md
      â”‚     â”œâ”€ 3 blockers ðŸ”´
      â”‚     â””â”€ 1 nitpick ðŸŸ 
      â””â”€ judges
         â””â”€ j1: reviewed?
            â”œâ”€ finished 0.8s âœ—
            â”œâ”€ judge: .route/1.vision.guard.judge.i1p1.abc123.def456.j1.md
            â””â”€ reason: blockers exceed threshold (3 > 0)
```

the final emit is a clean snapshotâ€”no spinners, no animation artifacts, just the facts.

### timelines

1. **instant** (0-100ms): plan tree emitted to stderr â€” full scope visible
2. **short** (100ms-2s): cached reviews/judges print result lines immediately
3. **medium** (2s-30s): fresh reviews run with active spinner on last line
4. **long** (30s+): elapsed timer on last line keeps human informed, no panic

---

## mental model

### how users describe it

> "it's like a build pipeline for thought milestones. you see each review and judge tick through, know which are cached, and spot blockers instantly via the red circles."

### analogies

| concept | analogy |
|---------|---------|
| guard tree | ci/cd pipeline stages |
| spinner | load indicator on a slow api call |
| cached indicator | browser cache hit |
| blocker circles | test failure badges |
| elapsed timer | download progress |

### terminology

| user says | system term |
|-----------|-------------|
| "the review is active" | review inflight |
| "it hit cache" | review/judge cached |
| "it failed" | judge failed |
| "there are blockers" | review.blockers > 0 |
| "let me approve it" | setStoneAsApproved |

---

## evaluation

### how well does it solve the goals?

| goal | solution | score |
|------|----------|-------|
| eliminate uncertainty | spinner + timer shows exactly what happens | âœ… |
| surface cached work | `Â· cached` indicator | âœ… |
| diagnose failures | issue counts + judge reasons inline | âœ… |
| reduce false cancellations | progress visibility â†’ human waits appropriately | âœ… |

### pros

1. **transparency**: no more "what is it up to?" moments
2. **efficiency signal**: cached indicators prove the system is smart
3. **scannable output**: tree structure with emoji badges â†’ instant comprehension
4. **dual output**: stderr for live, stdout for final â†’ works in pipelines and terminals

### cons

1. **terminal noise**: more output, though structured
2. **plan tree is static**: the plan tree shows initial state only â€” results appear below it as lines accumulate

### edge cases & pit of success

| edge case | how to handle |
|-----------|---------------|
| no reviews/judges | tree shows "auto-pass" or omits guard section |
| all cached | plan tree shows all `Â· cached`, no spinner phase needed |
| review fails mid-run | shows partial results + failure indicator |
| terminal resize | safe â€” only the last line is overwritten via `\r` |
| non-tty / ci | plan tree prints as static lines, spinner degrades to periodic line prints |
| very long review names | truncate with `...` to fit terminal width |
| parallel reviews | show all inflight simultaneously (if parallelized in future) |

---

## summary

the vision is simple: **make the invisible visible**.

when a human watches a guard execute, they should see exactly:
- what's active (which review/judge)
- how long it's been active (elapsed timer)
- what's cached (instant feedback)
- what the results are (blockers, nitpicks, pass/fail)

no more frozen terminals. no guesswork. the guard tree tells the story in real-time.
