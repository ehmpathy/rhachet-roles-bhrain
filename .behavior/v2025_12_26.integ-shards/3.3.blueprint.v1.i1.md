# blueprint: integration test sharding with explicit + dynamic allocation

## overview

implement a hybrid sharding strategy for integration tests:
- **explicit shards**: slow tests get dedicated shards (1 shard per explicit entry)
- **dynamic shards**: remaining tests distributed via Jest's `--shard` across N shards

this enables faster CI while using free GitHub-hosted runners (2-core `ubuntu-24.04`).

---

## config file

**path**: `jest.integration.shards.jsonc`

```jsonc
{
  // explicit shards â€” each entry becomes one dedicated shard
  // use for slow tests that would bottleneck dynamic distribution
  "explicit": [
    {
      "patterns": ["src/roles/reviewer/skills/reflect/reflect.casePriorRules.integration.test.ts"]
    },
    {
      "patterns": ["src/roles/reviewer/skills/reflect/reflect.caseTypescriptQuality.integration.test.ts"]
    }
  ],

  // dynamic shards â€” remaining tests (not in explicit) distributed via Jest --shard
  "dynamic": {
    "shards": 3
  }
}
```

**total shards** = `explicit.length + dynamic.shards` = 2 + 3 = 5

---

## workflow changes

### 1. setup-shards job

**inputs**: reads `jest.integration.shards.jsonc`

**outputs**:
- `enabled`: `'true'` if config exists, `'false'` otherwise
- `matrix`: JSON array of shard configs (only if enabled)
- `explicit-patterns`: all explicit patterns joined (for `--testPathIgnorePatterns`)

**logic**:
```bash
# check if config exists
if [[ ! -f jest.integration.shards.jsonc ]]; then
  echo "::notice::jest.integration.shards.jsonc not found, sharding disabled"
  echo 'enabled=false' >> $GITHUB_OUTPUT
  exit 0
fi

echo 'enabled=true' >> $GITHUB_OUTPUT

# read config
config=$(cat jest.integration.shards.jsonc | jq -c '.')

# extract explicit shards
explicit=$(echo "$config" | jq -c '.explicit // []')
explicit_count=$(echo "$explicit" | jq 'length')

# extract dynamic shard count
dynamic_count=$(echo "$config" | jq '.dynamic.shards // 0')

# build matrix
matrix="[]"

# add explicit shards
for i in $(seq 0 $((explicit_count - 1))); do
  patterns=$(echo "$explicit" | jq -c ".[$i].patterns")
  matrix=$(echo "$matrix" | jq -c ". + [{\"type\": \"explicit\", \"index\": $i, \"patterns\": $patterns}]")
done

# add dynamic shards
for i in $(seq 1 $dynamic_count); do
  matrix=$(echo "$matrix" | jq -c ". + [{\"type\": \"dynamic\", \"shard\": $i, \"total\": $dynamic_count}]")
done

# collect all explicit patterns for exclusion
explicit_patterns=$(echo "$explicit" | jq -r '.[].patterns[]' | paste -sd '|')

echo "matrix=$matrix" >> $GITHUB_OUTPUT
echo "explicit-patterns=$explicit_patterns" >> $GITHUB_OUTPUT
```

### 2. test-integration-shard job (only when sharding enabled)

**condition**: `if: needs.setup-shards.outputs.enabled == 'true'`

**matrix**: `${{ fromJson(needs.setup-shards.outputs.matrix) }}`

```yaml
test-integration-shard:
  runs-on: ubuntu-24.04
  needs: [install, setup-shards]
  if: needs.setup-shards.outputs.enabled == 'true'
  strategy:
    fail-fast: false
    matrix:
      shard: ${{ fromJson(needs.setup-shards.outputs.matrix) }}
  steps:
    # ... checkout, setup-node, cache restore, aws auth, testdb ...
    - name: test:integration (${{ matrix.shard.type }} ${{ matrix.shard.index || matrix.shard.shard }})
      run: |
        if [[ "${{ matrix.shard.type }}" == "explicit" ]]; then
          # run only matching patterns
          patterns='${{ join(matrix.shard.patterns, '|') }}'
          npm run test:integration -- --testPathPattern="$patterns"
        else
          # run remaining files, excluding explicit patterns
          exclude='${{ needs.setup-shards.outputs.explicit-patterns }}'
          npm run test:integration -- \
            --testPathIgnorePatterns="$exclude" \
            --shard=${{ matrix.shard.shard }}/${{ matrix.shard.total }}
        fi
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
```

### 3. test-integration job (dual purpose â€” backwards compatible)

**behavior**:
- when sharding enabled: early return after reporting shard results
- when sharding disabled: runs tests directly (like before)

**needs**: `[install, setup-shards, test-integration-shard]`
- `test-integration-shard` will be skipped when sharding disabled, but skipped jobs don't block

```yaml
test-integration:
  runs-on: ubuntu-24.04
  needs: [install, setup-shards, test-integration-shard]
  if: always() && needs.install.result == 'success' && needs.setup-shards.result == 'success'
  steps:
    # early return: if sharding enabled, just report results
    - name: report shard results
      if: needs.setup-shards.outputs.enabled == 'true'
      run: |
        if [[ "${{ needs.test-integration-shard.result }}" == "success" ]]; then
          echo "ðŸ‘Œ all integration test shards passed"
        else
          echo "::error::integration test shards failed"
          exit 1
        fi

    # otherwise: full test flow (no sharding)
    - name: checkout
      if: needs.setup-shards.outputs.enabled != 'true'
      uses: actions/checkout@v4

    - name: set node-version
      if: needs.setup-shards.outputs.enabled != 'true'
      uses: actions/setup-node@v4
      with:
        node-version-file: ".nvmrc"

    - name: get node-modules from cache
      if: needs.setup-shards.outputs.enabled != 'true'
      uses: actions/cache/restore@v4
      with:
        path: ./node_modules
        key: ${{ needs.install.outputs.node-modules-cache-key }}

    - name: get aws auth, if creds supplied
      if: needs.setup-shards.outputs.enabled != 'true' && inputs.creds-aws-role-arn
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.creds-aws-role-arn }}
        aws-region: ${{ inputs.creds-aws-region }}

    - name: start:testdb
      if: needs.setup-shards.outputs.enabled != 'true'
      run: npm run start:testdb --if-present

    - name: start:livedb:dev
      if: needs.setup-shards.outputs.enabled != 'true'
      run: npm run start:livedb:dev --if-present

    - name: test:integration
      if: needs.setup-shards.outputs.enabled != 'true'
      run: THOROUGH=true npm run test:integration
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
```

**note**: using `!= 'true'` instead of `== 'false'` handles edge cases where output might be empty.

---

## example execution

given config:
```jsonc
{
  "explicit": [
    { "patterns": ["**/reflect.casePriorRules.integration.test.ts"] },
    { "patterns": ["**/reflect.caseTypescriptQuality.integration.test.ts"] }
  ],
  "dynamic": { "shards": 3 }
}
```

**matrix generated**:
```json
[
  { "type": "explicit", "index": 0, "patterns": ["**/reflect.casePriorRules.integration.test.ts"] },
  { "type": "explicit", "index": 1, "patterns": ["**/reflect.caseTypescriptQuality.integration.test.ts"] },
  { "type": "dynamic", "shard": 1, "total": 3 },
  { "type": "dynamic", "shard": 2, "total": 3 },
  { "type": "dynamic", "shard": 3, "total": 3 }
]
```

**jobs spawned**:

| Job | Type | Command |
|-----|------|---------|
| test-integration-shard (explicit 0) | explicit | `--testPathPattern="**/reflect.casePriorRules.integration.test.ts"` |
| test-integration-shard (explicit 1) | explicit | `--testPathPattern="**/reflect.caseTypescriptQuality.integration.test.ts"` |
| test-integration-shard (dynamic 1) | dynamic | `--testPathIgnorePatterns="..." --shard=1/3` |
| test-integration-shard (dynamic 2) | dynamic | `--testPathIgnorePatterns="..." --shard=2/3` |
| test-integration-shard (dynamic 3) | dynamic | `--testPathIgnorePatterns="..." --shard=3/3` |

---

## files to modify

1. **create**: `jest.integration.shards.jsonc`
   - config file defining explicit + dynamic shards
   - optional â€” if missing, tests run without sharding

2. **modify**: `.github/workflows/.test.yml`
   - update `setup-shards` job to read config and output `enabled` flag
   - add `test-integration-shard` job (runs only when sharding enabled)
   - update `test-integration` job to be dual-purpose:
     - early return with shard results when sharding enabled
     - full test flow when sharding disabled (backwards compatible)
   - remove `shards-integration` workflow input (now config-driven)

---

## edge cases

### no explicit shards
```jsonc
{ "explicit": [], "dynamic": { "shards": 4 } }
```
- matrix contains only dynamic shards
- `explicit-patterns` is empty, `--testPathIgnorePatterns` is skipped

### no dynamic shards
```jsonc
{ "explicit": [...], "dynamic": { "shards": 0 } }
```
- matrix contains only explicit shards
- all tests must be covered by explicit patterns (or they won't run)

### config file missing
- `setup-shards` outputs `enabled=false`
- `test-integration-shard` is skipped
- `test-integration` runs tests directly (no matrix, no sharding)
- equivalent to `npm run test:integration` with no flags
- **fully backwards compatible** â€” behaves exactly as before

---

## backward compatibility

the `shards-integration` workflow input could be retained as an override:
- if set, ignores `dynamic.shards` from config
- useful for ad-hoc parallelism tuning without config changes

---

## tradeoffs

| aspect | pro | con |
|--------|-----|-----|
| explicit shards | isolate slow tests, predictable wall time | manual maintenance of patterns |
| dynamic shards | automatic distribution, no maintenance | can't control which tests run together |
| config file | version-controlled, self-documenting | another file to maintain |
| workflow complexity | flexible | more logic in setup-shards job |

---

## next steps

1. create `jest.integration.shards.jsonc` with initial config
2. update `setup-shards` job to read config
3. update `test-integration-shard` step to branch on type
4. test with a push to the branch
5. iterate based on observed wall times
