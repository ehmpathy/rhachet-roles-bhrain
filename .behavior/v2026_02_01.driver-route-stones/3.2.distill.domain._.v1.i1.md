# distill: domain objects and operations

## type aliases

```ts
type FileGlob = string;  // glob pattern (e.g., "*.research.*", "src/**/*.ts")
type DirPath = string;   // directory path (e.g., ".behavior/v2026_02_01.driver-route-stones")
type FilePath = string;  // file path (e.g., "1.vision.stone", ".route/1.vision.approved")
type Hash = string;      // content hash (e.g., sha256)
```

---

## usecases → contract

### usecase.1: get next stone
```ts
route.stone.get({
  stone: '@next-one' | '@next-all' | FileGlob,
  route: DirPath,
  say?: boolean,
}) => {
  stones: RouteStone[];
  emit: null | { stdout: string; stderr?: string; code?: number };
}
```

### usecase.2: set stone as passed
```ts
route.stone.set({
  stone: FileGlob,
  route: DirPath,
  as: 'passed',
}) => {
  passed: boolean;
  refs: {
    reviews: FilePath[];
    judges: FilePath[];
  };
  emit: null | { stdout: string; stderr?: string; code?: number };
}
```

### usecase.3: set stone as approved
```ts
route.stone.set({
  stone: FileGlob,
  route: DirPath,
  as: 'approved',
}) => {
  approved: boolean;
  emit: null | { stdout: string; stderr?: string; code?: number };
}
```

### usecase.4: delete stone
```ts
route.stone.del({
  stone: FileGlob,
  route: DirPath,
}) => {
  deleted: FilePath[];
  skipped: FilePath[];  // had artifacts
  emit: null | { stdout: string; stderr?: string; code?: number };
}
```

---

## domain.objects

### RouteStone (entity)

represents a milestone on a thought route.

```ts
interface RouteStone {
  name: string;          // e.g., "1.vision", "3.1.research.domain"
  path: FilePath;        // path to .stone or .src file
  guard: RouteStoneGuard | null;   // parsed guard if present
}
class RouteStone extends DomainEntity<RouteStone> implements RouteStone {
  public static unique = ['path'] as const;
}
```

### RouteStoneDriveArtifacts (literal)

represents the drive artifacts for a stone — what has been produced and accumulated along the drive.

```ts
interface RouteStoneDriveArtifacts {
  stone: RefByUnique<typeof RouteStone>;
  outputs: FilePath[];         // produced .md files (route artifacts)
  passage: FilePath | null;    // .passed marker under .route/ (drive artifact)
}
class RouteStoneDriveArtifacts extends DomainLiteral<RouteStoneDriveArtifacts> implements RouteStoneDriveArtifacts {}
```

### RouteStoneGuard (literal)

represents the conditions to pass a guarded stone.

```ts
interface RouteStoneGuard {
  path: FilePath;          // path to .guard file
  artifacts: FileGlob[];   // glob patterns for artifact detection
  reviews: string[];       // shell commands to run reviews
  judges: string[];        // shell commands to run judges
}
class RouteStoneGuard extends DomainLiteral<RouteStoneGuard> implements RouteStoneGuard {}
```

### RouteStoneGuardReviewArtifact (entity)

represents the output of a review run.

```ts
interface RouteStoneGuardReviewArtifact {
  stone: RefByUnique<typeof RouteStone>;
  hash: Hash;            // artifact content hash
  iteration: number;     // attempt number
  index: number;         // review index (r1, r2, etc)
  path: FilePath;        // path to review file under .route/
  blockers: number;
  nitpicks: number;
}
class RouteStoneGuardReviewArtifact extends DomainEntity<RouteStoneGuardReviewArtifact> implements RouteStoneGuardReviewArtifact {
  public static primary = ['path'] as const;
  public static unique = ['stone', 'hash', 'index'] as const;
}
```

### RouteStoneGuardJudgeArtifact (entity)

represents the output of a judge run.

```ts
interface RouteStoneGuardJudgeArtifact {
  stone: RefByUnique<typeof RouteStone>;
  hash: Hash;            // artifact content hash
  iteration: number;     // attempt number
  index: number;         // judge index (j1, j2, etc)
  path: FilePath;        // path to judge file under .route/
  passed: boolean;
  reason: string | null;
}
class RouteStoneGuardJudgeArtifact extends DomainEntity<RouteStoneGuardJudgeArtifact> implements RouteStoneGuardJudgeArtifact {
  public static primary = ['path'] as const;
  public static unique = ['stone', 'hash', 'index'] as const;
}
```

### RouteStoneGuardApproveArtifact (entity)

represents human approval for a stone.

```ts
interface RouteStoneGuardApproveArtifact {
  stone: RefByUnique<typeof RouteStone>;
  path: FilePath;  // path to .approved file under .route/
}
class RouteStoneGuardApproveArtifact extends DomainEntity<RouteStoneGuardApproveArtifact> implements RouteStoneGuardApproveArtifact {
  public static primary = ['path'] as const;
  public static unique = ['stone'] as const;
}
```

---

## domain.operations

### enumeration

| operation | input | output |
|-----------|-------|--------|
| `getAllStones` | `{ route: DirPath }` | `RouteStone[]` |
| `getAllStoneDriveArtifacts` | `{ route: DirPath }` | `RouteStoneDriveArtifacts[]` |
| `computeStoneOrderPrefix` | `{ stone: RouteStone }` | `string` |
| `computeNextStones` | `{ artifacts: RouteStoneDriveArtifacts[], query: '@next-one' \| '@next-all' }` | `RouteStone[]` |

### artifact operations

| operation | input | output |
|-----------|-------|--------|
| `getOneStoneArtifact` | `{ stone: RouteStone, route: DirPath }` | `FilePath \| null` |
| `computeStoneReviewInputHash` | `{ guard: RouteStoneGuard, route: DirPath }` | `Hash` |

### guard operations

| operation | input | output |
|-----------|-------|--------|
| `parseStoneGuard` | `{ path: FilePath }` | `RouteStoneGuard` |
| `runStoneGuardReviews` | `{ guard: RouteStoneGuard, hash: Hash, iteration: number, route: DirPath }` | `RouteStoneGuardReviewArtifact[]` |
| `runStoneGuardJudges` | `{ guard: RouteStoneGuard, hash: Hash, iteration: number, reviews: RouteStoneGuardReviewArtifact[], route: DirPath }` | `RouteStoneGuardJudgeArtifact[]` |
| `getAllStoneGuardArtifactsByHash` | `{ stone: RouteStone, hash: Hash, route: DirPath }` | `{ reviews: RouteStoneGuardReviewArtifact[], judges: RouteStoneGuardJudgeArtifact[] }` |

### state operations

| operation | input | output |
|-----------|-------|--------|
| `setStonePassage` | `{ stone: RouteStone, route: DirPath }` | `void` |
| `getOneStoneGuardApproval` | `{ stone: RouteStone, route: DirPath }` | `RouteStoneGuardApproveArtifact \| null` |
| `setStoneGuardApproval` | `{ stone: RouteStone, route: DirPath }` | `RouteStoneGuardApproveArtifact` |

### deletion operations

| operation | input | output |
|-----------|-------|--------|
| `delStone` | `{ stone: RouteStone }` | `void` |

---

## relationships

```
Route (directory)
 └── RouteStone[] (milestones)
      ├── computeStoneOrderPrefix → parallel group
      ├── RouteStoneGuard? (conditions)
      │    ├── artifacts[] → glob patterns
      │    ├── reviews[] → shell commands
      │    └── judges[] → shell commands
      └── RouteStoneDriveArtifacts (completion)
           ├── outputs[] → produced .md files
           └── passage? → .passed marker
      └── .route/ (driver artifacts)
           ├── RouteStoneGuardReviewArtifact[] → $stone.guard.review.i$iter.$hash.r$n.md
           ├── RouteStoneGuardJudgeArtifact[] → $stone.guard.judge.i$iter.$hash.j$n.md
           └── RouteStoneGuardApproveArtifact? → $stone.approved
```

---

## composition for skills

### route.stone.get
```
getAllStones
  → getAllStoneDriveArtifacts
    → computeNextStones
      → return stones (+ echo content if --say)
```

### route.stone.set --as passed
```
getOneStoneArtifact
  → (if null) error
  → (if no guard) setStonePassage
  → (if guard) parseStoneGuard
    → computeStoneReviewInputHash
      → getAllStoneGuardArtifactsByHash
        → (if prior exists for hash) reuse
        → (if no prior) runStoneGuardReviews → runStoneGuardJudges
          → (if all pass) setStonePassage
          → (if any fail) return rejection
```

### route.stone.set --as approved
```
setStoneGuardApproval
  → creates $route/.route/$stone.approved
```

### route.stone.del
```
getAllStones (filtered by glob)
  → for each: getOneStoneArtifact
    → (if artifact) skip + emit notice
    → (if null) delStone
```

---

## file structure

```
$route/
├── .route/                              # driver artifacts
│   ├── $stone.guard.review.i$iter.$hash.r1.md
│   ├── $stone.guard.review.i$iter.$hash.r2.md
│   ├── $stone.guard.judge.i$iter.$hash.j1.md
│   ├── $stone.approved
│   └── $stone.passed                    # marker for guarded stone completion
├── 1.vision.stone                       # stone definition
├── 1.vision.guard                       # guard (optional, or 1.vision.stone.guard)
├── 1.vision.md                          # artifact
├── 2.1.criteria.blackbox.stone
├── 2.1.criteria.blackbox.md
└── ...
```

**note**: `.src` is a legacy alias for `.stone` — both should be supported.

**note**: `.guard` is the default; `.stone.guard` is also supported for backwards compatibility.
