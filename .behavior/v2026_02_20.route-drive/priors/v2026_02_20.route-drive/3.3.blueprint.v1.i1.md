# blueprint: route.drive

## overview

this blueprint declares the implementation plan for route.drive â€” a GPS-like system that guides clones through routes with self-review checkpoints.

### key concept: route vs behavior

- **route** = any directory with stones (general concept)
- **behavior** = a specific type of route with wish/vision/criteria structure

routes are the general abstraction; behaviors are a specialized use case.

### architectural approach

the implementation follows extant patterns:
1. **thin shell dispatchers** â€” shell files delegate to TypeScript via `node -e "import('rhachet-roles-bhuild').then(m => m.cli.xxx())"`
2. **domain operations** â€” get/set/del operations for route, stone, and promise management
3. **domain objects** â€” Route, Stone, StoneGuard, StonePromise as DomainLiteral types
4. **CLI entry points** â€” zod-validated args exported via `cli.*`

### key flows

```
route.bind set --route $path
    â””â”€â–º route.bind CLI
        â”œâ”€â–º validate route directory has stones
        â”œâ”€â–º setBranchRouteBind({ branchName, routeDir })
        â””â”€â–º write {routeDir}/.bind/{branch}.flag

init.behavior (creates behavior, then binds route)
    â””â”€â–º init.behavior CLI
        â”œâ”€â–º create behavior structure (0.wish.md, etc.)
        â”œâ”€â–º [+] invoke route.bind set internally
        â””â”€â–º echo confirmation

onStop hook fires
    â””â”€â–º route.drive CLI
        â”œâ”€â–º getBranchRouteBind() â†’ routeDir | null
        â”œâ”€â–º if !routeDir â†’ exit 0 (silent)
        â”œâ”€â–º getStoneByRoute({ routeDir, which: 'current' }) â†’ stone | null
        â”œâ”€â–º if !stone â†’ echo "route complete!"
        â””â”€â–º echo stone content + pass command

route.stone.set --as passed
    â””â”€â–º route.stone.set CLI
        â”œâ”€â–º getBranchRouteBind() â†’ routeDir
        â”œâ”€â–º getStoneByRoute({ routeDir, stone }) â†’ stone
        â”œâ”€â–º parseStoneYamlFrontmatter({ stone }) â†’ guard config
        â”œâ”€â–º getStonePromises({ stone }) â†’ promises
        â”œâ”€â–º if review.self && unpromised â†’ block + echo guide + show promise cmd
        â””â”€â–º if all promised â†’ proceed to peer review (extant)

route.stone.set --as promised --that $slug
    â””â”€â–º route.stone.set CLI
        â”œâ”€â–º validateSlug({ slug, stone }) â†’ valid | invalid
        â”œâ”€â–º if invalid â†’ reject + echo valid options
        â”œâ”€â–º setStonePromise({ stone, slug }) â†’ promise artifact
        â””â”€â–º echo acknowledgment + next step
```

---

## filediffs treestruct

```
src/
â”œâ”€ contract/
â”‚  â””â”€ cli/
â”‚     â”œâ”€ [+] route.bind.ts               # route bind get/set/del CLI
â”‚     â”œâ”€ [+] route.drive.ts              # onStop hook CLI entry
â”‚     â”œâ”€ [+] route.stone.get.ts          # stone query CLI entry
â”‚     â”œâ”€ [+] route.stone.set.ts          # stone mutation CLI entry
â”‚     â””â”€ [~] init.behavior.ts            # invoke route.bind set
â”‚
â”œâ”€ domain.objects/
â”‚  â”œâ”€ [+] Route.ts                       # route domain literal
â”‚  â”œâ”€ [+] Stone.ts                       # stone domain literal
â”‚  â”œâ”€ [+] StoneGuard.ts                  # guard config literal
â”‚  â””â”€ [+] StonePromise.ts                # promise event literal
â”‚
â”œâ”€ domain.operations/
â”‚  â””â”€ route/
â”‚     â”œâ”€ bind/
â”‚     â”‚  â”œâ”€ [+] getBranchRouteBind.ts    # get bound route for branch
â”‚     â”‚  â”œâ”€ [+] getBranchRouteBind.test.ts
â”‚     â”‚  â”œâ”€ [+] setBranchRouteBind.ts    # bind branch to route
â”‚     â”‚  â”œâ”€ [+] setBranchRouteBind.test.ts
â”‚     â”‚  â”œâ”€ [+] delBranchRouteBind.ts    # unbind branch from route
â”‚     â”‚  â”œâ”€ [+] delBranchRouteBind.test.ts
â”‚     â”‚  â””â”€ [+] index.ts
â”‚     â”‚
â”‚     â”œâ”€ stone/
â”‚     â”‚  â”œâ”€ [+] getStoneByRoute.ts       # get current/specific stone
â”‚     â”‚  â”œâ”€ [+] getStoneByRoute.test.ts
â”‚     â”‚  â”œâ”€ [+] getAllStonesByRoute.ts   # enumerate all stones
â”‚     â”‚  â”œâ”€ [+] getAllStonesByRoute.test.ts
â”‚     â”‚  â”œâ”€ [+] parseStoneYamlFrontmatter.ts
â”‚     â”‚  â”œâ”€ [+] parseStoneYamlFrontmatter.test.ts
â”‚     â”‚  â””â”€ [+] index.ts
â”‚     â”‚
â”‚     â”œâ”€ promise/
â”‚     â”‚  â”œâ”€ [+] getStonePromises.ts      # get promise artifacts
â”‚     â”‚  â”œâ”€ [+] getStonePromises.test.ts
â”‚     â”‚  â”œâ”€ [+] setStonePromise.ts       # record promise
â”‚     â”‚  â”œâ”€ [+] setStonePromise.integration.test.ts
â”‚     â”‚  â”œâ”€ [+] computeSourceHash.ts     # hash source artifacts
â”‚     â”‚  â”œâ”€ [+] computeSourceHash.test.ts
â”‚     â”‚  â””â”€ [+] index.ts
â”‚     â”‚
â”‚     â”œâ”€ status/
â”‚     â”‚  â”œâ”€ [+] setStoneStatus.ts        # mark stone passed
â”‚     â”‚  â”œâ”€ [+] setStoneStatus.integration.test.ts
â”‚     â”‚  â””â”€ [+] index.ts
â”‚     â”‚
â”‚     â””â”€ [+] index.ts                    # barrel export
â”‚
â”œâ”€ domain.roles/
â”‚  â””â”€ behaver/
â”‚     â”œâ”€ [~] getBehaverRole.ts           # add onStop hook
â”‚     â”œâ”€ inits/
â”‚     â”‚  â””â”€ claude.hooks/
â”‚     â”‚     â””â”€ [+] sessionstop.route-drive.sh
â”‚     â””â”€ skills/
â”‚        â”œâ”€ [+] route.bind.sh            # route bind skill
â”‚        â”œâ”€ [+] route.drive.sh           # route drive skill
â”‚        â”œâ”€ [+] route.stone.get.sh
â”‚        â””â”€ [+] route.stone.set.sh
â”‚
â”œâ”€ [~] index.ts                          # add cli exports
â”‚
â””â”€ infra/
   â””â”€ [â—‹] cli/                           # reuse getCliArgs
   â””â”€ [â†] flattenBranchName              # reuse from behavior/bind

blackbox/
â””â”€ role=behaver/
   â”œâ”€ [+] skill.route.bind.acceptance.test.ts
   â”œâ”€ [+] skill.route.drive.acceptance.test.ts
   â”œâ”€ [+] skill.route.stone.get.acceptance.test.ts
   â””â”€ [+] skill.route.stone.set.acceptance.test.ts
```

---

## codepaths treestruct

### domain.objects

```
Route
â”œâ”€ [+] interface Route
â”‚  â”œâ”€ path: string                       # full path to route directory
â”‚  â”œâ”€ name: string                       # directory name
â”‚  â””â”€ stones: Stone[]                    # ordered stones in route
â”œâ”€ [+] class Route extends DomainLiteral<Route>
â”‚  â”œâ”€ primary = ['path']
â”‚  â””â”€ unique = ['path']
â””â”€ [+] export { Route }

Stone
â”œâ”€ [+] interface Stone
â”‚  â”œâ”€ path: string                       # full path to stone file
â”‚  â”œâ”€ name: string                       # extracted name (e.g., "3.3.blueprint.v1")
â”‚  â”œâ”€ order: number                      # sort order derived from name
â”‚  â”œâ”€ status: 'unpassed' | 'passed'      # derived from .passed marker
â”‚  â””â”€ guard: StoneGuard | null           # parsed from frontmatter
â”œâ”€ [+] class Stone extends DomainLiteral<Stone>
â”‚  â”œâ”€ primary = ['path']
â”‚  â””â”€ unique = ['path']
â””â”€ [+] export { Stone }

StoneGuard
â”œâ”€ [+] interface StoneGuard
â”‚  â””â”€ review: { self: ReviewSelf[] }
â”œâ”€ [+] interface ReviewSelf
â”‚  â”œâ”€ slug: string                       # identifier for promise
â”‚  â””â”€ say: string                        # guide content (inline or expanded @path)
â””â”€ [+] class StoneGuard extends DomainLiteral<StoneGuard>

StonePromise
â”œâ”€ [+] interface StonePromise
â”‚  â”œâ”€ slug: string                       # review.self slug
â”‚  â”œâ”€ stonePath: string                  # stone this promise applies to
â”‚  â”œâ”€ sourceHash: string                 # hash of source artifacts at promise time
â”‚  â””â”€ timestamp: string                  # ISO timestamp
â””â”€ [+] class StonePromise extends DomainLiteral<StonePromise>
```

### domain.operations/route/bind

```
getBranchRouteBind
â”œâ”€ [+] (input: { branchName?: string }, context?: { cwd?: string })
â”‚  â””â”€ â†’ { routeDir: string | null; binds: string[] }
â”œâ”€ [+] if !branchName â†’ getCurrentBranch()
â”œâ”€ [â†] flattenBranchName                  # reuse from behavior/bind
â”œâ”€ [+] search for any dir with .bind/{flattenedBranch}.flag
â”‚  â”œâ”€ check .behavior/*/.bind/
â”‚  â”œâ”€ check .route/*/.bind/
â”‚  â””â”€ check any dir with stones + .bind/
â””â”€ [+] return first match or null

setBranchRouteBind
â”œâ”€ [+] (input: { branchName: string; routeDir: string }, context?: { cwd?: string })
â”‚  â””â”€ â†’ { success: boolean; message: string }
â”œâ”€ [+] validate not protected branch (main, master)
â”œâ”€ [+] validate routeDir has stones (*.md files)
â”œâ”€ [+] check for extant bind (fail if already bound elsewhere)
â”œâ”€ [â†] flattenBranchName
â”œâ”€ [+] write {routeDir}/.bind/{flattenedBranch}.flag
â””â”€ [+] return success

delBranchRouteBind
â”œâ”€ [+] (input: { branchName: string }, context?: { cwd?: string })
â”‚  â””â”€ â†’ { success: boolean; message: string }
â”œâ”€ [+] find extant bind via getBranchRouteBind
â”œâ”€ [+] if !found â†’ return success (idempotent)
â”œâ”€ [+] remove .bind/{flattenedBranch}.flag
â””â”€ [+] return success
```

### domain.operations/route/stone

```
getStoneByRoute
â”œâ”€ [+] (input: { routeDir: string; which: 'current' | 'next' | string })
â”‚  â””â”€ â†’ Stone | null
â”œâ”€ [+] enumerate stones in routeDir
â”‚  â”œâ”€ glob: *.md except 0.wish, .ref.*, .bind/, .guard/
â”‚  â””â”€ parse name, order, status
â”œâ”€ [+] determine which stone
â”‚  â”œâ”€ 'current' â†’ first unpassed
â”‚  â”œâ”€ 'next' â†’ stone after current
â”‚  â””â”€ string â†’ find by name
â””â”€ [+] parse yaml frontmatter if present

getAllStonesByRoute
â”œâ”€ [+] (input: { routeDir: string })
â”‚  â””â”€ â†’ Stone[]
â”œâ”€ [+] glob for stone files
â”œâ”€ [+] parse each into Stone
â””â”€ [+] sort by order

parseStoneYamlFrontmatter
â”œâ”€ [+] (input: { content: string }, context?: { cwd?: string })
â”‚  â””â”€ â†’ StoneGuard | null
â”œâ”€ [+] extract yaml between --- markers
â”œâ”€ [+] parse yaml with js-yaml
â”œâ”€ [+] validate guard.review.self shape
â””â”€ [+] expand @path/to/brief.md references
```

### domain.operations/route/promise

```
getStonePromises
â”œâ”€ [+] (input: { stone: Stone })
â”‚  â””â”€ â†’ StonePromise[]
â”œâ”€ [+] read .guard/promises/{stoneName}/*.json
â””â”€ [+] filter by current sourceHash validity

setStonePromise
â”œâ”€ [+] (input: { stone: Stone; slug: string; routeDir: string })
â”‚  â””â”€ â†’ StonePromise
â”œâ”€ [+] validate slug against stone.guard.review.self
â”œâ”€ [+] compute sourceHash
â”œâ”€ [+] write promise artifact to .guard/promises/{stoneName}/{slug}.json
â””â”€ [+] return promise

computeSourceHash
â”œâ”€ [+] (input: { routeDir: string })
â”‚  â””â”€ â†’ string
â”œâ”€ [+] glob source files (*.src, *.md except .guard/)
â”œâ”€ [+] sort paths for determinism
â””â”€ [+] hash concatenated content
```

### domain.operations/route/status

```
setStoneStatus
â”œâ”€ [+] (input: { stone: Stone; status: 'passed'; routeDir: string })
â”‚  â””â”€ â†’ { success: boolean; blocked?: boolean; nextReview?: ReviewSelf }
â”œâ”€ [+] check self-review completion
â”‚  â”œâ”€ get all review.self slugs
â”‚  â”œâ”€ get all valid promises
â”‚  â””â”€ if absent â†’ return blocked + nextReview
â”œâ”€ [+] if all promised â†’ write .guard/passed/{stoneName}.flag
â””â”€ [+] return success
```

### contract/cli

```
route.bind
â”œâ”€ [+] schemaOfArgs = z.object({
â”‚  â”œâ”€ named: { route: optional, dir: optional }
â”‚  â””â”€ ordered: ['get' | 'set' | 'del']
â”‚  })
â”œâ”€ [+] export const routeBind = (): void
â”œâ”€ [+] dispatch by action
â”‚  â”œâ”€ 'get' â†’ getBranchRouteBind + echo result
â”‚  â”œâ”€ 'set' â†’ validate --route + setBranchRouteBind
â”‚  â””â”€ 'del' â†’ delBranchRouteBind
â””â”€ [+] output format
   â”œâ”€ get: "bound to: {routeName}" or "not bound"
   â”œâ”€ set: "âœ“ bound {branch} to {route}"
   â””â”€ del: "âœ“ unbound {branch}"

route.drive
â”œâ”€ [+] schemaOfArgs = z.object({ named: {}, ordered: [] })
â”œâ”€ [+] export const routeDrive = (): void
â”œâ”€ [+] getBranchRouteBind â†’ routeDir
â”œâ”€ [+] getStoneByRoute({ routeDir, which: 'current' }) â†’ stone
â”œâ”€ [+] output tree structure
â”‚  â”œâ”€ ğŸ¦‰ where were we?
â”‚  â”œâ”€ ğŸ—¿ route.drive tree
â”‚  â”‚  â”œâ”€ where to go (route + stone)
â”‚  â”‚  â””â”€ are we there yet? (pass command)
â”‚  â””â”€ <stone> tag with content
â””â”€ [+] handle edge cases
   â”œâ”€ no bind â†’ exit 0 (silent)
   â””â”€ all passed â†’ "route complete!"

route.stone.get
â”œâ”€ [+] schemaOfArgs = z.object({ named: { stone: optional }, ordered: [] })
â”œâ”€ [+] export const routeStoneGet = (): void
â”œâ”€ [+] get stone by name or current
â””â”€ [+] output stone info

route.stone.set
â”œâ”€ [+] schemaOfArgs = z.object({
â”‚  â”œâ”€ named: { stone: string, as: 'passed' | 'promised', that: optional }
â”‚  â””â”€ ordered: []
â”‚  })
â”œâ”€ [+] export const routeStoneSet = (): void
â”œâ”€ [+] dispatch by --as value
â”‚  â”œâ”€ 'passed' â†’ setStoneStatus flow
â”‚  â”‚  â”œâ”€ if blocked â†’ echo guide + promise command
â”‚  â”‚  â””â”€ if success â†’ echo confirmation
â”‚  â””â”€ 'promised' â†’ setStonePromise flow
â”‚     â”œâ”€ validate --that slug
â”‚     â”œâ”€ record promise
â”‚     â””â”€ echo acknowledgment + next step
â””â”€ [+] output format
   â”œâ”€ ğŸ¦‰ header phrase
   â”œâ”€ ğŸ—¿ route.stone.set tree
   â””â”€ <review.self.guide> tag if blocked
```

### init.behavior modification

```
init.behavior
â”œâ”€ [â—‹] schemaOfArgs (extant)
â”œâ”€ [â—‹] create behavior directory structure
â”œâ”€ [~] after behavior created
â”‚  â””â”€ [+] invoke setBranchRouteBind({ branchName, routeDir: behaviorDir })
â””â”€ [â—‹] echo confirmation
```

### hooks and skills

```
getBehaverRole
â”œâ”€ [â—‹] slug, name, purpose
â”œâ”€ [â—‹] hooks.onBrain.onBoot
â”œâ”€ [â—‹] hooks.onBrain.onTool
â””â”€ [~] hooks.onBrain.onStop
   â””â”€ [+] { command: 'rhachet run ... sessionstop.route-drive', timeout: 'PT5S' }

sessionstop.route-drive.sh
â”œâ”€ [+] #!/usr/bin/env bash
â”œâ”€ [+] set -uo pipefail (no -e, must exit 0)
â””â”€ [+] node -e "import('rhachet-roles-bhuild').then(m => m.cli.routeDrive())" || exit 0

route.bind.sh
â”œâ”€ [+] #!/usr/bin/env bash
â”œâ”€ [+] set -euo pipefail
â””â”€ [+] exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.routeBind())" -- "$@"

route.drive.sh
â”œâ”€ [+] #!/usr/bin/env bash
â”œâ”€ [+] set -euo pipefail
â””â”€ [+] exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.routeDrive())" -- "$@"

route.stone.get.sh
â”œâ”€ [+] #!/usr/bin/env bash
â”œâ”€ [+] set -euo pipefail
â””â”€ [+] exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.routeStoneGet())" -- "$@"

route.stone.set.sh
â”œâ”€ [+] #!/usr/bin/env bash
â”œâ”€ [+] set -euo pipefail
â””â”€ [+] exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.routeStoneSet())" -- "$@"
```

### index.ts exports

```
cli
â”œâ”€ [â—‹] bindBehavior
â”œâ”€ [â—‹] bootBehavior
â”œâ”€ [â—‹] ... (extant)
â”œâ”€ [+] routeBind
â”œâ”€ [+] routeDrive
â”œâ”€ [+] routeStoneGet
â””â”€ [+] routeStoneSet
```

---

## artifact storage

### .bind/ directory structure

```
{routeDir}/
â””â”€ .bind/
   â””â”€ {flattenedBranch}.flag             # empty file, presence = bound
```

works for both:
- `.behavior/v2026_02_20.my-feature/.bind/vlad.my-feature.flag`
- `.route/my-route/.bind/vlad.my-route.flag`
- `any/dir/with/stones/.bind/branch.flag`

### .guard/ directory structure

```
{routeDir}/
â””â”€ .guard/
   â”œâ”€ promises/
   â”‚  â””â”€ {stoneName}/
   â”‚     â”œâ”€ {slug}.json                  # promise artifact
   â”‚     â””â”€ ...
   â””â”€ passed/
      â””â”€ {stoneName}.flag                # empty file, presence = passed
```

### promise artifact schema

```json
{
  "slug": "all-done",
  "stonePath": ".behavior/v2026_test/3.3.blueprint.v1.md",
  "sourceHash": "sha256:abc123...",
  "timestamp": "2026-02-20T12:34:56.789Z"
}
```

---

## test coverage

### unit tests

| file | covers |
|------|--------|
| `getBranchRouteBind.test.ts` | bind detection, multiple binds, no bind |
| `setBranchRouteBind.test.ts` | bind create, protected branch reject, duplicate reject |
| `delBranchRouteBind.test.ts` | unbind, idempotent unbind |
| `getStoneByRoute.test.ts` | current/next/specific stone lookup |
| `getAllStonesByRoute.test.ts` | stone enumeration + sort order |
| `parseStoneYamlFrontmatter.test.ts` | yaml parse, @path expand, malformed handle |
| `getStonePromises.test.ts` | promise read, hash validation, expired filter |
| `computeSourceHash.test.ts` | deterministic hash, file inclusion |

### integration tests

| file | covers |
|------|--------|
| `setBranchRouteBind.integration.test.ts` | bind write to filesystem |
| `setStonePromise.integration.test.ts` | promise write to filesystem |
| `setStoneStatus.integration.test.ts` | status update, promise check, marker write |
| `route.bind.integration.test.ts` | full CLI flow with temp repo |
| `route.drive.integration.test.ts` | full CLI flow with temp repo |
| `route.stone.set.integration.test.ts` | self-review flow with promises |

### acceptance tests

| file | covers |
|------|--------|
| `skill.route.bind.acceptance.test.ts` | bind get/set/del via rhachet dispatch |
| `skill.route.drive.acceptance.test.ts` | onStop behavior via rhachet dispatch |
| `skill.route.stone.get.acceptance.test.ts` | stone query via rhachet dispatch |
| `skill.route.stone.set.acceptance.test.ts` | pass/promise flow via rhachet dispatch |

### key test scenarios

```
route.bind
â”œâ”€ [case1] no bind extant
â”‚  â”œâ”€ [t0] get â†’ "not bound"
â”‚  â”œâ”€ [t1] set â†’ creates bind, returns success
â”‚  â””â”€ [t2] del â†’ returns success (idempotent)
â”œâ”€ [case2] bind extant
â”‚  â”œâ”€ [t0] get â†’ "bound to: {route}"
â”‚  â”œâ”€ [t1] set same â†’ success (idempotent)
â”‚  â”œâ”€ [t2] set different â†’ error (must del first)
â”‚  â””â”€ [t3] del â†’ removes bind
â””â”€ [case3] protected branch
   â””â”€ [t0] set on main â†’ error

route.drive
â”œâ”€ [case1] route bound, stones remain
â”‚  â””â”€ [t0] echoes current stone + pass command
â”œâ”€ [case2] route bound, all passed
â”‚  â””â”€ [t0] echoes "route complete!"
â””â”€ [case3] no route bound
   â””â”€ [t0] exits silently (no output)

route.stone.set --as passed
â”œâ”€ [case1] stone has review.self, no promises
â”‚  â””â”€ [t0] blocks + echoes first guide + promise command
â”œâ”€ [case2] stone has review.self, some promises
â”‚  â””â”€ [t0] blocks + echoes next unpromised guide
â”œâ”€ [case3] stone has review.self, all promises
â”‚  â””â”€ [t0] proceeds + marks passed
â”œâ”€ [case4] stone has no review.self
â”‚  â””â”€ [t0] proceeds directly
â””â”€ [case5] source changed since promises
   â””â”€ [t0] invalidates + requires fresh promises

route.stone.set --as promised --that $slug
â”œâ”€ [case1] valid slug
â”‚  â””â”€ [t0] records promise + acknowledges
â””â”€ [case2] invalid slug
   â””â”€ [t0] rejects + echoes valid options
```

---

## output format examples

### route.bind get (bound)

```
bound to: v2026_02_20.my-feature
```

### route.bind set (success)

```
âœ“ bound vlad/my-feature to .behavior/v2026_02_20.my-feature
```

### route.drive (stone remains)

```
ğŸ¦‰ where were we?

ğŸ—¿ route.drive
   â”œâ”€ where to go
   â”‚  â”œâ”€ route = .behavior/v2026_02_20.my-feature
   â”‚  â””â”€ stone = 3.3.blueprint.v1
   â””â”€ are we there yet? if so, run
      â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed


   <stone name="3.3.blueprint.v1">

       ... stone content ...

   </stone>
```

### route.stone.set --as passed (blocked)

```
ğŸ¦‰ so you're saying there's a chance?

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 3.3.blueprint.v1
   â””â”€ passage = blocked (self-review required)

ğŸ” check yo'self
   â”œâ”€ review.self 1/3
   â”‚  â”œâ”€ slug = all-done
   â”‚  â””â”€ see the guide below
   â””â”€ promise its done? if so, run
      â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as promised --that all-done


   <review.self.guide slug="all-done">

       did you complete all requested in this stone?

   </review.self.guide>
```

### route.stone.set --as promised (success)

```
ğŸ¦‰ righteous!

ğŸ—¿ route.stone.set
   â”œâ”€ stone = 3.3.blueprint.v1
   â””â”€ promised = all-done âœ“

ğŸ“ next step
   â””â”€ rhx route.stone.set --stone 3.3.blueprint.v1 --as passed
```

---

## implementation order

1. **domain.objects** â€” Route, Stone, StoneGuard, StonePromise
2. **domain.operations/route/bind** â€” get/set/del branch route bind
3. **domain.operations/route/stone** â€” parse, get, enumerate stones
4. **domain.operations/route/promise** â€” get/set promises, compute hash
5. **domain.operations/route/status** â€” set stone status
6. **contract/cli** â€” route.bind, route.drive, route.stone.get, route.stone.set
7. **contract/cli** â€” modify init.behavior to invoke setBranchRouteBind
8. **shell dispatchers** â€” skills and hook
9. **role registration** â€” add onStop hook
10. **index.ts** â€” export CLI entry points
11. **tests** â€” unit â†’ integration â†’ acceptance

---

## dependencies

### npm packages (extant)

- `domain-objects` â€” DomainLiteral base class
- `zod` â€” CLI arg validation
- `js-yaml` â€” yaml frontmatter parse
- `emoji-space-shim` â€” CLI output wrapper
- `hash-fns` â€” for sourceHash computation

### no new dependencies required

all required functionality available via extant packages.

---

## citations

1. src/domain.roles/behaver/getBehaverRole.ts â€” role registration pattern
2. src/domain.roles/behaver/inits/claude.hooks/sessionstart.boot-behavior.sh â€” hook dispatcher
3. src/contract/cli/init.behavior.ts â€” CLI entry to be modified
4. src/contract/cli/boot.behavior.ts â€” output format pattern
5. src/domain.objects/BehaviorArtifact.ts â€” domain object pattern
6. src/domain.operations/behavior/bind/flattenBranchName.ts â€” branch name flatten utility
7. .behavior/v2026_02_20.route-drive/1.vision.md â€” output format specification
8. .behavior/v2026_02_20.route-drive/2.1.criteria.blackbox.md â€” behavioral requirements
