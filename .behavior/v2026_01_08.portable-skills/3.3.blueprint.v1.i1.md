# blueprint for portable-skills

implementation plan to replicate the portable skills pattern from [PR #27: rhachet-roles-bhuild](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files) onto this repo.

---

## references

- [0.wish.md](./0.wish.md) — goal: consistency across repos, skill portability
- [3.1.research.claims._.v1.i1.md](./3.1.research.claims._.v1.i1.md) — facts, assumptions, questions
- [3.1.research.templates._.v1.i1.md](./3.1.research.templates._.v1.i1.md) — pattern documentation from bhuild

---

## current state

### shell scripts (location-dependent)

```bash
# src/domain.roles/reviewer/skills/review/review.sh
exec npx tsx "$SCRIPT_DIR/review.ts" "$@"

# src/domain.roles/reviewer/skills/reflect/reflect.sh
exec npx tsx "$SCRIPT_DIR/reflect.ts" "$@"
```

these scripts use local file paths (`$SCRIPT_DIR`), which break when rhachet symlinks them to `.agent/`.

### src/index.ts (no cli exports)

```typescript
export * from '@src/contract/sdk';
```

no `cli.*` namespace exists.

### package.json (no self-reference)

no `"rhachet-roles-bhrain": "file:."` in devDependencies.

### directory structure (no cli layer)

- ✅ `src/contract/sdk/` — exists
- ✅ `src/contract/commands/` — exists
- ❌ `src/contract/cli/` — absent
- ❌ `src/infra/cli/` — absent

---

## target state

### shell scripts (location-independent)

```bash
#!/usr/bin/env bash
set -euo pipefail
exec npx tsx -e "import('rhachet-roles-bhrain').then(m => m.cli.review())" -- "$@"
```

### src/index.ts (cli exports)

```typescript
export * from '@src/contract/sdk';

// cli entry points for portable skill dispatch
import { review } from './contract/cli/review';
import { reflect } from './contract/cli/reflect';

export const cli = {
  review,
  reflect,
};
```

### package.json (self-reference)

```json
{
  "devDependencies": {
    "rhachet-roles-bhrain": "file:."
  }
}
```

### directory structure (with cli layer)

```
src/
├── contract/
│   ├── cli/
│   │   ├── review.ts       # cli entry point
│   │   └── reflect.ts      # cli entry point
│   ├── commands/
│   └── sdk/
├── domain.operations/
│   └── reviewer/           # complex logic (already exists)
├── domain.roles/
│   └── reviewer/
│       └── skills/
│           ├── review/
│           │   └── review.sh   # thin dispatcher (updated)
│           └── reflect/
│               └── reflect.sh  # thin dispatcher (updated)
└── infra/
    └── cli/
        ├── getCliArgs.ts       # arg parse utility
        └── index.ts            # barrel export
```

---

## implementation phases

### phase 0: foundation infrastructure

create the shared cli infrastructure that all skills will use.

#### 0.1: create src/infra/cli/getCliArgs.ts

copy and adapt from bhuild's implementation:

```typescript
/**
 * .what = parse and validate cli args against a zod schema
 *
 * .why  = provides type-safe arg parse across all cli entry points
 *         with zod validation. rhachet args (repo, role, skill, s) should
 *         be declared as optional in the schema so they are parsed and ignored.
 */
import { z } from 'zod';

type CliSchemaWithRhachetArgs = z.ZodObject<{
  named: z.ZodObject<{
    repo?: z.ZodOptional<z.ZodString>;
    role?: z.ZodOptional<z.ZodString>;
    skill?: z.ZodOptional<z.ZodString>;
    s?: z.ZodOptional<z.ZodString>;
    [key: string]: z.ZodTypeAny | undefined;
  }>;
  ordered: z.ZodDefault<z.ZodArray<z.ZodString>>;
}>;

const getCliArgsRaw = (
  argv: string[],
): { named: Record<string, string>; ordered: string[] } => {
  const named: Record<string, string> = {};
  const ordered: string[] = [];

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];
    if (!arg) continue;

    // skip rhachet separator
    if (arg === '--') continue;

    // named arg: --key value or --key=value
    if (arg.startsWith('--')) {
      const eqIndex = arg.indexOf('=');
      if (eqIndex !== -1) {
        const key = arg.slice(2, eqIndex);
        const value = arg.slice(eqIndex + 1);
        named[key] = value;
      } else {
        const key = arg.slice(2);
        const nextArg = argv[i + 1];
        if (nextArg && !nextArg.startsWith('-')) {
          named[key] = nextArg;
          i++;
        } else {
          named[key] = 'true';
        }
      }
      continue;
    }

    // short arg: -k value
    if (arg.startsWith('-') && arg.length === 2) {
      const key = arg.slice(1);
      const nextArg = argv[i + 1];
      if (nextArg && !nextArg.startsWith('-')) {
        named[key] = nextArg;
        i++;
      } else {
        named[key] = 'true';
      }
      continue;
    }

    // ordered arg
    ordered.push(arg);
  }

  return { named, ordered };
};

export const getCliArgs = <T extends CliSchemaWithRhachetArgs>(input: {
  schema: T;
  argv?: string[];
}): z.infer<T> => {
  // detect if argv[1] is script filename (direct invocation) vs user arg (package import)
  const argvFirstIsScriptFilename = process.argv[1]?.includes('/cli/');
  const argvWithoutScriptFilename = argvFirstIsScriptFilename
    ? process.argv.slice(2)
    : process.argv.slice(1);
  const argv = input.argv ?? argvWithoutScriptFilename;
  const raw = getCliArgsRaw(argv);

  // validate against schema
  const result = input.schema.safeParse(raw);

  if (!result.success) {
    const errors = result.error.issues
      .map((issue) => {
        const path = issue.path.join('.');
        return `  ${path}: ${issue.message}`;
      })
      .join('\n');
    console.error('error: invalid arguments');
    console.error(errors);
    process.exit(1);
  }

  return result.data;
};
```

#### 0.2: create src/infra/cli/index.ts

```typescript
export { getCliArgs } from './getCliArgs';
```

#### 0.3: add devDependencies self-reference

update package.json:

```json
{
  "devDependencies": {
    "rhachet-roles-bhrain": "file:."
  }
}
```

---

### phase 1: convert review skill

#### 1.1: create src/contract/cli/review.ts

```typescript
/**
 * .what = cli entry point for code review skill
 *
 * .why  = enables portable invocation via package import pattern
 */
import { z } from 'zod';

import { stepReview } from '@src/domain.operations/reviewer/stepReview';
import { getCliArgs } from '@src/infra/cli';

const schemaOfArgs = z.object({
  named: z.object({
    // skill-specific args
    rules: z.string().optional(),
    diffs: z.string().optional(),
    paths: z.string().optional(),
    output: z.string().optional(),
    mode: z.enum(['soft', 'hard']).optional(),
    rapid: z.string().optional(),
    // rhachet passthrough args (optional, ignored)
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});

export const review = async (): Promise<void> => {
  const { named } = getCliArgs({ schema: schemaOfArgs });

  await stepReview({
    rules: named.rules,
    diffs: named.diffs as 'since-main' | 'since-commit' | 'since-staged' | undefined,
    paths: named.paths,
    output: named.output,
    mode: named.mode,
    rapid: named.rapid === 'true',
  });
};
```

#### 1.2: update src/domain.roles/reviewer/skills/review/review.sh

```bash
#!/usr/bin/env bash
######################################################################
# .what = shell entrypoint for code review skill
#
# .why = enables direct invocation from CLI, CI/CD, git hooks
#        via location-independent package import
#
# usage:
#   ./review.sh --rules "rules/*.md" --paths "src/*.ts" --output "review.md" --mode hard
#
# options:
#   --rules   glob pattern(s) for rule files (comma-separated)
#   --diffs   diff range: since-main, since-commit, since-staged
#   --paths   glob pattern(s) for target files (comma-separated)
#   --output  output file path for the review
#   --mode    review mode: soft (paths only) or hard (full content)
######################################################################
set -euo pipefail

exec npx tsx -e "import('rhachet-roles-bhrain').then(m => m.cli.review())" -- "$@"
```

---

### phase 2: convert reflect skill

#### 2.1: create src/contract/cli/reflect.ts

```typescript
/**
 * .what = cli entry point for reviewer.reflect skill
 *
 * .why  = enables portable invocation via package import pattern
 */
import { z } from 'zod';

import { stepReflect } from '@src/domain.operations/reviewer/stepReflect';
import { getCliArgs } from '@src/infra/cli';

const schemaOfArgs = z.object({
  named: z.object({
    // skill-specific args
    source: z.string().optional(),
    target: z.string().optional(),
    mode: z.enum(['soft', 'hard']).optional(),
    force: z.string().optional(),
    rapid: z.string().optional(),
    // rhachet passthrough args (optional, ignored)
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});

export const reflect = async (): Promise<void> => {
  const { named } = getCliArgs({ schema: schemaOfArgs });

  await stepReflect({
    source: named.source,
    target: named.target,
    mode: named.mode,
    force: named.force === 'true',
    rapid: named.rapid === 'true',
  });
};
```

#### 2.2: update src/domain.roles/reviewer/skills/reflect/reflect.sh

```bash
#!/usr/bin/env bash
######################################################################
# .what = shell wrapper for reviewer.reflect skill
#
# .why  = enables direct invocation from command line
#         via location-independent package import
#
# usage:
#   reflect.sh --source /path/to/feedback/repo --target /path/to/rules/dir
#   reflect.sh --source . --target ./briefs/practices --mode hard
#   reflect.sh --source . --target ./briefs/practices --force
#
# guarantee:
#   - validates source directory exists and has feedback
#   - validates target directory exists (or creates with --force)
#   - creates draft directory with pure/, sync/, manifest.json
#   - fail-fast on errors
######################################################################

set -euo pipefail

exec npx tsx -e "import('rhachet-roles-bhrain').then(m => m.cli.reflect())" -- "$@"
```

---

### phase 3: wire up exports

#### 3.1: update src/index.ts

```typescript
export * from '@src/contract/sdk';

// cli entry points for portable skill dispatch
import { reflect } from './contract/cli/reflect';
import { review } from './contract/cli/review';

export const cli = {
  reflect,
  review,
};
```

---

### phase 4: workflow updates

#### 4.1: ensure build before integration tests

verify `.github/workflows/.test.yml` runs `npm run build` before `test:integration`:

```yaml
- name: build
  run: npm run build

- name: test:integration
  run: THOROUGH=true npm run test:integration
```

the current `test:acceptance:locally` script already does this (`npm run build && ...`), but standalone integration tests need the build step.

---

### phase 5: documentation

#### 5.1: create portable-skills-pattern.md brief

create `.agent/repo=.this/role=any/briefs/portable-skills-pattern.md` with:
- the portable dispatch pattern
- devDependencies self-reference rationale
- cli entry point structure
- arg parse schema requirements

---

## validation checklist

after implementation, verify:

- [ ] `npm run build` completes without errors
- [ ] `npm run test:types` passes
- [ ] shell scripts work from repo root: `./src/domain.roles/reviewer/skills/review/review.sh --help`
- [ ] skills work via rhachet: `npx rhachet run --skill review --repo bhrain --role reviewer`
- [ ] skills work when symlinked: `.agent/repo=bhrain/role=reviewer/skills/review/review.sh`
- [ ] integration tests pass: `npm run test:integration`

---

## file checklist

files to create:
- [ ] `src/infra/cli/getCliArgs.ts`
- [ ] `src/infra/cli/index.ts`
- [ ] `src/contract/cli/review.ts`
- [ ] `src/contract/cli/reflect.ts`

files to update:
- [ ] `package.json` — add devDependencies self-reference
- [ ] `src/index.ts` — add cli exports
- [ ] `src/domain.roles/reviewer/skills/review/review.sh` — use package import
- [ ] `src/domain.roles/reviewer/skills/reflect/reflect.sh` — use package import

---

## risk assessment

| risk | mitigation |
|------|------------|
| tsx resolution differs between direct and package import | getCliArgs detects invocation mode via argv[1] check |
| consumer contract breakage | skills remain backward compatible (same args, same behavior) |
| self-reference breaks in ci | `file:.` is standard npm feature, works in ci with npm install |
| arg parse edge cases | zod schema validates all args with clear error messages |

---

## sources

- [PR #27: rhachet-roles-bhuild](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)
- [3.1.research.claims._.v1.i1.md](./3.1.research.claims._.v1.i1.md)
- [3.1.research.templates._.v1.i1.md](./3.1.research.templates._.v1.i1.md)
