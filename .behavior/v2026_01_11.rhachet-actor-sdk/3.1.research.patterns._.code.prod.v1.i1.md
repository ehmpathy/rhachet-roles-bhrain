# research: production codepath patterns

patterns relevant to implement brain choice for review and reflect skills

---

## pattern.1 = llm invocation via claude cli spawn [REPLACE]

### relation to wish
the wish requires skills to use `context.brain.choice.ask()` and `.act()` instead of direct claude cli spawn. this pattern must be replaced with brain choice delegation.

### citation.1
**file:** `src/domain.operations/review/invokeClaudeCode.ts:19-45`
```typescript
export const invokeClaudeCode = async (input: {
  prompt: string;
  cwd?: string;
}): Promise<{ response: object; review: string; usage: ClaudeUsage }> => {
  const output = await new Promise<string>((resolve, reject) => {
    const child = spawn('claude', ['-p', '-', '--output-format', 'json'], {
      cwd: input.cwd,
    });
```
**note:** review spawns claude cli directly with no model selection.

### citation.2
**file:** `src/domain.operations/reflect/invokeClaudeCodeForReflect.ts:47-76`
```typescript
export const invokeClaudeCodeForReflect = async <T>(input: {
  prompt: string;
  cwd?: string;
  rapid?: boolean;
}): Promise<{ response: T; usage: ReflectClaudeUsage }> => {
  // determine model and settings based on rapid flag
  // note: both models need enough turns to write multiple rules
  const model = input.rapid ? 'haiku' : 'sonnet';
  const maxTurns = input.rapid ? '50' : '30';

  // invoke claude-code cli via stdin to avoid E2BIG on large prompts
  const child = spawn('claude', [
    '-p',
    '-',
    '--output-format',
    'json',
    '--allowedTools',
    'Write',
    '--model',
    model,
    '--max-turns',
    maxTurns,
  ], ...);
```
**note:** reflect has model selection via `rapid` flag, but only two hardcoded options (haiku/sonnet).

---

## pattern.2 = cli args schema with zod [REUSE]

### relation to wish
the wish requires `--brain` flag in cli. this pattern shows how to add schema-validated args.

### citation.3
**file:** `src/infra/cli/getCliArgs.ts:78-106`
```typescript
export const getCliArgs = <T extends CliArgsSchema>(input: {
  schema: T;
  argv?: string[];
}): z.infer<T> => {
  // detect if argv[1] is entrypoint filename (direct invocation) vs user arg (package import)
  const argvFirstIsEntrypointFilename = process.argv[1]?.includes('/cli/');
  const argvWithoutEntrypointFilename = argvFirstIsEntrypointFilename
    ? process.argv.slice(2)
    : process.argv.slice(1);
  const argv = input.argv ?? argvWithoutEntrypointFilename;
  const raw = getCliArgsRaw(argv);

  // validate against schema
  const result = input.schema.safeParse(raw);
  ...
};
```

### citation.4
**file:** `src/contract/cli/reflect.ts:11-26`
```typescript
const schemaOfArgs = z.object({
  named: z.object({
    // skill-specific args
    source: z.string().optional(),
    target: z.string().optional(),
    mode: z.enum(['soft', 'hard']).optional(),
    force: z.string().optional(),
    rapid: z.string().optional(),
    // rhachet passthrough args
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});
```
**note:** `rapid` already exists as a string arg, parsed to boolean downstream. `brain` can follow same pattern.

---

## pattern.3 = hardcoded price rates per model [REMOVE]

### relation to wish
since the interface is now rhachet's BrainAtom & BrainRepl contract, local price rate logic is no longer supported. price rates will be exposed via rhachet interfaces on responses.

### action
comment out callsites with: `// todo: expose prices via rhachet BrainAtom and BrainRepl on responses`

### citation.5
**file:** `src/domain.operations/reflect/metrics/computeMetricsExpected.ts:22-30`
```typescript
  // claude sonnet price rates: $3/1M input, $15/1M output
  const inputCost =
    ((input.step1PromptTokens + input.step2PromptTokens) / 1_000_000) * 3;
  const outputCost = (estimatedOutputTokens / 1_000_000) * 15;
  const cost = inputCost + outputCost;
```

### citation.6
**file:** `src/domain.operations/reflect/metrics/computeMetricsRealized.ts:77-96`
```typescript
// claude sonnet price rates per 1M tokens:
// - input: $3
// - cache write: $3.75
// - cache read: $0.30
// - output: $15
const inputCost = (tokens.input / 1_000_000) * 3;
const cacheWriteCost = (tokens.cacheWrite / 1_000_000) * 3.75;
const cacheReadCost = (tokens.cacheRead / 1_000_000) * 0.3;
const outputCost = (tokens.output / 1_000_000) * 15;
```

### citation.7
**file:** `src/domain.operations/review/stepReview.ts:358-368`
```typescript
// calculate realized costs per token type
const realizedCosts = (() => {
  const input = (brainResult.usage.inputTokens / 1_000_000) * 3;
  const cacheWrite = (brainResult.usage.inputTokensCacheCreation / 1_000_000) * 3.75;
  const cacheRead = (brainResult.usage.inputTokensCacheRead / 1_000_000) * 0.3;
  const output = (brainResult.usage.outputTokens / 1_000_000) * 15;
  const total =
    Math.round((input + cacheWrite + cacheRead + output) * 10000) / 10000;
  return { input, cacheWrite, cacheRead, output, total };
})();
```
**note:** all three places have hardcoded sonnet price rates that must be commented out.

---

## pattern.4 = step function signature with optional args [EXTEND]

### relation to wish
the wish requires stepReview and stepReflect to accept optional `brain?: string` input.

### citation.8
**file:** `src/domain.operations/reflect/stepReflect.ts:95-105`
```typescript
export const stepReflect = async (input: {
  source: string;
  target: string;
  mode?: 'soft' | 'hard';
  force?: boolean;
  rapid?: boolean;
}): Promise<StepReflectResult> => {
  const mode = input.mode ?? 'pull';
  const force = input.force ?? false;
  const rapid = input.rapid ?? false;
```
**note:** `rapid` is optional with default. `brain` can follow same pattern with default `xai/grok/code-fast-1`.

### citation.9
**file:** `src/domain.operations/review/stepReview.ts:114-122`
```typescript
export const stepReview = async (input: {
  rules: string | string[];
  diffs?: string;
  paths?: string | string[];
  output: string;
  focus: 'pull' | 'hard';
  cwd?: string;
}): Promise<StepReviewResult> => {
  const cwd = input.cwd ?? process.cwd();
```
**note:** no rapid or model selection here. needs `brain?: string` added.

---

## pattern.5 = usage extraction from claude response [REMOVE]

### relation to wish
since the interface is now rhachet's BrainAtom & BrainRepl contract, local usage extraction is no longer supported. usage will be exposed via rhachet interfaces on responses.

### action
comment out callsites with: `// todo: expose usage via rhachet BrainAtom and BrainRepl on responses`

### citation.10
**file:** `src/domain.operations/reflect/invokeClaudeCodeForReflect.ts:10-15,174-185`
```typescript
interface ReflectClaudeUsage {
  input: number;
  cacheWrite: number;
  cacheRead: number;
  output: number;
}

// extract usage from response
const usage: ReflectClaudeUsage = (() => {
  if (!claudeResponse.usage)
    throw new UnexpectedCodePathError('response.usage not found', {
      claudeResponse,
    });
  return {
    input: claudeResponse.usage.input_tokens ?? 0,
    cacheWrite: claudeResponse.usage.cache_creation_input_tokens ?? 0,
    cacheRead: claudeResponse.usage.cache_read_input_tokens ?? 0,
    output: claudeResponse.usage.output_tokens ?? 0,
  };
})();
```
**note:** this extraction logic will be replaced by rhachet's BrainAtom/BrainRepl response interface.

---

## pattern.6 = rapid flag capability caveat [REMOVE]

### relation to wish
this is no longer relevant since we've replaced it with explicit `--brain` input. instead of haiku special treatment, tests will use `xai/grok/code-fast-1` since it's cheap, fast, and effective.

### action
remove `rapid` flag logic and update tests to use `--brain xai/grok/code-fast-1` for fast test runs.

### citation.11
**file:** `src/domain.operations/reflect/step2/compileReflectStep2Prompt.ts:6-21`
```typescript
/**
 * .what = compiles step 2 brain prompt for rule blend
 * .why = instructs brain to create manifest.json for blend operations
 *
 * .note = when rapid=true (haiku), SET_UPDATE is disabled because haiku cannot
 *         reliably provide required fields. this means duplicates may be produced
 *         when prior rules exist. use rapid=false (sonnet) for proper deduplication.
 */
export const compileReflectStep2Prompt = async (input: {
  targetDir: string;
  draftDir: string;
  pureDir: string;
  focus: 'pull' | 'hard';
  rapid?: boolean;
}): Promise<{ prompt: string; tokenEstimate: number }> => {
```
**note:** the `rapid` flag and its haiku-specific logic will be removed in favor of explicit `--brain` selection.

---

## summary

| pattern | disposition | rationale |
|---------|-------------|-----------|
| pattern.1 = llm invocation via claude cli spawn | [REPLACE] | replace with context.brain.choice.ask() and .act() |
| pattern.2 = cli args schema with zod | [REUSE] | add `brain` arg same way as `rapid` |
| pattern.3 = hardcoded price rates per model | [REMOVE] | comment out; todo: expose via rhachet BrainAtom/BrainRepl |
| pattern.4 = step function with optional args | [EXTEND] | add `brain?: string` to input |
| pattern.5 = usage extraction from response | [REMOVE] | comment out; todo: expose via rhachet BrainAtom/BrainRepl |
| pattern.6 = rapid flag capability caveat | [REMOVE] | replaced by explicit `--brain`; tests use xai/grok/code-fast-1 |
