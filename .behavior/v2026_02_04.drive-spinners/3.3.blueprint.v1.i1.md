# blueprint: drive-spinners

## approach

three concerns, cleanly separated:

1. **format** ‚Äî pure functions that produce tree strings from state
2. **progress** ‚Äî a `ContextCliEmit` context type that encapsulates and propagates the progress callback through the `(input, context)` pattern
3. **orchestration** ‚Äî the cli layer constructs `ContextCliEmit` and threads it through the call chain

no new dependencies. no log-update, no cli-spinners, no ink. braille frames are a constant array. `\r` overwrite on one line is trivial. the codebase already has this pattern in `stepReview.ts` lines 104-139.

---

## filediff treestruct

```
src/
  domain.objects/
    Driver/
      [+] GuardProgressEvent.ts              # progress event type (queued | inflight | cached | finished)
      [+] ContextCliEmit.ts                 # context type that encapsulates + propagates progress callbacks
  domain.operations/
    route/
      [~] formatRouteStoneEmit.ts            # add guard tree section to stdout emit
      [+] guard/formatGuardTree.ts           # pure fn: state ‚Üí tree string
      [+] guard/formatGuardTree.test.ts      # unit tests for tree format
      [~] guard/runStoneGuardReviews.ts      # accept context: ContextCliEmit, emit progress events
      [~] judges/runStoneGuardJudges.ts      # accept context: ContextCliEmit, emit progress events
      [~] stepRouteStoneSet.ts                # accept + propagate context: ContextCliEmit
      [~] stones/setStoneAsPassed.ts         # accept context: ContextCliEmit, propagate to reviews/judges
      [+] guard/genContextCliEmit.ts         # orchestrate stderr emit via progress events
      [+] guard/genContextCliEmit.test.ts    # unit tests for stderr orchestration
  contract/
    cli/
      [~] route.ts                           # construct ContextCliEmit, pass as context to stepRouteStoneSet
```

---

## codepath treestruct

```
routeStoneSet (cli)                                         [~] construct ContextCliEmit, pass as context
  ‚îî‚îÄ stepRouteStoneSet                                      [~] accept + propagate context: ContextCliEmit
     ‚îî‚îÄ setStoneAsPassed                                    [~] accept context: ContextCliEmit, propagate
        ‚îú‚îÄ findStoneByGlob                                  [‚óã] retain
        ‚îú‚îÄ getAllStoneArtifacts                              [‚óã] retain
        ‚îú‚îÄ computeStoneReviewInputHash                      [‚óã] retain
        ‚îú‚îÄ getAllStoneGuardArtifactsByHash                   [‚óã] retain
        ‚îú‚îÄ runStoneGuardReviews                              [~] accept context: ContextCliEmit
        ‚îÇ  ‚îú‚îÄ context.cliEmit.onGuardProgress({ inflight: { beganAt } })       [+]
        ‚îÇ  ‚îú‚îÄ runOneStoneGuardReview                         [‚óã] retain
        ‚îÇ  ‚îî‚îÄ context.cliEmit.onGuardProgress({ inflight: { endedAt }, outcome })  [+]
        ‚îú‚îÄ runStoneGuardJudges                               [~] accept context: ContextCliEmit
        ‚îÇ  ‚îú‚îÄ context.cliEmit.onGuardProgress({ inflight: { beganAt } })       [+]
        ‚îÇ  ‚îú‚îÄ runOneStoneGuardJudge                          [‚óã] retain
        ‚îÇ  ‚îî‚îÄ context.cliEmit.onGuardProgress({ inflight: { endedAt }, outcome })  [+]
        ‚îî‚îÄ formatRouteStoneEmit                              [~] accept guard results, emit tree
           ‚îî‚îÄ formatGuardTree                                [+] pure fn: guard results ‚Üí tree string
```

---

## domain decomposition

### domain.objects

#### ContextCliEmit

a context type that encapsulates CLI output callbacks and propagates through the `(input, context)` call chain:

```ts
interface ContextCliEmit {
  cliEmit: {
    onGuardProgress: (event: GuardProgressEvent) => void;
  };
}
```

- `onGuardProgress` is always required ‚Äî the injected callback decides whether to act on events or stay silent
- domain procedures accept `context: ContextCliEmit` as their second arg
- the cli layer constructs this context and passes it through
- tests pass `{ cliEmit: { onGuardProgress: () => {} } }` (no-op) unless they verify progress events

#### GuardProgressEvent

a declarative, standalone event with one common shape. every event carries the full context ‚Äî which stone, what happened, when. the receiver never needs ambient state to interpret an event. no booleans ‚Äî outcomes are structured objects:

```ts
interface GuardProgressEvent {
  stone: RouteStone;                // carries .name, .guard, .path

  // which guard step (phase + index identify the cmd via stone.guard.reviews[index] or stone.guard.judges[index])
  step: {
    phase: 'review' | 'judge';
    index: number;
  };

  // lifecycle (null when cached)
  inflight: {
    beganAt: IsoTimeStamp;
    endedAt: IsoTimeStamp | null;   // null while active, populated on finish
  } | null;

  // outcome (null while active or cached; populated on finish)
  outcome: {
    path: string;
    review: { blockers: number; nitpicks: number } | null;   // null for judges
    judge: { decision: 'passed' | 'failed'; reason: string | null } | null;  // null for reviews
  } | null;
}
```

`cmd` is derived from `stone.guard.reviews[step.index]` or `stone.guard.judges[step.index]` ‚Äî no redundant field. lifecycle state is expressed via `inflight` and `outcome` presence: both null = cached, inflight present + outcome null = active, outcome present = done. duration is derived from `endedAt - beganAt`.

plan-level orchestration data (artifact files, cached indices) stays in `setStoneAsPassed` ‚Äî it is not event data. `genContextCliEmit` receives only per-review and per-judge progress events.

### domain.operations

#### formatGuardTree (new, pure)

**input**: guard results (reviews, judges, artifacts, passage, stone name) ‚Äî the same data already available in `setStoneAsPassed`

**output**: multi-line tree string with box-draw characters

**contract**:

```
üóø route.stone.set
   ‚îú‚îÄ stone = 1.vision
   ‚îú‚îÄ passage = blocked
   ‚îî‚îÄ guard
      ‚îú‚îÄ artifacts
      ‚îÇ  ‚îî‚îÄ 1.vision.v1.md
      ‚îú‚îÄ reviews
      ‚îÇ  ‚îî‚îÄ r1: reviewer/reflect
      ‚îÇ     ‚îú‚îÄ finished 12.4s ‚úì
      ‚îÇ     ‚îú‚îÄ review: .route/1.vision.guard.review.i1.abc123.r1.md
      ‚îÇ     ‚îú‚îÄ 3 blockers üî¥
      ‚îÇ     ‚îî‚îÄ 1 nitpick üü†
      ‚îî‚îÄ judges
         ‚îî‚îÄ j1: reviewed?
            ‚îú‚îÄ finished 0.8s ‚úó
            ‚îú‚îÄ judge: .route/1.vision.guard.judge.i1p1.abc123.def456.j1.md
            ‚îî‚îÄ reason: blockers exceed threshold (3 > 0)
```

responsibilities:
- format artifact filenames under `artifacts` section
- format each review with `r{index}: {cmd}` label + result sub-branches
- format each judge with `j{index}: {cmd}` label + result sub-branches
- show `¬∑ cached` for cached items (no duration, no detail sub-branches)
- show `finished {dur}s ‚úì` for fresh reviews that completed
- show `finished {dur}s ‚úì` or `finished {dur}s ‚úó` for fresh judges
- show blocker/nitpick counts with `üî¥`/`üü†` only when count > 0
- show judge reason only when judge failed

this is a pure function ‚Äî no side effects, no i/o, fully unit-testable.

#### genContextCliEmit (new, side-effect orchestrator)

**input**: `{ stderr: NodeJS.WriteStream }`

**output**: returns a `ContextCliEmit` instance + a `done()` cleanup method. writes to stderr in two phases

**phase 1 ‚Äî plan tree**: before any progress events fire, the cli layer emits the full guard tree with `¬∑ queued` and `¬∑ cached` indicators to stderr. this is a static, non-animated print driven by the stone and guard data, not by a progress event.

**phase 2 ‚Äî active line**: on events with `inflight.endedAt = null`, start a spinner interval that overwrites the last stderr line via `\r`. on events with `inflight.endedAt` populated + `outcome` present, clear the interval, overwrite the spinner line with the final result, then print detail sub-branches as new lines below.

the spinner uses braille frames `['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']` at 80ms intervals, with elapsed time: `inflight {elapsed}s ‚†π`.

**non-tty fallback**: when `!process.stderr.isTTY`, skip the spinner interval. print static lines instead of `\r` overwrites.

#### formatRouteStoneEmit (update)

add a new union variant to `FormatInput` for the `'passed'` action that includes guard results:

```ts
| {
    operation: 'route.stone.set';
    stone: string;
    action: 'passed';
    passage: 'allowed' | 'blocked';
    note?: string;
    reason?: string;
    guard?: {
      artifactFiles: string[];
      reviews: Array<{ index: number; cmd: string; cached: boolean; durationSec: number | null; blockers: number; nitpicks: number; path: string }>;
      judges: Array<{ index: number; cmd: string; cached: boolean; durationSec: number | null; passed: boolean; reason: string | null; path: string }>;
    };
  }
```

when `guard` is present, delegate to `formatGuardTree` for the tree section and include it in the output.

#### setStoneAsPassed (update)

accept `context: ContextCliEmit` as second arg:

```ts
export const setStoneAsPassed = async (
  input: { stone: string; route: string },
  context: ContextCliEmit,
): Promise<...>
```

changes:
1. propagate `context` to `runStoneGuardReviews` and `runStoneGuardJudges`
2. collect guard progress data from review/judge artifacts and pass to `formatRouteStoneEmit` via the new guard field

#### runStoneGuardReviews (update)

accept `context: ContextCliEmit` as second arg:

```ts
export const runStoneGuardReviews = async (
  input: { stone: RouteStone; guard: RouteStoneGuard; hash: string; iteration: number; route: string },
  context: ContextCliEmit,
): Promise<RouteStoneGuardReviewArtifact[]>
```

changes:
- before each `runOneStoneGuardReview`, call `context.cliEmit.onGuardProgress()` with `{ phase: 'review', inflight: { beganAt, endedAt: null }, outcome: null }`
- after each `runOneStoneGuardReview`, call `context.cliEmit.onGuardProgress()` with `{ phase: 'review', inflight: { beganAt, endedAt }, outcome: { path, review: { blockers, nitpicks } } }`
- for cached reviews (those in `doneIndices`), no events emitted

#### runStoneGuardJudges (update)

accept `context: ContextCliEmit` as second arg:

```ts
export const runStoneGuardJudges = async (
  input: { stone: RouteStone; guard: RouteStoneGuard; hash: string; iteration: number; route: string },
  context: ContextCliEmit,
): Promise<RouteStoneGuardJudgeArtifact[]>
```

changes:
- before each `runOneStoneGuardJudge`, call `context.cliEmit.onGuardProgress()` with `{ phase: 'judge', inflight: { beganAt, endedAt: null }, outcome: null }`
- after each `runOneStoneGuardJudge`, call `context.cliEmit.onGuardProgress()` with `{ phase: 'judge', inflight: { beganAt, endedAt }, outcome: { path, judge: { decision, reason } } }`
- for cached judges (those in `priorPassedByIndex`), no events emitted

#### route.ts routeStoneSet (update)

construct `ContextCliEmit` via `genContextCliEmit`, pass as context:

```ts
const progress = genContextCliEmit({ stderr: process.stderr });
const result = await stepRouteStoneSet(
  { stone: options.stone, route: options.route, as: options.as },
  { cliEmit: progress.context.cliEmit },
);
progress.done();
```

`genContextCliEmit` returns `{ context: ContextCliEmit; done: () => void }`.
`progress.done()` clears any active interval and writes a final newline.

---

## test coverage

### unit tests: formatGuardTree.test.ts

| case | input | expected |
|------|-------|----------|
| [case1] reviews+judges, allowed, all fresh | 2 reviews (0 blockers, 3 blockers), 1 judge (passed) | full tree with `finished ‚úì`, blocker counts, no nitpick lines for 0 |
| [case2] reviews+judges, blocked, all fresh | 1 review (1 blocker), 1 judge (failed) | tree with `finished ‚úó`, reason line |
| [case3] some cached reviews | 1 cached + 1 fresh review, 1 judge | cached shows `¬∑ cached`, fresh shows `finished ‚úì` |
| [case4] all cached | all reviews + judges cached | all show `¬∑ cached` |
| [case5] unguarded stone | no guard input | tree omits guard section, shows `allowed (unguarded)` |
| [case6] artifacts only guard | guard with artifacts but no reviews/judges | tree shows artifacts, omits reviews/judges sections |
| [case7] multiple artifacts | 3 artifact files | each listed under artifacts section |
| [case8] review with nitpicks only | 0 blockers, 2 nitpicks | omit blocker line, show `2 nitpicks üü†` |
| [case9] review with both blockers and nitpicks | 3 blockers, 1 nitpick | both lines shown with respective indicators |
| [case10] cached judge that had failed | cached judge, originally failed | shows `¬∑ cached`, omits reason |
| [case11] passage line with reason | blocked + combined reasons | `passage = blocked` + `reason = ...` |

### unit tests: genContextCliEmit.test.ts

| case | scenario | expected |
|------|----------|----------|
| [case1] inflight event | emit review with `inflight.endedAt = null` | stderr shows `inflight {elapsed}s ‚†π` on last line |
| [case2] finished event after inflight | emit event with `inflight.endedAt` + `outcome` | spinner line overwritten with `finished {dur}s ‚úì` |
| [case3] non-tty mode | `isTTY = false` | no `\r` overwrites, static line prints only |
| [case4] judge finished with failure | judge outcome `decision = 'failed'` | shows `finished {dur}s ‚úó` |

### integration tests: setStoneAsPassed (collocated)

| case | scenario | expected |
|------|----------|----------|
| [case1] progress events emitted for fresh reviews | guarded stone, fresh reviews | onGuardProgress called with inflight then finished events in correct order |
| [case2] no events for cached reviews | guarded stone, cached reviews | onGuardProgress not called for cached reviews |
| [case3] progress events emitted for judges | guarded stone with judges | onGuardProgress called with judge inflight then finished events |

### acceptance tests: driver.route.set.acceptance.test.ts (update)

| case | scenario | expected |
|------|----------|----------|
| [case-new-1] stdout guard tree on passage allowed | guarded stone, reviews pass, judges pass | stdout contains guard tree with `finished ‚úì`, `passage = allowed` |
| [case-new-2] stdout guard tree on passage blocked | guarded stone, judge fails | stdout contains guard tree with `finished ‚úó`, `passage = blocked`, `reason = ...` |
| [case-new-3] stderr plan tree emitted | guarded stone | stderr contains `¬∑ queued` indicators for reviews/judges |
| [case-new-4] stdout guard tree with cached reviews | second run (same artifacts) | stdout shows `¬∑ cached` for reviews |

---

## execution sequence

```
human: `route.stone.set --stone 1.vision --route . --as passed`

  cli (route.ts):
    1. parse args
    2. progress = genContextCliEmit({ stderr: process.stderr })
    3. call stepRouteStoneSet(input, { cliEmit: progress.context.cliEmit })

  stepRouteStoneSet:
    4. propagate context to setStoneAsPassed(input, context)

  setStoneAsPassed (input, context: ContextCliEmit):
    5. find stone, get artifacts, compute hash
    6. determine cached review/judge indices

    7. runStoneGuardReviews(input, context) ‚Äî for each review:
       a. context.cliEmit.onGuardProgress({ inflight: { beganAt, endedAt: null } })
          ‚Üí spinner starts on stderr last line
       b. runOneStoneGuardReview()
       c. context.cliEmit.onGuardProgress({ inflight: { beganAt, endedAt }, outcome })
          ‚Üí spinner cleared, result lines printed

    8. runStoneGuardJudges(input, context) ‚Äî for each judge:
       a. context.cliEmit.onGuardProgress({ inflight: { beganAt, endedAt: null } })
          ‚Üí spinner starts on stderr last line
       b. runOneStoneGuardJudge()
       c. context.cliEmit.onGuardProgress({ inflight: { beganAt, endedAt }, outcome })
          ‚Üí spinner cleared, result lines printed

   10. compute passage, format emit with guard tree via formatRouteStoneEmit
   11. return result

  cli (route.ts):
   12. progress.done()
   13. console.log(result.emit.stdout)
```

---

## risks and mitigations

| risk | impact | mitigation |
|------|--------|-----------|
| `\r` overwrite leaves stale characters when new line is shorter than prior | garbled last line on stderr | pad the replacement line with trailing spaces to at least match the prior line's length |
| spinner interval not cleared on error | orphaned interval, garbled output | wrap interval lifecycle in try/finally; `progress.done()` called in cli layer's finally block |
| review/judge commands write to stderr themselves | interleaved output with our progress | capture child process stderr; only emit our progress lines to stderr |
| progress callback adds surface area to domain procedures | more args to thread | `ContextCliEmit` context type encapsulates the callback; propagates via standard `(input, context)` pattern; tests pass `{ cliEmit: { onGuardProgress: () => {} } }` |
| tree string format drifts from vision | confuse the human | snapshot tests in `formatGuardTree.test.ts` lock the exact format |
