
# blueprint: route.stone.del tune

## summary

three changes to `route.stone.del`:

1. **fuzzy pattern** â€” auto-wrap `--stone` value with `*...*` when no glob chars (`*`, `?`) are present
2. **plan/apply mode** â€” add `--mode plan|apply` (default: `plan`); plan is read-only, apply executes deletion
3. **treestruct output** â€” replace flat comma-separated output with `ðŸ¦‰` header + `ðŸ—¿` tree, with stones as a nested branch

---

## filediffs

```
src/
â”œâ”€ contract/
â”‚  â””â”€ cli/
â”‚     â””â”€ route.ts                              [~] update â€” add --mode arg parse, pass to stepRouteStoneDel
â”œâ”€ domain.operations/
â”‚  â””â”€ route/
â”‚     â”œâ”€ stepRouteStoneDel.ts                  [~] update â€” add mode + fuzzy pattern + new return shape
â”‚     â”œâ”€ stepRouteStoneDel.test.ts             [~] update â€” cover fuzzy pattern + plan mode + apply mode
â”‚     â”œâ”€ stepRouteStoneDel.integration.test.ts [~] update â€” cover plan vs apply on disk
â”‚     â”œâ”€ formatRouteStoneEmit.ts               [~] update â€” rewrite del variant with treestruct + header
â”‚     â””â”€ stones/
â”‚        â”œâ”€ asStoneGlob.ts                     [+] create â€” extract + add fuzzy auto-wrap logic
â”‚        â””â”€ asStoneGlob.test.ts                [+] create â€” unit tests for fuzzy + explicit glob
â”œâ”€ domain.roles/
â”‚  â””â”€ driver/
â”‚     â””â”€ skills/
â”‚        â””â”€ route.stone.del.sh                 [â—‹] retain â€” no change (args pass through)
blackbox/
â””â”€ driver.route.del.acceptance.test.ts         [~] update â€” cover plan default, apply mode, fuzzy pattern, treestruct output
```

---

## codepaths

```
cli: routeStoneDel()
  [~] parse --mode from argv (default: 'plan')
  [â—‹] parse --stone, --route (retain)
  [â—‹] validate required args (retain)
  [~] pass mode to stepRouteStoneDel

stepRouteStoneDel(input: { stone, route, mode })
  [â—‹] validate route dir found
  [â—‹] gather all stones via getAllStones()
  [+] normalize pattern via asStoneGlob() â€” auto-wrap if no glob chars
  [~] filter stones via isStoneInGlob() â€” use normalized glob
  [~] branch on mode:
      mode = 'plan':
        [+] classify each stone: check artifacts via getAllStoneArtifacts
        [+] return plan result (no disk mutation)
      mode = 'apply':
        [â—‹] attempt deletion for each stone via delStone (retain)
        [â—‹] catch BadRequestError for retained stones (retain)
  [~] format output via formatRouteStoneEmit (new del variant)

asStoneGlob (new file)
  [+] asStoneGlob({ pattern }) â€” if no `*` or `?` in pattern, wrap with `*...*`; else pass through
  [+] isStoneInGlob({ name, glob }) â€” convert glob to regex, test name (extract from stepRouteStoneDel)

formatRouteStoneEmit
  [+] add HEADER_DEL = "ðŸ¦‰ hoo needs 'em"
  [~] rewrite 'route.stone.del' variant:
      - accept: { operation, mode, pattern, patternRaw, route, stones: { name, status }[] }
      - emit: ðŸ¦‰ header, ðŸ—¿ tree with pattern, route, stones branch, summary counts
  [â—‹] retain get + set variants unchanged
```

---

## contracts

### stepRouteStoneDel

```ts
export const stepRouteStoneDel = async (input: {
  stone: string;
  route: string;
  mode: 'plan' | 'apply';          // new: default handled at cli layer
}): Promise<{
  pattern: string;                   // new: normalized glob pattern
  patternRaw: string;                // new: raw user input
  deleted: string[];                 // names of deleted stones (empty in plan mode)
  retained: string[];                // renamed from skipped
  stones: {                          // new: per-stone detail for treestruct
    name: string;
    status: 'delete' | 'retain';     // plan mode
  }[] | {
    name: string;
    status: 'deleted' | 'retained';  // apply mode
  }[];
  emit: { stdout: string } | null;
}>
```

### asStoneGlob

```ts
/**
 * .what = converts raw user input into a proper stone glob pattern
 * .why = enables natural word input without glob syntax knowledge
 *
 * .note = if pattern has no glob chars (* or ?), wraps with *...*
 *         if pattern already has glob chars, passes through as-is
 */
export const asStoneGlob = (input: {
  pattern: string;
}): { glob: string; raw: string }

/**
 * .what = matches a stone name against a stone glob pattern
 * .why = enables filter of stones by glob
 */
export const isStoneInGlob = (input: {
  name: string;
  glob: string;
}): boolean
```

### formatRouteStoneEmit (del variant)

```ts
// new union member for FormatInput
| {
    operation: 'route.stone.del';
    mode: 'plan' | 'apply';
    pattern: string;
    patternRaw: string;
    route: string;
    stones: { name: string; status: 'delete' | 'retain' | 'deleted' | 'retained'; reason: string | null }[];
    countDelete: number;
    countRetain: number;
  }
```

output structure:
```
ðŸ¦‰ hoo needs 'em

ðŸ—¿ route.stone.del --mode plan
   â”œâ”€ pattern = *research* (from "research")
   â”œâ”€ route   = .behavior/v2026_02_04.drive-spinners
   â”œâ”€ stones
   â”‚  â”œâ”€ âœ“ 3.1.research.access._.v1 (delete)
   â”‚  â”œâ”€ âŠ˜ 3.1.research.claims._.v1 (retain, artifact found)
   â”‚  â””â”€ âœ“ 3.1.research.templates._.v1 (delete)
   â”œâ”€ delete = 5
   â””â”€ retain = 2 (artifact found)

rerun with --mode apply to execute
```

---

## test coverage

### unit: asStoneGlob.test.ts [+] create

- `research` (no globs) â†’ normalizes to `*research*`
- `*.research.*` (has globs) â†’ pass through as-is
- `*` (wildcard) â†’ pass through as-is
- `3.1.research.domain._.v1` (exact name, no globs) â†’ normalizes to `*3.1.research.domain._.v1*`
- match/no-match assertions per pattern

### unit: stepRouteStoneDel.test.ts [~] update

- [case1â€“5] retain and update to new contract shape (mode, pattern, patternRaw, stones array)
- add cases for plan mode: verify no files removed, verify stones array has `delete`/`retain` status
- add cases for fuzzy pattern: `research` matches `3.1.research.*` stones
- update emit assertions: check treestruct format instead of flat comma-separated

### integration: stepRouteStoneDel.integration.test.ts [~] update

- plan mode: verify stones with artifacts marked as `retain`, no disk changes
- apply mode: verify stones without artifacts removed, stones with artifacts preserved
- verify emit output includes `ðŸ¦‰` header and `ðŸ—¿` treestruct

### acceptance: driver.route.del.acceptance.test.ts [~] update

- [case1] default mode = plan: invoke without `--mode`, verify no files removed, stdout has treestruct
- [case2] apply mode: invoke with `--mode apply`, verify files removed
- [case3] fuzzy pattern: invoke with `--stone research`, verify matches research stones
- [case4] retained with artifact: verify `(retain, artifact found)` / `(retained, artifact found)` in output
- update all stdout assertions from `deleted:`/`skipped` to treestruct format

---

## execution order

1. extract `asStoneGlob.ts` + `asStoneGlob.test.ts` (no deps on other changes)
2. update `stepRouteStoneDel.ts` contract (mode, fuzzy pattern, new return shape)
3. update `formatRouteStoneEmit.ts` (new del variant with treestruct)
4. update `stepRouteStoneDel.test.ts` + `stepRouteStoneDel.integration.test.ts`
5. update `src/contract/cli/route.ts` (parse `--mode`, update help text)
6. build + update `blackbox/driver.route.del.acceptance.test.ts`

