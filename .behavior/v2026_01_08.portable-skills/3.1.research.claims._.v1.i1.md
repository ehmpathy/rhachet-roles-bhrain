# research.claims for portable-skills

claims discovered via web research and reference pr analysis, relevant to:
- wish: replicate portable skills pattern from [rhachet-roles-bhuild PR #27](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)
- vision: consistency across repos, leverage lessons learned for skill portability

---

## 1. shell dispatch pattern

### [FACT] 1.1 - `exec` replaces the shell process with the target command

> "exec is often used as a wrapper script for starting other binaries. Using process replacement you can call a binary and when it takes over there is no trace of the original wrapper script in the process table or memory."
> — [Putorius: Exec Command - Process Replacement](https://www.putorius.net/exec-command.html)

### [FACT] 1.2 - wrapper scripts with `exec` are common on linux systems

> "Use of a wrapper script to set environment variables and then invoke a binary is fairly common. On Fedora 35, more than 13 percent of the files in /usr/bin start with either #!/usr/bin/sh or #!/usr/bin/bash."
> — [Red Hat Developer: Debugging binaries invoked from scripts](https://developers.redhat.com/articles/2022/12/27/debugging-binaries-invoked-scripts-gdb)

### [SUMP] 1.3 - thin proxy pattern is best practice for cli tools

> "The best way to test is by separating logic into dedicated modules and converting your executable into a simple proxy. The executable simply parses arguments with minimist and delegates to a `lib/cli.js` module that consumes the main library."
> — [Atlassian Developer Blog: Building command line tools with Node.js](https://blog.developer.atlassian.com/scripting-with-node/)

### [FACT] 1.4 - reference pr uses `exec npx tsx -e "import(...)"` dispatch pattern

> shell scripts dispatch directly against the package export:
> ```bash
> exec npx tsx -e "import('rhachet-roles-bhuild').then(m => m.cli.mySkill())" -- "$@"
> ```
> — [PR #27: portable-skills-pattern.md](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)

---

## 2. npm module resolution

### [FACT] 2.1 - local path dependencies work for offline development

> "Local paths can be placed in the dependencies section instead of real packages using syntax like `"bar": "file:../foo/bar"`. This feature is useful for local offline development and creating tests that require npm installing where you don't want to hit an external server."
> — [npm Docs](https://docs.npmjs.com/cli/v7/configuring-npm/package-json/)

### [FACT] 2.2 - `file:.` self-reference enables local package resolution

> "You can just point the package.json dependency to the actual library folder instead of the packed version and run `npm i` once. npm creates a link to the actual folder inside node_modules."
> — [DEV Community: Use npm pack to test your packages locally](https://dev.to/scooperdev/use-npm-pack-to-test-your-packages-locally-486e)

### [SUMP] 2.3 - self-reference belongs in devDependencies

> "the self-reference belongs in `devDependencies` because:
> - only needed during development (for the import to resolve to repo root)
> - at runtime (when consumed as npm dependency), standard node_modules resolution works
> - not a runtime dependency of the package itself"
> — [PR #27: portable-skills-pattern.md](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)

### [FACT] 2.4 - npx resolves packages from local node_modules first

> "npx will check whether `<command>` exists in $PATH, or in the local project binaries, and execute that. If `<command>` is not found, it will be installed prior to execution."
> — [npm Docs: npx](https://docs.npmjs.com/cli/v8/commands/npx/)

### [FACT] 2.5 - `exports` field encapsulates package internals

> "When the 'exports' field is defined, all subpaths of the package are encapsulated and no longer available to importers. When a package has an 'exports' field, this will take precedence over the 'main' field when importing the package by name."
> — [Node.js Documentation: Packages](https://nodejs.org/api/packages.html)

---

## 3. claude code hooks

### [FACT] 3.1 - hooks are shell commands executed at lifecycle events

> "A hook is a custom shell command that you create to execute automatically when a targeted event occurs in your Claude Code session, such as when Claude is about to write a file or when you submit a prompt."
> — [Claude Code Hooks Reference](https://code.claude.com/docs/en/hooks)

### [FACT] 3.2 - hooks receive CLAUDE_PROJECT_DIR environment variable

> "CLAUDE_PROJECT_DIR: Absolute path to project root (where Claude Code was started)"
> — [Claude Code Hooks Reference](https://code.claude.com/docs/en/hooks)

### [SUMP] 3.3 - absolute paths are recommended for hook scripts

> "Use absolute paths - Specify full paths for scripts (use '$CLAUDE_PROJECT_DIR' for the project path)"
> — [Claude Code Hooks Reference](https://code.claude.com/docs/en/hooks)

### [FACT] 3.4 - reference pr shifts from cli invocation to direct file paths

> from: `./node_modules/.bin/rhachet roles init --repo ehmpathy --role mechanic --command claude.hooks/sessionstart.notify-permissions`
> to: `.agent/repo=ehmpathy/role=mechanic/inits/claude.hooks/sessionstart.notify-permissions.sh`
> — [PR #27: .claude/settings.json diff](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)

### [KHUE] 3.5 - when should hooks use cli dispatch vs direct file paths?

> the pr shifts from cli-based dispatch to direct file path invocation, but does not explicitly document when one approach is preferred over the other. what are the tradeoffs?

---

## 4. tsx and typescript execution

### [FACT] 4.1 - tsx enables direct typescript execution

> "tsx can be executed with npx—a tool to run npm packages without installing them. In your command-line, simply pass in a TypeScript file you'd like to run."
> — [tsx Getting Started](https://tsx.is/getting-started)

### [FACT] 4.2 - npx adds node_modules/.bin to PATH

> "When npx runs a script, it also adds node_modules/.bin to the shell PATH."
> — [2ality: Running cross-platform tasks via npm package scripts](https://2ality.com/2022/08/npm-package-scripts.html)

### [SUMP] 4.3 - 2025 requires hybrid approach for typescript

> "In 2025, you will still most likely have to go for a hybrid approach, i.e., use a different runtime configuration for development and production."
> — [Liran Tal: TypeScript in 2025](https://lirantal.com/blog/typescript-in-2025-with-esm-and-cjs-npm-publishing)

---

## 5. cli entry points and bin configuration

### [FACT] 5.1 - bin field links executables for npm packages

> "To use this, supply a bin field in your package.json which is a map of command name to local file name. When this package is installed globally, that file will be linked where global bins go so it is available to run by name."
> — [npm Docs: package.json](https://docs.npmjs.com/cli/v7/configuring-npm/package-json/)

### [FACT] 5.2 - executables require node shebang

> "Please make sure that your file(s) referenced in bin starts with `#!/usr/bin/env node`, otherwise the scripts are started without the node executable!"
> — [npm Docs: package.json](https://docs.npmjs.com/cli/v7/configuring-npm/package-json/)

### [SUMP] 5.3 - cli entry points should export from index under cli.* namespace

> "CLI entry points MUST be exported from `src/index.ts` under `cli.*`"
> — [PR #27: portable-skills-pattern.md](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)

### [SUMP] 5.4 - cli entry points must strip rhachet passthrough args

> "CLI entry points MUST handle rhachet passthrough args (`--repo`, `--skill`, `--role`, `--`)"
> — [PR #27: portable-skills-pattern.md](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)

---

## 6. portability and consistency

### [FACT] 6.1 - resolution field ensures consistency across environments

> "The resolution field in package.json helps in avoiding version conflicts by enforcing a specific version across the project, and ensuring that all developers working on the project use the same version of dependencies, leading to consistent behavior across different environments."
> — [Medium: Simplifying Your Node.js Development with Resolution](https://medium.com/@satishsathya11/simplifying-your-node-js-development-with-resolution-in-package-json-6ad53ebade67)

### [FACT] 6.2 - native dependencies reduce portability

> "Tracking generated files leads to unnecessary noise and bloat in your Git history. Worse, because some dependencies are native and must be compiled. Checking them in makes your app less portable because you provide builds from just a single, and possibly incorrect, architecture."
> — [Julie Ng: JavaScript Best Practices and node_modules](https://julie.io/writing/javascript-node-modules/)

### [SUMP] 6.3 - shell scripts become location-independent via package import

> "shell scripts are location-independent because they import directly from the package. when rhachet symlinks skills to `.agent/repo=.../skills/`, the shell script location changes but `import('rhachet-roles-bhuild')` still resolves correctly because node module resolution happens at runtime from the consumer's node_modules."
> — [PR #27: portable-skills-pattern.md](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)

### [OPIN] 6.4 - portability is a key evaluation criterion

> "portability (10% weight factor) is evaluated based on how well patterns work 'across common stacks and CI setups.'"
> — [Claude Skills: advanced-features-2025](https://claude-plugins.dev/skills/@JosiahSiegel/claude-code-marketplace/advanced-features-2025)

---

## 7. domain operation patterns

### [SUMP] 7.1 - complex logic should move to domain.operations

> the pr establishes that complex skill logic should decompose into `src/domain.operations/` for:
> - composition and testability
> - separation from cli parsing concerns
> - reuse across multiple skills
> — [PR #27: portable-skills-pattern.md](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)

### [SUMP] 7.2 - getCliArgs with zod provides typed argument parsing

> "arg parsing via `getCliArgs({ schema: schemaOfArgs })` provides:
> - automatic rhachet arg stripping
> - Zod validation with typed output
> - schema must follow `{ named, ordered }` shape"
> — [PR #27: portable-skills-pattern.md](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)

---

## 8. plugins and skills architecture

### [FACT] 8.1 - plugins bundle hooks, commands, and skills

> "Plugins can define hooks that work across projects... Components merge seamlessly — hooks combine, commands appear in autocomplete, skills activate automatically"
> — [alexop.dev: Understanding Claude Code's Full Stack](https://alexop.dev/posts/understanding-claude-code-full-stack/)

### [FACT] 8.2 - skills are inherently modular

> "skills package expertise Claude applies automatically... skills are inherently modular—place them in ~/.claude/skills/ (personal, all projects), .claude/skills/ (project-specific), or inside plugins (team distribution)"
> — [alexop.dev: Understanding Claude Code's Full Stack](https://alexop.dev/posts/understanding-claude-code-full-stack/)

### [FACT] 8.3 - plugins have CLAUDE_PLUGIN_ROOT variable

> "Environment variables for plugins: `${CLAUDE_PLUGIN_ROOT}`: Absolute path to plugin directory"
> — [Claude Code Hooks Reference](https://code.claude.com/docs/en/hooks)

---

## 9. open questions

### [KHUE] 9.1 - what are the tradeoffs of cli dispatch vs direct file dispatch for hooks?

the reference pr shifts from cli invocation (`rhachet roles init --command ...`) to direct file paths (`.agent/.../pretooluse.check-permissions.sh`). what drove this decision? latency? simplicity? error handling?

### [KHUE] 9.2 - how should rhachet arg stripping interact with unknown args?

the pattern strips `--repo`, `--role`, `--skill`, `-s`, `--` but what happens when a skill receives an unknown arg? fail fast or pass through?

### [KHUE] 9.3 - should skills prefer tsx inline execution or compiled js?

the pattern uses `npx tsx -e "import(...)"` but typescript compilation to js would avoid tsx runtime dependency. what are the tradeoffs?

### [KHUE] 9.4 - how does this pattern interact with monorepos?

the self-reference pattern assumes a single package root. how would this work in a monorepo where multiple packages need portable skills?

---

## sources cited

1. [Putorius: Exec Command - Process Replacement](https://www.putorius.net/exec-command.html)
2. [Red Hat Developer: Debugging binaries invoked from scripts](https://developers.redhat.com/articles/2022/12/27/debugging-binaries-invoked-scripts-gdb)
3. [Atlassian Developer Blog: Building command line tools with Node.js](https://blog.developer.atlassian.com/scripting-with-node/)
4. [npm Docs: package.json](https://docs.npmjs.com/cli/v7/configuring-npm/package-json/)
5. [npm Docs: npx](https://docs.npmjs.com/cli/v8/commands/npx/)
6. [DEV Community: Use npm pack to test your packages locally](https://dev.to/scooperdev/use-npm-pack-to-test-your-packages-locally-486e)
7. [Node.js Documentation: Packages](https://nodejs.org/api/packages.html)
8. [Claude Code Hooks Reference](https://code.claude.com/docs/en/hooks)
9. [tsx Getting Started](https://tsx.is/getting-started)
10. [2ality: Running cross-platform tasks via npm package scripts](https://2ality.com/2022/08/npm-package-scripts.html)
11. [Liran Tal: TypeScript in 2025](https://lirantal.com/blog/typescript-in-2025-with-esm-and-cjs-npm-publishing)
12. [Medium: Simplifying Your Node.js Development with Resolution](https://medium.com/@satishsathya11/simplifying-your-node-js-development-with-resolution-in-package-json-6ad53ebade67)
13. [Julie Ng: JavaScript Best Practices and node_modules](https://julie.io/writing/javascript-node-modules/)
14. [alexop.dev: Understanding Claude Code's Full Stack](https://alexop.dev/posts/understanding-claude-code-full-stack/)
15. [Claude Skills: advanced-features-2025](https://claude-plugins.dev/skills/@JosiahSiegel/claude-code-marketplace/advanced-features-2025)
16. [PR #27: rhachet-roles-bhuild](https://github.com/ehmpathy/rhachet-roles-bhuild/pull/27/files)
