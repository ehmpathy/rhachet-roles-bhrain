# domain research: bhrain.struct.v1

---

## executive summary

bhrain.struct.v1 is an implementation of a replic brain architecture that replicates the claude-code pattern: a single-threaded agentic loop with pluggable tools, memory management, and permission guards. the domain consists of configuration objects, execution state, tool interfaces, and plugin contracts.

---

## 1. domain namespace treestruct

```
Bhrain
├── Config                          # root configuration entity
├── Atom                            # llm backend literal
├── Context                         # runtime context literal (DI)
│   └── Creds                       # provider credentials literal
│
├── Session                         # execution lifecycle entity
│   ├── Message                     # conversation unit literal
│   └── Subagent                    # child agent entity
│
├── Loop                            # agentic loop subdomain
│   ├── Iteration                   # single cycle literal
│   └── IterationCompletedEvent     # cycle completed event
│
├── Tool                            # tool execution subdomain
│   ├── Definition                  # tool schema literal
│   ├── Call                        # invocation request literal
│   ├── Result                      # execution output literal
│   ├── Box                         # tool collection plugin interface
│   └── ExecutionCompletedEvent     # tool executed event
│
├── Memory                          # context management subdomain
│   ├── Manager                     # optimization plugin interface
│   ├── CompactionResult            # update decision literal
│   ├── TokenUsage                  # consumption accounting literal
│   └── CompactedEvent              # context updated event
│
└── Permission                      # security policy subdomain
    ├── Guard                       # policy plugin interface
    └── Decision                    # verdict literal
```

---

## 2. domain objects

### 2.1 entities (identity + lifecycle)

#### Bhrain.Config
the root configuration for instantiating a brain.

```ts
interface BhrainConfig {
  uuid?: string;                          // instance identifier
  atom: BhrainAtom;                       // which llm backend (claude, qwen)
  toolBoxes: BhrainToolBox[];             // composable tool sources
  memoryManager: BhrainMemoryManager;     // context optimization plugin
  permissionGuard: BhrainPermissionGuard; // security policy plugin
  maxIterations: number;                  // loop termination limit
  systemPrompt?: string;                  // additional instructions
}
```
- **unique**: [uuid]
- **updatable**: [toolBoxes, memoryManager, permissionGuard]

#### Bhrain.Session
a conversation lifecycle from invocation to completion.

```ts
interface BhrainSession {
  uuid?: string;
  configUuid: string;
  status: 'ACTIVE' | 'COMPLETED' | 'TERMINATED';
  iterationCount: number;
  tokenUsage: BhrainMemoryTokenUsage;
  startedAt: string;
  endedAt?: string;
}
```
- **unique**: [uuid]
- **updatable**: [status, iterationCount, tokenUsage, endedAt]

#### Bhrain.Session.Subagent
a child agent spawned for isolated task execution.

```ts
interface BhrainSessionSubagent {
  uuid?: string;
  sessionUuid: string;
  type: 'explore' | 'plan' | 'general-purpose';
  prompt: string;
  status: 'RUNNING' | 'COMPLETED' | 'FAILED';
  result?: string;
}
```
- **unique**: [uuid]
- **updatable**: [status, result]

---

### 2.2 literals (immutable value objects)

#### Bhrain.Atom
configuration for an llm backend.

```ts
interface BhrainAtom {
  provider: 'anthropic' | 'qwen' | 'openai';
  model: string;
}
```
- note: `apiKey` and `baseUrl` come from `BhrainContext`, not input

#### Bhrain.Context
operator-provided runtime context (dependency injection).

```ts
interface BhrainContext {
  creds: {
    [provider: string]: BhrainContextCreds;  // keyed by provider name
  };
  log: LogMethods;
}

interface BhrainContextCreds {
  apiKey: string;
  url?: string;
}
```
- injected at invocation time, not declared in config
- creds keyed by provider enables multi-provider support
- e.g., `context.creds.anthropic.apiKey`, `context.creds.qwen.url`

#### Bhrain.Session.Message
the atomic unit of conversation [1].

```ts
interface BhrainSessionMessage {
  role: 'system' | 'user' | 'assistant' | 'tool';
  content: string | null;
  toolCalls?: BhrainToolCall[];
  toolCallId?: string;      // for tool result messages
  timestamp: string;
}
```

#### Bhrain.Loop.Iteration
a single cycle through the agentic loop.

```ts
interface BhrainLoopIteration {
  number: number;
  hadToolCalls: boolean;
  toolCallCount: number;
  tokenUsage: BhrainMemoryTokenUsage;
}
```

#### Bhrain.Tool.Definition
schema describing a tool's interface [2][3].

```ts
interface BhrainToolDefinition {
  name: string;
  description: string;
  inputSchema: JSONSchema;
  strict?: boolean;         // enforce exact schema match
  examples?: BhrainToolExample[];
}
```

#### Bhrain.Tool.Call
a structured request to invoke a tool [2].

```ts
interface BhrainToolCall {
  id: string;               // unique call identifier
  name: string;             // tool name
  input: Record<string, unknown>;
}
```

#### Bhrain.Tool.Result
output from tool execution [4].

```ts
interface BhrainToolResult {
  callId: string;
  success: boolean;
  output: string;
  truncated?: boolean;
  exitCode?: number;        // for bash tools
}
```

#### Bhrain.Memory.TokenUsage
accounting for context consumption.

```ts
interface BhrainMemoryTokenUsage {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
}
```

#### Bhrain.Memory.CompactionResult
output from memory manager after context optimization [6].

```ts
interface BhrainMemoryCompactionResult {
  shouldUpdate: boolean;
  newMessages?: BhrainSessionMessage[];  // replacement context if updating
  externalizedRefs?: string[];           // references to stored content
}
```

#### Bhrain.Permission.Decision
the guard's verdict on a tool call [5].

```ts
interface BhrainPermissionDecision {
  decision: 'allow' | 'deny' | 'prompt';
  reason?: string;
}
```

---

### 2.3 events (immutable records of occurrences)

#### Bhrain.Loop.IterationCompletedEvent
emitted after each agentic loop cycle.

```ts
interface BhrainLoopIterationCompletedEvent {
  sessionUuid: string;
  iterationNumber: number;
  hadToolCalls: boolean;
  tokenUsage: BhrainMemoryTokenUsage;
  occurredAt: string;
}
```
- **unique**: [sessionUuid, iterationNumber]

#### Bhrain.Tool.ExecutionCompletedEvent
emitted after tool execution.

```ts
interface BhrainToolExecutionCompletedEvent {
  sessionUuid: string;
  callId: string;
  toolName: string;
  durationMs: number;
  success: boolean;
  occurredAt: string;
}
```
- **unique**: [sessionUuid, callId]

#### Bhrain.Memory.CompactedEvent
emitted when memory manager updates context.

```ts
interface BhrainMemoryCompactedEvent {
  sessionUuid: string;
  strategy: string;
  tokensBefore: number;
  tokensAfter: number;
  occurredAt: string;
}
```
- **unique**: [sessionUuid, occurredAt]

---

## 3. domain operations

### 3.1 Bhrain operations

| operation | signature | description |
|-----------|-----------|-------------|
| invoke | `(input: { config: BhrainConfig, prompt: string }, context: BhrainContext) => BhrainSession` | instantiate brain and execute |
| configure | `(input: { config: Partial<BhrainConfig> }) => BhrainConfig` | create/update configuration |

### 3.2 Bhrain.Loop operations

| operation | signature | description |
|-----------|-----------|-------------|
| iterate | `(input: { session: BhrainSession, messages: BhrainSessionMessage[] }) => BhrainLoopIteration` | execute one loop cycle |
| terminate | `(input: { session: BhrainSession, reason: string }) => BhrainSession` | gracefully stop loop |

### 3.3 Bhrain.Tool operations

| operation | signature | description |
|-----------|-----------|-------------|
| define | `(input: { definition: BhrainToolDefinition }) => BhrainToolDefinition` | register a tool |
| execute | `(input: { call: BhrainToolCall }) => BhrainToolResult` | execute a tool call |
| mergeBoxes | `(input: { boxes: BhrainToolBox[] }) => BhrainToolDefinition[]` | combine multiple toolboxes |

### 3.4 Bhrain.Memory operations

| operation | signature | description |
|-----------|-----------|-------------|
| compact | `(input: { messages: BhrainSessionMessage[], strategy: string }) => BhrainMemoryCompactionResult` | optimize context |
| summarize | `(input: { messages: BhrainSessionMessage[] }) => BhrainSessionMessage` | condense via llm |
| truncate | `(input: { messages: BhrainSessionMessage[], limit: number }) => BhrainSessionMessage[]` | drop oldest |
| externalize | `(input: { content: string }) => BhrainMemoryExternalRef` | store outside context |

### 3.5 Bhrain.Permission operations

| operation | signature | description |
|-----------|-----------|-------------|
| check | `(input: { call: BhrainToolCall, guard: BhrainPermissionGuard }) => BhrainPermissionDecision` | evaluate policy |
| promptUser | `(input: { call: BhrainToolCall }) => boolean` | ask user approval |

---

## 4. plugin interfaces

### 4.1 Bhrain.Tool.Box
provides a collection of tools [7][8].

```ts
interface BhrainToolBox {
  name: string;
  definitions: BhrainToolDefinition[];
  execute: (input: { call: BhrainToolCall }) => Promise<BhrainToolResult>;
}
```

### 4.2 Bhrain.Memory.Manager
controls context window optimization [6][9].

```ts
interface BhrainMemoryManager {
  name: string;

  // called after each iteration
  shouldUpdate: (input: { messages: BhrainSessionMessage[] }) => boolean;

  // called when shouldUpdate returns true
  getUpdate: (input: { messages: BhrainSessionMessage[] }) => BhrainMemoryCompactionResult;

  // optional: background optimization
  observe?: (input: { messages: BhrainSessionMessage[] }) => void;
}
```

### 4.3 Bhrain.Permission.Guard
enforces security policy [5][10].

```ts
interface BhrainPermissionGuard {
  name: string;

  // called before each tool execution
  check: (input: { call: BhrainToolCall }) => BhrainPermissionDecision;
}
```

---

## 5. relationships

### 5.1 treestruct of composition

```
Bhrain.Config
├── Bhrain.Atom
├── Bhrain.Tool.Box[]
│   └── Bhrain.Tool.Definition[]
├── Bhrain.Memory.Manager
│   └── (strategy plugins)
└── Bhrain.Permission.Guard

Bhrain.Session
├── Bhrain.Config (ref)
├── Bhrain.Session.Message[]
│   ├── Bhrain.Tool.Call[]
│   └── Bhrain.Tool.Result[]
├── Bhrain.Memory.TokenUsage
└── Bhrain.Session.Subagent[]
```

### 5.2 dependency graph

```
┌─────────────────────────────────────────────────┐
│               Bhrain.Config                      │
│  (atom, toolBoxes, memoryManager, permGuard)    │
└──────────────────────┬──────────────────────────┘
                       │ creates
                       ▼
┌─────────────────────────────────────────────────┐
│               Bhrain.Session                     │
│        (messages: Bhrain.Session.Message[])      │
└──────────────────────┬──────────────────────────┘
                       │ runs
                       ▼
┌─────────────────────────────────────────────────┐
│               Bhrain.Loop                        │
│   generate → check tools → execute → append     │
└──────┬───────────────┬──────────────────────────┘
       │               │
       ▼               ▼
┌──────────────────┐  ┌───────────────────────────┐
│Bhrain.Memory     │  │   Bhrain.Permission       │
│  .Manager        │  │     .Guard                │
│ (compact?)       │  │   (allow/deny/prompt?)    │
└──────────────────┘  └───────────────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │  Bhrain.Tool.Box │
                    │    (execute)     │
                    └──────────────────┘
```

### 5.3 subagent isolation

```
Bhrain.Session (parent)           Bhrain.Session.Subagent
┌────────────────────┐           ┌────────────────────┐
│ messages: 50k      │ ──spawn─▶ │ messages: 0        │
│ tokens             │           │ (fresh context)    │
└────────────────────┘           └────────────────────┘
          ▲                               │
          │        ◀── return summary ────┘
          │          (1-2k tokens)
```

---

## 6. how domains compose to support the wish

### 6.1 invocation flow

```
1. CLI parses: --arch bhrain.struct.v1 --atom qwen --input "..."

2. Bhrain.Config created with:
   - atom: Bhrain.Atom = { provider: 'qwen', model: 'qwen-2.5' }
   - toolBoxes: Bhrain.Tool.Box[] = [filesBox, bashBox, websearchBox]
   - memoryManager: Bhrain.Memory.Manager = summarizeOnLimit
   - permissionGuard: Bhrain.Permission.Guard = promptForWrites

3. Bhrain.Session created

4. Bhrain.Loop started with user input as first Bhrain.Session.Message

5. Loop iterates until no Bhrain.Tool.Call in response

6. Final Bhrain.Session.Message returned
```

### 6.2 tool execution flow

```
1. LLM generates Bhrain.Tool.Call[] in response

2. For each call:
   2a. Bhrain.Permission.Guard.check({ call }) → Bhrain.Permission.Decision
   2b. If 'deny': append denial as Bhrain.Tool.Result, continue
   2c. If 'prompt': await Bhrain.Permission.promptUser({ call })
   2d. If 'allow': Bhrain.Tool.Box.execute({ call }) → Bhrain.Tool.Result

3. Append Bhrain.Tool.Result to Bhrain.Session.Message[]

4. Bhrain.Memory.Manager.shouldUpdate({ messages })?
   4a. If true: messages = getUpdate({ messages }).newMessages

5. Continue Bhrain.Loop
```

### 6.3 plugin composition

```
bhrain.struct.v1
├── core (non-pluggable)
│   ├── Bhrain.Loop (agentic iteration)
│   ├── Bhrain.Session.Message (conversation handling)
│   └── Bhrain.Atom (llm integration)
│
└── plugins (pluggable)
    ├── Bhrain.Tool.Box[]: [filesBox, bashBox, websearchBox, ...]
    ├── Bhrain.Memory.Manager: summarizeOnLimit | truncate | custom
    └── Bhrain.Permission.Guard: allowAll | promptForWrites | custom
```

---

## 7. citations

| # | source | quote |
|---|--------|-------|
| 1 | [Anthropic: Building Effective Agents](https://www.anthropic.com/research/building-effective-agents) | "The basic building block of agentic systems is an LLM enhanced with augmentations such as retrieval, tools, and memory." |
| 2 | [Claude Docs: Tool Use](https://platform.claude.com/docs/en/agents-and-tools/tool-use/implement-tool-use) | "Claude tool definitions require a description and an input_schema (a JSON Schema object defining the parameters)." |
| 3 | [Anthropic: Advanced Tool Use](https://www.anthropic.com/engineering/advanced-tool-use) | "Agents need to learn correct tool usage from examples, not just schema definitions." |
| 4 | [PromptLayer: Claude Code Behind the Scenes](https://blog.promptlayer.com/claude-code-behind-the-scenes-of-the-master-agent-loop/) | "Each step builds logically on the previous one, creating a transparent audit trail of the agent's reasoning and actions." |
| 5 | [Cerbos: Permission Management for AI Agents](https://www.cerbos.dev/blog/permission-management-for-ai-agents) | "Granular access control means defining precisely which tools an agent can call." |
| 6 | [Anthropic: Effective Context Engineering](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents) | "Compaction is the practice of taking a conversation nearing the context window limit, summarizing its contents, and reinitiating a new context window with the summary." |
| 7 | [ZenML: Claude Code Agent Architecture](https://www.zenml.io/llmops-database/claude-code-agent-architecture-single-threaded-master-loop-for-autonomous-coding) | "The core thesis underlying Claude Code's design philosophy centers on the principle that 'a simple, single-threaded master loop combined with disciplined tools and planning delivers controllable autonomy.'" |
| 8 | [Anthropic: Building Agents with Claude Agent SDK](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk) | "Subagents are pre-configured AI personalities that Claude Code can delegate tasks to... Each subagent operates in its own context, preventing pollution of the main conversation." |
| 9 | [MemGPT Paper](https://arxiv.org/abs/2310.08560) | "MemGPT proposes virtual context management, a technique drawing inspiration from hierarchical memory systems in traditional operating systems." |
| 10 | [Permit.io: Access Request MCP](https://www.permit.io/blog/delegating-ai-permissions-to-human-users-with-permitios-access-request-mcp) | "By introducing human-in-the-loop approval at key decision points, you get: Safety, Accountability, and Control." |
| 11 | [Letta: Agent Memory](https://www.letta.com/blog/agent-memory) | "What an agent 'remembers' is fundamentally determined by what exists in its context window at any given moment... designing an agent's memory is essentially context engineering." |
| 12 | [Claude Docs: Subagents](https://platform.claude.com/docs/en/agent-sdk/subagents) | "Subagents help manage context: they use their own isolated context windows, and only send relevant information back to the orchestrator." |

---

## 8. prior art references

### internal briefs (src/roles/architect/briefs/brains.replic/)

| concept | brief |
|---------|-------|
| agentic-loop | arc109.concept.agentic-loop.[article].md |
| tool-definition | arc106.concept.tool-definition.[article].md |
| tool-call | arc107.concept.tool-call.[article].md |
| tool-result | arc108.concept.tool-result.[article].md |
| context-compaction | arc116.concept.context-compaction.[article].md |
| message | arc121.concept.message.[article].md |
| subagent | arc117.concept.subagent.[article].md |
| claude-code blueprint | arc201.blueprint.claude-code.[article].md |
| concepts treestruct | arc150.concepts.treestruct.[article].md |

---

## 9. open questions

1. **streaming**: should the loop support streaming responses, or batch only?
2. **subagent recursion**: can subagents spawn their own subagents? what's the depth limit?
3. **toolbox versioning**: how to handle tool definition changes mid-session?
4. **memory manager state**: does the manager maintain state between iterations, or is it stateless?
5. **permission persistence**: can approvals be remembered for session duration?
